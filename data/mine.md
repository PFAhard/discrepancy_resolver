## Low Risk Issues

|Index|Issue|Instances|
|:---:|:---|:---:|
| [L-01](#L-01) | [Loss of precision](#L-01) | 14 |
| [L-02](#L-02) | [Solidity version 0.8.20 may not work on other chains due to `PUSH0`](#L-02) | 10 |
| [L-03](#L-03) | [Large assembly blocks should have extensive comments](#L-03) | 9 |
| [L-04](#L-04) | [Code does not follow the best practice of check-effects-interaction](#L-04) | 9 |
| [L-05](#L-05) | [Array lengths not checked](#L-05) | 7 |
| [L-06](#L-06) | [Prevent division by 0](#L-06) | 6 |
| [L-07](#L-07) | [Missing contract-existence checks before low-level calls](#L-07) | 6 |
| [L-08](#L-08) | [Missing checks for `address(0)` when assigning values to address state variables](#L-08) | 4 |
| [L-09](#L-09) | [Privileged functions can create points of failure](#L-09) | 4 |
| [L-10](#L-10) | [Consider bounding input array length](#L-10) | 3 |
| [L-11](#L-11) | [Emitting storage values instead of the memory one.](#L-11) | 2 |
| [L-12](#L-12) | [`tokenURI` should throw an error if `_tokenId` is not a valid `NFT`](#L-12) | 1 |
| [L-13](#L-13) | [NFT doesn't handle hardforks](#L-13) | 1 |
| [L-14](#L-14) | [Functions calling contracts/addresses with transfer hooks are missing reentrancy guards](#L-14) | 1 |
| [L-15](#L-15) | [Use `.call()` instead of `.send()` or `.transfer()`](#L-15) | 1 |

78 instances over 15 issues

---

## NonCritical Risk Issues

|Index|Issue|Instances|
|:---:|:---|:---:|
| [N-01](#N-01) | [`Constants` in comparisons should appear on the left side](#N-01) | 107 |
| [N-02](#N-02) | [Unused contract variables](#N-02) | 83 |
| [N-03](#N-03) | [Contract functions should use an `interface`](#N-03) | 51 |
| [N-04](#N-04) | [NatSpec` @param` is missing](#N-04) | 48 |
| [N-05](#N-05) | [Function declarations should have NatSpec descriptions](#N-05) | 44 |
| [N-06](#N-06) | [`constants` should be defined rather than using magic numbers](#N-06) | 38 |
| [N-07](#N-07) | [NatSpec `@return` argument is missing](#N-07) | 37 |
| [N-08](#N-08) | [Variable names don't follow the Solidity naming convention](#N-08) | 30 |
| [N-09](#N-09) | [Custom `error` without details](#N-09) | 29 |
| [N-10](#N-10) | [`Import` only specific files](#N-10) | 27 |
| [N-11](#N-11) | [Do not use underscore at the end of variable name](#N-11) | 27 |
| [N-12](#N-12) | [Event declarations should have NatSpec descriptions](#N-12) | 26 |
| [N-13](#N-13) | [Event is missing `indexed` field](#N-13) | 21 |
| [N-14](#N-14) | [Duplicated `require/if` statements should be refactored](#N-14) | 20 |
| [N-15](#N-15) | [Use SafeCast to safely downcast variables](#N-15) | 19 |
| [N-16](#N-16) | [Use multiple `require()` and `if` statements instead of `&&`](#N-16) | 18 |
| [N-17](#N-17) | [Function state mutability can be restricted to pure](#N-17) | 16 |
| [N-18](#N-18) | [A function which defines named returns in it's declaration doesn't need to use return](#N-18) | 15 |
| [N-19](#N-19) | [State variables should include comments](#N-19) | 12 |
| [N-20](#N-20) | [Change `public` to `external` for functions that are not called internally](#N-20) | 10 |
| [N-21](#N-21) | [`if`-statement can be converted to a ternary](#N-21) | 10 |
| [N-22](#N-22) | [Emits without msg.sender parameter](#N-22) | 9 |
| [N-23](#N-23) | [Using named parameters in `mapping` is best practice](#N-23) | 9 |
| [N-24](#N-24) | [Remaining eth may not be refunded to users](#N-24) | 9 |
| [N-25](#N-25) | [Function names should differ to make the code more readable](#N-25) | 8 |
| [N-26](#N-26) | [Consider using `delete` rather than assigning zero/false to clear values](#N-26) | 7 |
| [N-27](#N-27) | [External calls in an un-bounded `for`-loop may result in a DOS](#N-27) | 7 |
| [N-28](#N-28) | [Events may be emitted out of order due to reentrancy](#N-28) | 7 |
| [N-29](#N-29) | [Function state mutability can be restricted to view](#N-29) | 6 |
| [N-30](#N-30) | [Use of `override` is unnecessary](#N-30) | 6 |
| [N-31](#N-31) | [Modifier declarations should have NatSpec descriptions](#N-31) | 6 |
| [N-32](#N-32) | [Setters should prevent re-setting of the same value](#N-32) | 5 |
| [N-33](#N-33) | [Expressions for constant values should use `immutable` rather than `constant`](#N-33) | 5 |
| [N-34](#N-34) | [`constructor` missing zero address check](#N-34) | 4 |
| [N-35](#N-35) | [Variable initialization with default value](#N-35) | 4 |
| [N-36](#N-36) | [Consider implementing two-step procedure for updating protocol addresses](#N-36) | 4 |
| [N-37](#N-37) | [Missing event and or timelock for critical parameter change](#N-37) | 4 |
| [N-38](#N-38) | [Consider adding a block/deny-list](#N-38) | 4 |
| [N-39](#N-39) | [Events should use parameters to convey information](#N-39) | 4 |
| [N-40](#N-40) | [Keccak state variables should be immutable not constant](#N-40) | 3 |
| [N-41](#N-41) | [Events that mark critical parameter changes should contain both the old and the new value](#N-41) | 3 |
| [N-42](#N-42) | [Long functions should be refactored into multiple, smaller, functions](#N-42) | 3 |
| [N-43](#N-43) | [Named imports of parent contracts are missing](#N-43) | 3 |
| [N-44](#N-44) | [`else`-block not required](#N-44) | 2 |
| [N-45](#N-45) | [Condition will not revert when `block.timestamp` is `==` to the compared variable](#N-45) | 2 |
| [N-46](#N-46) | [Large multiples of ten should use scientific notation](#N-46) | 2 |
| [N-47](#N-47) | [Custom `error` should be used rather than `require`/`assert`](#N-47) | 2 |
| [N-48](#N-48) | [`require`/`revert` without any message](#N-48) | 2 |
| [N-49](#N-49) | [Array indicies should be referenced via `enum`s rather than via numeric literals](#N-49) | 2 |
| [N-50](#N-50) | [Unused function parameter](#N-50) | 2 |
| [N-51](#N-51) | [Overflows in unchecked blocks](#N-51) | 2 |
| [N-52](#N-52) | [Empty function blocks](#N-52) | 1 |
| [N-53](#N-53) | [`Constant` name must be in capitalized `SNAKE_CASE`](#N-53) | 1 |
| [N-54](#N-54) | [Array is `push()`ed but not `pop()`ed](#N-54) | 1 |
| [N-55](#N-55) | [Assembly block creates dirty bits](#N-55) | 1 |
| [N-56](#N-56) | [Complex math should be split into multiple steps](#N-56) | 1 |
| [N-57](#N-57) | [Function names should use lowerCamelCase](#N-57) | 1 |
| [N-58](#N-58) | [Contracts should have full test coverage](#N-58) | 1 |
| [N-59](#N-59) | [Large or complicated code bases should implement invariant tests](#N-59) | 1 |
| [N-60](#N-60) | [Codebase should implement formal verification testing](#N-60) | 1 |

833 instances over 60 issues

---

## Gas Risk Issues

|Index|Issue|Instances|
|:---:|:---|:---:|
| [G-01](#G-01) | [Usage of `uint`/`int` smaller than 32 bytes (256 bits) incurs overhead](#G-01) | 146 |
| [G-02](#G-02) | [Delete Unused State Variables](#G-02) | 83 |
| [G-03](#G-03) | [Optimize Zero Checks Using Assembly](#G-03) | 73 |
| [G-04](#G-04) | [State variables should be cached in stack variables rather than re-reading them from storage](#G-04) | 67 |
| [G-05](#G-05) | [Use Assembly for Efficient Event Emission](#G-05) | 39 |
| [G-06](#G-06) | [Optimize External Calls with Assembly for Memory Efficiency](#G-06) | 36 |
| [G-07](#G-07) | [Avoid Unnecessary Public Variables](#G-07) | 33 |
| [G-08](#G-08) | [Consider Using Solady's Gas Optimized Lib for Math](#G-08) | 27 |
| [G-09](#G-09) | [Stack variable used as a cheaper cache for a state variable is only used once](#G-09) | 21 |
| [G-10](#G-10) | [Optimize Gas by Using Only Named Returns](#G-10) | 21 |
| [G-11](#G-11) | [Trade-offs Between Modifiers and Internal Functions](#G-11) | 20 |
| [G-12](#G-12) | [Use assembly to check for `address(0)`](#G-12) | 18 |
| [G-13](#G-13) | [Consider Packing Small `uint` When it's Possible](#G-13) | 18 |
| [G-14](#G-14) | [`>=` costs less gas than `>`](#G-14) | 16 |
| [G-15](#G-15) | [Consider Caching Multiple Accesses to Mappings/Arrays](#G-15) | 15 |
| [G-16](#G-16) | [Add `unchecked` blocks for divisions where the operands cannot overflow](#G-16) | 14 |
| [G-17](#G-17) | [Optimize Gas by Using Do-While Loops](#G-17) | 11 |
| [G-18](#G-18) | [`++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops](#G-18) | 10 |
| [G-19](#G-19) | [Use at least Solidity version `0.8.19` to gain some gas boost](#G-19) | 10 |
| [G-20](#G-20) | [Optimize Unsigned Integer Comparison With Zero](#G-20) | 10 |
| [G-21](#G-21) | [`<array>.length` Should Not Be Looked Up In Every Loop Of A For-loop](#G-21) | 7 |
| [G-22](#G-22) | [Using `bool` for storage incurs overhead](#G-22) | 7 |
| [G-23](#G-23) | [Optimize Boolean States with `uint256(1/2)`](#G-23) | 7 |
| [G-24](#G-24) | [`Internal` functions only called once can be inlined to save gas](#G-24) | 6 |
| [G-25](#G-25) | [Using `storage` instead of `memory` for structs/arrays saves gas](#G-25) | 6 |
| [G-26](#G-26) | [Consider using `bytes32` rather than a `string`](#G-26) | 6 |
| [G-27](#G-27) | [Setting the `constructor` to `payable`](#G-27) | 5 |
| [G-28](#G-28) | [State variables access within a loop](#G-28) | 5 |
| [G-29](#G-29) | [Use Assembly for Hash Calculations](#G-29) | 5 |
| [G-30](#G-30) | [Function calls should be cached instead of re-calling the function](#G-30) | 4 |
| [G-31](#G-31) | [Multiple mappings can be replaced with a single struct mapping](#G-31) | 3 |
| [G-32](#G-32) | [Optimize by Using Assembly for Low-Level Calls' Return Data](#G-32) | 3 |
| [G-33](#G-33) | [Use Custom Errors](#G-33) | 2 |
| [G-34](#G-34) | [State Variables can be packed into fewer storage slots](#G-34) | 2 |
| [G-35](#G-35) | [`selfbalance()` is cheaper than `address(this).balance`](#G-35) | 1 |
| [G-36](#G-36) | [Functions guaranteed to revert when called by normal users can be marked `payable`](#G-36) | 1 |
| [G-37](#G-37) | [Using `private` for constants saves gas](#G-37) | 1 |
| [G-38](#G-38) | [Consider activating `via-ir` for deploying](#G-38) | 1 |
| [G-39](#G-39) | [Multiplication/division by two should use bit shifting](#G-39) | 1 |
| [G-40](#G-40) | [Using `private` for `constants` saves gas](#G-40) | 1 |

762 instances over 40 issues

---

## Disputed Risk Issues

|Index|Issue|Instances|
|:---:|:---|:---:|
| [D-01](#D-01) | [Control structures do not comply with best practices](#D-01) | 156 |
| [D-02](#D-02) | [Optimize Gas Spend Using `0.8.20` and Optimizer Features](#D-02) | 10 |
| [D-03](#D-03) | [`abi.encode()` is less efficient than `abi.encodepacked()`](#D-03) | 1 |

167 instances over 3 issues

---



## Low Risk Issues

### [L-01] Loss of precision
<a name="L-01"></a>
[To the top](#TOP)

Division by large numbers may result in the result being zero, due to solidity not supporting fractions. Consider requiring a minimum amount for the numerator to ensure that it is always larger than the denominator

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 14 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
...
270	        votingPower = (amount * exchangeRateBps) / 1e4;
...
281	        amount = (votingPower * 1e4) / exchangeRateBps;
...
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
...
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
...
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
...
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
```
[266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L266)
[270](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L270)
[281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L281)
[287](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L287)
[325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L325)
[329](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L329)
[355](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L355)

---

	 - contracts/party/PartyGovernance.sol

```solidity
434	            uint256 mid = (low + high) / 2;
...
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
...
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
```
[434](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L434)
[1115](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1115)
[1134](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1134)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
...
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
...
413	                uint256 fee = (amount * feeBps_) / 1e4;
```
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)
[393](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L393)
[413](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L413)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
```
[74](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L74)


</details>

-------
### [L-02] Solidity version 0.8.20 may not work on other chains due to `PUSH0`
<a name="L-02"></a>
[To the top](#TOP)

The compiler for Solidity 0.8.20 switches the default target EVM version to [Shanghai](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note), which includes the new PUSH0 op code. This op code may not yet be implemented on all L2s, so deployment on these chains will fail. To work around this issue, use an earlier [EVM](https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html?ref=zaryabs.com#setting-the-evm-version-to-target) [version](https://book.getfoundry.sh/reference/config/solidity-compiler#evm_version)

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 10 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L2)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L2)

---

	 - contracts/party/PartyGovernance.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L2)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L2)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L2)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L2)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L2)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L2)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L2)

---

	 - contracts/utils/Implementation.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L2)


</details>

-------
### [L-03] Large assembly blocks should have extensive comments
<a name="L-03"></a>
[To the top](#TOP)

Assembly blocks are take a lot more time to audit than normal Solidity code, and often have gotchas and side-effects that the Solidity versions of the same code do not. Consider adding more comments explaining what is being done in every step of the assembly code

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 9 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
319	            assembly {
320	                let freeMem := mload(0x40)
321	                mstore(freeMem, functionSelector)
322	                mstore(0x40, add(freeMem, 0x20))
323	                return(freeMem, 0x20)
324	            }
325	        }
...
407	        assembly {
408	            // Overwrite the data field with the hash of its contents and then
409	            // hash the struct.
410	            let dataPos := add(proposal, 0x40)
411	            let t := mload(dataPos)
412	            mstore(dataPos, dataHash)
413	            proposalHash := keccak256(proposal, 0x60)
414	            // Restore the data field.
415	            mstore(dataPos, t)
416	        }
417	    }
...
1158	        assembly {
1159	            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))
1160	            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))
1161	            h := keccak256(0x00, 0x40)
1162	        }
1163	    }
```
[319..325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L319-L325)
[407..417](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L407-L417)
[1158..1163](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1158-L1163)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
306	        assembly {
307	            // By reading 4 bytes into the length prefix, the leading 4 bytes
308	            // of the data will be in the lower bits of the read word.
309	            proposalType := and(mload(add(proposalData, 4)), 0xffffffff)
310	            mstore(add(proposalData, 4), sub(mload(proposalData), 4))
311	            offsetProposalData := add(proposalData, 4)
312	        }
313	        require(proposalType != ProposalType.Invalid);
...
337	        assembly {
338	            stor.slot := slot
339	        }
340	    }
```
[306..313](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L306-L313)
[337..340](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L337-L340)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
61	        assembly {
62	            stor.slot := s
63	        }
```
[61..63](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L61-L63)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
53	        assembly {
54	            stor.slot := slot
55	        }
```
[53..55](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L53-L55)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
32	        assembly {
33	            // First word of signature after size contains r
34	            r := mload(add(signature, 0x20))
35	            s := mload(add(signature, 0x40))
36	            // v is one byte which starts after s. type is uint8 so extra data will be ignored
37	            v := mload(add(signature, 0x41))
38	        }
...
41	        assembly {
42	            // Raw message data begins after v. Overwriting part of s and v with size of `message`
43	            message := add(signature, 0x41)
44	            mstore(message, sub(mload(signature), 0x41))
45	        }
```
[32..38](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L32-L38)
[41..45](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L41-L45)


</details>

-------
### [L-04] Code does not follow the best practice of check-effects-interaction
<a name="L-04"></a>
[To the top](#TOP)

Code should follow the best-practice of [check-effects-interaction](https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-11-coding-patterns/topic/checks-effects-interactions/), where state variables are updated before any external calls are made. Doing so prevents a large class of reentrancy bugs.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 9 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
255	    function batchContributeFor(
256	        BatchContributeForArgs calldata args
257	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
258	        votingPowers = new uint96[](args.recipients.length);
259	        uint256 valuesSum;
260	        for (uint256 i; i < args.recipients.length; ++i) {
261	            votingPowers[i] = _contribute(
262	                args.recipients[i],
263	                args.initialDelegates[i],
264	                args.values[i],
265	                args.tokenIds[i],
266	                args.gateDatas[i]
267	            );
268	            valuesSum += args.values[i];
269	        }
270	        if (msg.value != valuesSum) {
271	            revert InvalidMessageValue();
272	        }
273	    }
...
275	    function _contribute(
276	        address payable contributor,
277	        address delegate,
278	        uint96 amount,
279	        uint256 tokenId,
280	        bytes memory gateData
281	    ) private returns (uint96 votingPower) {
282	        // Require a non-null delegate.
283	        if (delegate == address(0)) {
284	            revert InvalidDelegateError();
285	        }
286	
287	        // Must not be blocked by gatekeeper.
288	        IGateKeeper _gateKeeper = gateKeeper;
289	        if (_gateKeeper != IGateKeeper(address(0))) {
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
291	                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);
292	            }
293	        }
294	
295	        votingPower = _processContribution(contributor, delegate, amount);
296	
297	        // OK to contribute with zero just to update delegate.
298	        if (amount == 0) return 0;
299	
300	        if (tokenId == 0) {
301	            // Mint contributor a new party card.
302	            party.mint(contributor, votingPower, delegate);
303	        } else if (disableContributingForExistingCard) {
304	            revert ContributingForExistingCardDisabledError();
305	        } else if (party.ownerOf(tokenId) == contributor) {
306	            // Increase voting power of contributor's existing party card.
307	            party.increaseVotingPower(tokenId, votingPower);
308	        } else {
309	            revert NotOwnerError(tokenId);
310	        }
311	    }
```
[255..273](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L255-L273)
[275..311](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L275-L311)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
140	    function _initialize(ETHCrowdfundOptions memory opts) internal {
141	        // Set the minimum and maximum contribution amounts.
142	        if (opts.minContribution > opts.maxContribution) {
143	            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);
144	        }
145	        minContribution = opts.minContribution;
146	        maxContribution = opts.maxContribution;
147	        // Set the min total contributions.
148	        if (opts.minTotalContributions > opts.maxTotalContributions) {
149	            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);
150	        }
151	        minTotalContributions = opts.minTotalContributions;
152	        // Set the max total contributions.
153	        if (opts.maxTotalContributions == 0) {
154	            // Prevent this because when `maxTotalContributions` is 0 the
155	            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has
156	            // never been initialized.
157	            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);
158	        }
159	        maxTotalContributions = opts.maxTotalContributions;
160	        // Set the party crowdfund is for.
161	        party = opts.party;
162	        // Set the crowdfund start and end timestamps.
163	        expiry = uint40(block.timestamp + opts.duration);
164	        // Set the exchange rate.
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
166	        exchangeRateBps = opts.exchangeRateBps;
167	        // Set the funding split and its recipient.
168	        fundingSplitBps = opts.fundingSplitBps;
169	        fundingSplitRecipient = opts.fundingSplitRecipient;
170	        // Set whether to disable contributing for existing card.
171	        disableContributingForExistingCard = opts.disableContributingForExistingCard;
172	    }
173	
...
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
```
[140..173](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L140-L173)
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)

---

	 - contracts/party/PartyGovernance.sol

```solidity
270	    function _initialize(
271	        GovernanceOpts memory govOpts,
272	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
273	        IERC721[] memory preciousTokens,
274	        uint256[] memory preciousTokenIds
275	    ) internal virtual {
276	        // Check BPS are valid.
277	        if (govOpts.feeBps > 1e4) {
278	            revert InvalidBpsError(govOpts.feeBps);
279	        }
280	        if (govOpts.passThresholdBps > 1e4) {
281	            revert InvalidBpsError(govOpts.passThresholdBps);
282	        }
283	        // Initialize the proposal execution engine.
284	        _initProposalImpl(
285	            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),
286	            abi.encode(proposalEngineOpts)
287	        );
288	        // Set the governance parameters.
289	        _getSharedProposalStorage().governanceValues = GovernanceValues({
290	            voteDuration: govOpts.voteDuration,
291	            executionDelay: govOpts.executionDelay,
292	            passThresholdBps: govOpts.passThresholdBps,
293	            totalVotingPower: govOpts.totalVotingPower
294	        });
295	        numHosts = uint8(govOpts.hosts.length);
296	        // Set fees.
297	        feeBps = govOpts.feeBps;
298	        feeRecipient = govOpts.feeRecipient;
299	        // Set the precious list.
300	        _setPreciousList(preciousTokens, preciousTokenIds);
301	        // Set the party hosts.
302	        if (govOpts.hosts.length > type(uint8).max) {
303	            revert TooManyHosts();
304	        }
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
309	
...
706	    function execute(
707	        uint256 proposalId,
708	        Proposal memory proposal,
709	        IERC721[] memory preciousTokens,
710	        uint256[] memory preciousTokenIds,
711	        bytes calldata progressData,
712	        bytes calldata extraData
713	    ) external payable {
714	        _assertNotGloballyDisabled();
715	        _assertActiveMember();
716	        // Get information about the proposal.
717	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
718	        // Proposal details must remain the same from `propose()`.
719	        _validateProposalHash(proposal, proposalState.hash);
720	        ProposalStateValues memory values = proposalState.values;
721	        ProposalStatus status = _getProposalStatus(values);
722	        // The proposal must be executable or have already been executed but still
723	        // has more steps to go.
724	        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {
725	            revert BadProposalStatusError(status);
726	        }
727	        if (status == ProposalStatus.Ready) {
728	            // If the proposal has not been executed yet, make sure it hasn't
729	            // expired. Note that proposals that have been executed
730	            // (but still have more steps) ignore `maxExecutableTime`.
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
738	        }
739	        // Check that the precious list is valid.
740	        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {
741	            revert BadPreciousListError();
742	        }
743	        // Preemptively set the proposal to completed to avoid it being executed
744	        // again in a deeper call.
745	        proposalState.values.completedTime = uint40(block.timestamp);
746	        // Execute the proposal.
747	        bool completed = _executeProposal(
748	            proposalId,
749	            proposal,
750	            preciousTokens,
751	            preciousTokenIds,
752	            _getProposalFlags(values),
753	            progressData,
754	            extraData
755	        );
756	        if (!completed) {
757	            // Proposal did not complete.
758	            proposalState.values.completedTime = 0;
759	        }
760	    }
761	
```
[270..309](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L270-L309)
[706..761](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L706-L761)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
81	    function _initialize(
82	        string memory name_,
83	        string memory symbol_,
84	        uint256 customizationPresetId,
85	        PartyGovernance.GovernanceOpts memory governanceOpts,
86	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
87	        IERC721[] memory preciousTokens,
88	        uint256[] memory preciousTokenIds,
89	        address[] memory authorities,
90	        uint40 rageQuitTimestamp_
91	    ) internal {
92	        PartyGovernance._initialize(
93	            governanceOpts,
94	            proposalEngineOpts,
95	            preciousTokens,
96	            preciousTokenIds
97	        );
98	        name = name_;
99	        symbol = symbol_;
100	        rageQuitTimestamp = rageQuitTimestamp_;
101	        unchecked {
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
105	        }
106	        if (customizationPresetId != 0) {
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
109	        }
110	    }
...
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
```
[81..110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L81-L110)
[344..448](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L344-L448)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
25	    function _executeSetGovernanceParameter(
26	        IProposalExecutionEngine.ExecuteProposalParams memory params
27	    ) internal returns (bytes memory) {
28	        SetGovernanceParameterProposalData memory proposalData = abi.decode(
29	            params.proposalData,
30	            (SetGovernanceParameterProposalData)
31	        );
32	        if (proposalData.voteDuration != 0) {
33	            if (proposalData.voteDuration < 1 hours) {
34	                revert InvalidGovernanceParameter(proposalData.voteDuration);
35	            }
36	            emit VoteDurationSet(
37	                _getSharedProposalStorage().governanceValues.voteDuration,
38	                proposalData.voteDuration
39	            );
40	            _getSharedProposalStorage().governanceValues.voteDuration = proposalData.voteDuration;
41	        }
42	        if (proposalData.executionDelay != 0) {
43	            if (proposalData.executionDelay > 30 days) {
44	                revert InvalidGovernanceParameter(proposalData.executionDelay);
45	            }
46	            emit ExecutionDelaySet(
47	                _getSharedProposalStorage().governanceValues.executionDelay,
48	                proposalData.executionDelay
49	            );
50	            _getSharedProposalStorage().governanceValues.executionDelay = proposalData
51	                .executionDelay;
52	        }
53	        if (proposalData.passThresholdBps != 0) {
54	            if (proposalData.passThresholdBps > 10000) {
55	                revert InvalidGovernanceParameter(proposalData.passThresholdBps);
56	            }
57	            emit PassThresholdBpsSet(
58	                _getSharedProposalStorage().governanceValues.passThresholdBps,
59	                proposalData.passThresholdBps
60	            );
61	            _getSharedProposalStorage().governanceValues.passThresholdBps = proposalData
62	                .passThresholdBps;
63	        }
64	
65	        return "";
66	    }
```
[25..66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L25-L66)


</details>

-------
### [L-05] Array lengths not checked
<a name="L-05"></a>
[To the top](#TOP)

If the length of the arrays are not required to be of the same length, user operations may not be fully executed due to a mismatch in the number of items iterated over, versus the number of items provided in the second array

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 7 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
270	    function _initialize(
271	        GovernanceOpts memory govOpts,
272	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
273	        IERC721[] memory preciousTokens,
274	        uint256[] memory preciousTokenIds
275	    ) internal virtual {
276	        // Check BPS are valid.
277	        if (govOpts.feeBps > 1e4) {
278	            revert InvalidBpsError(govOpts.feeBps);
279	        }
280	        if (govOpts.passThresholdBps > 1e4) {
281	            revert InvalidBpsError(govOpts.passThresholdBps);
282	        }
283	        // Initialize the proposal execution engine.
284	        _initProposalImpl(
285	            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),
286	            abi.encode(proposalEngineOpts)
287	        );
288	        // Set the governance parameters.
289	        _getSharedProposalStorage().governanceValues = GovernanceValues({
290	            voteDuration: govOpts.voteDuration,
291	            executionDelay: govOpts.executionDelay,
292	            passThresholdBps: govOpts.passThresholdBps,
293	            totalVotingPower: govOpts.totalVotingPower
294	        });
295	        numHosts = uint8(govOpts.hosts.length);
296	        // Set fees.
297	        feeBps = govOpts.feeBps;
298	        feeRecipient = govOpts.feeRecipient;
299	        // Set the precious list.
300	        _setPreciousList(preciousTokens, preciousTokenIds);
301	        // Set the party hosts.
302	        if (govOpts.hosts.length > type(uint8).max) {
303	            revert TooManyHosts();
304	        }
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
309	
...
706	    function execute(
707	        uint256 proposalId,
708	        Proposal memory proposal,
709	        IERC721[] memory preciousTokens,
710	        uint256[] memory preciousTokenIds,
711	        bytes calldata progressData,
712	        bytes calldata extraData
713	    ) external payable {
714	        _assertNotGloballyDisabled();
715	        _assertActiveMember();
716	        // Get information about the proposal.
717	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
718	        // Proposal details must remain the same from `propose()`.
719	        _validateProposalHash(proposal, proposalState.hash);
720	        ProposalStateValues memory values = proposalState.values;
721	        ProposalStatus status = _getProposalStatus(values);
722	        // The proposal must be executable or have already been executed but still
723	        // has more steps to go.
724	        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {
725	            revert BadProposalStatusError(status);
726	        }
727	        if (status == ProposalStatus.Ready) {
728	            // If the proposal has not been executed yet, make sure it hasn't
729	            // expired. Note that proposals that have been executed
730	            // (but still have more steps) ignore `maxExecutableTime`.
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
738	        }
739	        // Check that the precious list is valid.
740	        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {
741	            revert BadPreciousListError();
742	        }
743	        // Preemptively set the proposal to completed to avoid it being executed
744	        // again in a deeper call.
745	        proposalState.values.completedTime = uint40(block.timestamp);
746	        // Execute the proposal.
747	        bool completed = _executeProposal(
748	            proposalId,
749	            proposal,
750	            preciousTokens,
751	            preciousTokenIds,
752	            _getProposalFlags(values),
753	            progressData,
754	            extraData
755	        );
756	        if (!completed) {
757	            // Proposal did not complete.
758	            proposalState.values.completedTime = 0;
759	        }
760	    }
761	
...
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
...
1147	    function _isPreciousListCorrect(
1148	        IERC721[] memory preciousTokens,
1149	        uint256[] memory preciousTokenIds
1150	    ) private view returns (bool) {
1151	        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);
1152	    }
1153	
...
1154	    function _hashPreciousList(
1155	        IERC721[] memory preciousTokens,
1156	        uint256[] memory preciousTokenIds
1157	    ) internal pure returns (bytes32 h) {
1158	        assembly {
1159	            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))
1160	            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))
1161	            h := keccak256(0x00, 0x40)
1162	        }
1163	    }
1164	
```
[270..309](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L270-L309)
[706..761](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L706-L761)
[860..902](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L860-L902)
[1147..1153](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1147-L1153)
[1154..1164](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1154-L1164)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
81	    function _initialize(
82	        string memory name_,
83	        string memory symbol_,
84	        uint256 customizationPresetId,
85	        PartyGovernance.GovernanceOpts memory governanceOpts,
86	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
87	        IERC721[] memory preciousTokens,
88	        uint256[] memory preciousTokenIds,
89	        address[] memory authorities,
90	        uint40 rageQuitTimestamp_
91	    ) internal {
92	        PartyGovernance._initialize(
93	            governanceOpts,
94	            proposalEngineOpts,
95	            preciousTokens,
96	            preciousTokenIds
97	        );
98	        name = name_;
99	        symbol = symbol_;
100	        rageQuitTimestamp = rageQuitTimestamp_;
101	        unchecked {
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
105	        }
106	        if (customizationPresetId != 0) {
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
109	        }
110	    }
...
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
```
[81..110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L81-L110)
[344..448](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L344-L448)


</details>

-------
### [L-06] Prevent division by 0
<a name="L-06"></a>
[To the top](#TOP)

On several locations in the code precautions are not being taken for not dividing by 0, this will revert the code. These functions can be called with 0 value in the input, this value is not checked for being bigger than 0, that means in some scenarios this can potentially trigger a division by zero.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 6 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
281	        amount = (votingPower * 1e4) / exchangeRateBps;
...
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
```
[281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L281)
[287](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L287)

---

	 - contracts/party/PartyGovernance.sol

```solidity
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
...
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
```
[1115](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1115)
[1134](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1134)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
```
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
```
[74](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L74)


</details>

-------
### [L-07] Missing contract-existence checks before low-level calls
<a name="L-07"></a>
[To the top](#TOP)

Low-level calls return success if there is no code present at the specified address. In addition to the zero-address checks, add a check to verify that `<address>.code.length > 0`

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 6 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
350	    function batchRefund(
351	        uint256[] calldata tokenIds,
352	        bool revertOnFailure
353	    ) external returns (uint96[] memory amounts) {
354	        uint256 numRefunds = tokenIds.length;
355	        amounts = new uint96[](numRefunds);
356	
357	        for (uint256 i; i < numRefunds; ++i) {
358	            (bool s, bytes memory r) = address(this).call(
359	                abi.encodeCall(this.refund, (tokenIds[i]))
360	            );
361	
362	            if (!s) {
363	                if (revertOnFailure) {
364	                    r.rawRevert();
365	                }
366	            } else {
367	                amounts[i] = abi.decode(r, (uint96));
368	            }
369	        }
370	    }
```
[350..370](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L350-L370)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
371	        // Must be called by the DAO.
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
384	    }
385	
```
[366..385](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L366-L385)

---

	 - contracts/party/PartyGovernance.sol

```solidity
771	    function cancel(uint256 proposalId, Proposal calldata proposal) external {
772	        _assertActiveMember();
773	        // Get information about the proposal.
774	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
775	        // Proposal details must remain the same from `propose()`.
776	        _validateProposalHash(proposal, proposalState.hash);
777	        ProposalStateValues memory values = proposalState.values;
778	        {
779	            // Must be `InProgress`.
780	            ProposalStatus status = _getProposalStatus(values);
781	            if (status != ProposalStatus.InProgress) {
782	                revert BadProposalStatusError(status);
783	            }
784	        }
785	        {
786	            // Limit the `cancelDelay` to the global max and min cancel delay
787	            // to mitigate parties accidentally getting stuck forever by setting an
788	            // unrealistic `cancelDelay` or being reckless with too low a
789	            // cancel delay.
790	            uint256 cancelDelay = proposal.cancelDelay;
791	            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(
792	                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION
793	            );
794	            uint256 globalMinCancelDelay = _GLOBALS.getUint256(
795	                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION
796	            );
797	            if (globalMaxCancelDelay != 0) {
798	                // Only if we have one set.
799	                if (cancelDelay > globalMaxCancelDelay) {
800	                    cancelDelay = globalMaxCancelDelay;
801	                }
802	            }
803	            if (globalMinCancelDelay != 0) {
804	                // Only if we have one set.
805	                if (cancelDelay < globalMinCancelDelay) {
806	                    cancelDelay = globalMinCancelDelay;
807	                }
808	            }
809	            uint256 cancelTime = values.executedTime + cancelDelay;
810	            // Must not be too early.
811	            if (block.timestamp < cancelTime) {
812	                revert ProposalCannotBeCancelledYetError(
813	                    uint40(block.timestamp),
814	                    uint40(cancelTime)
815	                );
816	            }
817	        }
818	        // Mark the proposal as cancelled by setting the completed time to the current
819	        // time with the high bit set.
820	        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);
821	        {
822	            // Delegatecall into the proposal engine impl to perform the cancel.
823	            (bool success, bytes memory resultData) = (
824	                address(_getSharedProposalStorage().engineImpl)
825	            ).delegatecall(abi.encodeCall(IProposalExecutionEngine.cancelProposal, (proposalId)));
826	            if (!success) {
827	                resultData.rawRevert();
828	            }
829	        }
830	        emit ProposalCancelled(proposalId);
831	        // Notify third-party platforms that the governance NFT metadata has
832	        // updated for all tokens.
833	        emit BatchMetadataUpdate(0, type(uint256).max);
834	    }
835	
...
841	    function emergencyExecute(
842	        address targetAddress,
843	        bytes calldata targetCallData,
844	        uint256 amountEth
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
846	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
847	        if (!success) {
848	            res.rawRevert();
849	        }
850	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
851	    }
852	
...
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
```
[771..835](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L771-L835)
[841..852](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L841-L852)
[860..902](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L860-L902)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
43	    function _initProposalImpl(IProposalExecutionEngine impl, bytes memory initData) internal {
44	        SharedProposalStorage storage stor = _getSharedProposalStorage();
45	        IProposalExecutionEngine oldImpl = stor.engineImpl;
46	        stor.engineImpl = impl;
47	        (bool s, bytes memory r) = address(impl).delegatecall(
48	            abi.encodeCall(IProposalExecutionEngine.initialize, (address(oldImpl), initData))
49	        );
50	        if (!s) {
51	            r.rawRevert();
52	        }
53	    }
```
[43..53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L43-L53)


</details>

-------
### [L-08] Missing checks for `address(0)` when assigning values to address state variables
<a name="L-08"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 4 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
108	    function initialize(
109	        InitialETHCrowdfundOptions memory crowdfundOpts,
110	        ETHPartyOptions memory partyOpts,
111	        MetadataProvider customMetadataProvider,
112	        bytes memory customMetadata
113	    ) external payable onlyInitialize {
114	        // Create party the initial crowdfund will be for.
115	        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);
116	
117	        // Initialize the crowdfund.
118	        _initialize(
119	            ETHCrowdfundOptions({
120	                party: party_,
121	                initialContributor: crowdfundOpts.initialContributor,
122	                initialDelegate: crowdfundOpts.initialDelegate,
123	                minContribution: crowdfundOpts.minContribution,
124	                maxContribution: crowdfundOpts.maxContribution,
125	                disableContributingForExistingCard: crowdfundOpts
126	                    .disableContributingForExistingCard,
127	                minTotalContributions: crowdfundOpts.minTotalContributions,
128	                maxTotalContributions: crowdfundOpts.maxTotalContributions,
129	                exchangeRateBps: crowdfundOpts.exchangeRateBps,
130	                fundingSplitBps: crowdfundOpts.fundingSplitBps,
131	                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,
132	                duration: crowdfundOpts.duration,
133	                gateKeeper: crowdfundOpts.gateKeeper,
134	                gateKeeperId: crowdfundOpts.gateKeeperId
135	            })
136	        );
137	
138	        // If the deployer passed in some ETH during deployment, credit them
139	        // for the initial contribution.
140	        uint96 initialContribution = msg.value.safeCastUint256ToUint96();
141	        if (initialContribution > 0) {
142	            // If this contract has ETH, either passed in during deployment or
143	            // pre-existing, credit it to the `initialContributor`.
144	            _contribute(
145	                crowdfundOpts.initialContributor,
146	                crowdfundOpts.initialDelegate,
147	                initialContribution,
148	                0,
149	                ""
150	            );
151	        }
152	
153	        // Set up gatekeeper after initial contribution (initial always gets in).
154	        gateKeeper = crowdfundOpts.gateKeeper;
155	        gateKeeperId = crowdfundOpts.gateKeeperId;
156	    }
```
[108..156](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L108-L156)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
140	    function _initialize(ETHCrowdfundOptions memory opts) internal {
141	        // Set the minimum and maximum contribution amounts.
142	        if (opts.minContribution > opts.maxContribution) {
143	            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);
144	        }
145	        minContribution = opts.minContribution;
146	        maxContribution = opts.maxContribution;
147	        // Set the min total contributions.
148	        if (opts.minTotalContributions > opts.maxTotalContributions) {
149	            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);
150	        }
151	        minTotalContributions = opts.minTotalContributions;
152	        // Set the max total contributions.
153	        if (opts.maxTotalContributions == 0) {
154	            // Prevent this because when `maxTotalContributions` is 0 the
155	            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has
156	            // never been initialized.
157	            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);
158	        }
159	        maxTotalContributions = opts.maxTotalContributions;
160	        // Set the party crowdfund is for.
161	        party = opts.party;
162	        // Set the crowdfund start and end timestamps.
163	        expiry = uint40(block.timestamp + opts.duration);
164	        // Set the exchange rate.
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
166	        exchangeRateBps = opts.exchangeRateBps;
167	        // Set the funding split and its recipient.
168	        fundingSplitBps = opts.fundingSplitBps;
169	        fundingSplitRecipient = opts.fundingSplitRecipient;
170	        // Set whether to disable contributing for existing card.
171	        disableContributingForExistingCard = opts.disableContributingForExistingCard;
172	    }
173	
...
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
```
[140..173](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L140-L173)
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)

---

	 - contracts/party/PartyGovernance.sol

```solidity
270	    function _initialize(
271	        GovernanceOpts memory govOpts,
272	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
273	        IERC721[] memory preciousTokens,
274	        uint256[] memory preciousTokenIds
275	    ) internal virtual {
276	        // Check BPS are valid.
277	        if (govOpts.feeBps > 1e4) {
278	            revert InvalidBpsError(govOpts.feeBps);
279	        }
280	        if (govOpts.passThresholdBps > 1e4) {
281	            revert InvalidBpsError(govOpts.passThresholdBps);
282	        }
283	        // Initialize the proposal execution engine.
284	        _initProposalImpl(
285	            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),
286	            abi.encode(proposalEngineOpts)
287	        );
288	        // Set the governance parameters.
289	        _getSharedProposalStorage().governanceValues = GovernanceValues({
290	            voteDuration: govOpts.voteDuration,
291	            executionDelay: govOpts.executionDelay,
292	            passThresholdBps: govOpts.passThresholdBps,
293	            totalVotingPower: govOpts.totalVotingPower
294	        });
295	        numHosts = uint8(govOpts.hosts.length);
296	        // Set fees.
297	        feeBps = govOpts.feeBps;
298	        feeRecipient = govOpts.feeRecipient;
299	        // Set the precious list.
300	        _setPreciousList(preciousTokens, preciousTokenIds);
301	        // Set the party hosts.
302	        if (govOpts.hosts.length > type(uint8).max) {
303	            revert TooManyHosts();
304	        }
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
309	
```
[270..309](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L270-L309)


</details>

-------
### [L-09] Privileged functions can create points of failure
<a name="L-09"></a>
[To the top](#TOP)

Ensure such accounts are protected and consider implementing multi sig to prevent a single point of failure

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 4 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
```
[366..370](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L366-L370)

---

	 - contracts/party/PartyGovernance.sol

```solidity
487	    function distribute(
488	        uint256 amount,
489	        ITokenDistributor.TokenType tokenType,
490	        address token,
491	        uint256 tokenId
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
...
841	    function emergencyExecute(
842	        address targetAddress,
843	        bytes calldata targetCallData,
844	        uint256 amountEth
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
```
[487..492](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L487-L492)
[841..845](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L841-L845)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
479	    function addAuthority(address authority) external onlySelf {
```
[479](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L479)


</details>

-------
### [L-10] Consider bounding input array length
<a name="L-10"></a>
[To the top](#TOP)

The functions below take in an unbounded array, and make function calls for entries in the array. While the function will revert if it eventually runs out of gas, it may be a nicer user experience to `require()` that the length of the array is below some reasonable maximum, so that the user doesn't have to use up a full transaction's gas only to see that the transaction reverts.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 3 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
350	    function batchRefund(
351	        uint256[] calldata tokenIds,
352	        bool revertOnFailure
353	    ) external returns (uint96[] memory amounts) {
354	        uint256 numRefunds = tokenIds.length;
355	        amounts = new uint96[](numRefunds);
356	
357	        for (uint256 i; i < numRefunds; ++i) {
358	            (bool s, bytes memory r) = address(this).call(
359	                abi.encodeCall(this.refund, (tokenIds[i]))
360	            );
361	
362	            if (!s) {
363	                if (revertOnFailure) {
364	                    r.rawRevert();
365	                }
366	            } else {
367	                amounts[i] = abi.decode(r, (uint96));
368	            }
369	        }
370	    }
```
[350..370](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L350-L370)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
268	    function _burnAndUpdateVotingPower(
269	        uint256[] memory tokenIds,
270	        bool checkIfAuthorizedToBurn
271	    ) private returns (uint96 totalVotingPowerBurned) {
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
302	
303	        // Update minted voting power.
304	        mintedVotingPower -= totalVotingPowerBurned;
305	    }
...
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
```
[268..305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L268-L305)
[344..448](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L344-L448)


</details>

-------
### [L-11] Emitting storage values instead of the memory one.
<a name="L-11"></a>
[To the top](#TOP)

Emitted values should not be read from storage again. Instead, the existing values from memory should be used.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
331	        emit ProposalEngineImplementationUpgraded(address(implementation), expectedImpl);
```
[331](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L331)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
86	        emit SigningThresholdBpsSet(party, signingThersholdBps[party], thresholdBps);
```
[86](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L86)


</details>

-------
### [L-12] `tokenURI` should throw an error if `_tokenId` is not a valid `NFT`
<a name="L-12"></a>
[To the top](#TOP)

According to [EIP-721](https://eips.ethereum.org/EIPS/eip-721) and specifically, the metadata extension, the tokenURI function should throw an error if `_tokenId` is not a valid NFT. Contrary, the current implementation returns an empty string.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
```
[123..126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L123-L126)


</details>

-------
### [L-13] NFT doesn't handle hardforks
<a name="L-13"></a>
[To the top](#TOP)

Consider adding require(1 == block.chainId), or the chain ID of whichever chain you prefer, to the functions below, or at least include the chain ID in the URI, so that there is no confusion about which chain is the owner of the NFT.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
```
[123..126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L123-L126)


</details>

-------
### [L-14] Functions calling contracts/addresses with transfer hooks are missing reentrancy guards
<a name="L-14"></a>
[To the top](#TOP)

Even if the function follows the best practice of check-effects-interaction, not using a reentrancy guard when there may be transfer hooks will open the users of this protocol up to [read-only reentrancies](https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/) with no way to protect against it, except by block-listing the whole protocol.`

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
204	    function batchContribute(
205	        BatchContributeArgs calldata args
206	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
207	        uint256 numContributions = args.tokenIds.length;
208	        votingPowers = new uint96[](numContributions);
209	
210	        uint256 ethAvailable = msg.value;
211	        for (uint256 i; i < numContributions; ++i) {
212	            ethAvailable -= args.values[i];
213	
214	            votingPowers[i] = _contribute(
215	                payable(msg.sender),
216	                args.delegate,
217	                args.values[i],
218	                args.tokenIds[i],
219	                args.gateDatas[i]
220	            );
221	        }
222	
223	        // Refund any unused ETH.
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
225	    }
```
[204..225](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L204-L225)


</details>

-------
### [L-15] Use `.call()` instead of `.send()` or `.transfer()`
<a name="L-15"></a>
[To the top](#TOP)

The `.send()` function intends to transfer an ETH amount with a fixed amount of 2300 gas. This function is not equipped to handle changes in the underlying `.send()` and `.transfer()` functions which may supply different amounts of gas in the future. Additionally, if the recipient implements a fallback function containing some sort of logic, this may inevitably revert, meaning the vault and owner of the contract will never be able to call certain sensitive functions.

Consider using `.call()` instead with the checks-effects-interactions pattern implemented correctly. Careful consideration needs to be made to prevent reentrancy.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
204	    function batchContribute(
205	        BatchContributeArgs calldata args
206	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
207	        uint256 numContributions = args.tokenIds.length;
208	        votingPowers = new uint96[](numContributions);
209	
210	        uint256 ethAvailable = msg.value;
211	        for (uint256 i; i < numContributions; ++i) {
212	            ethAvailable -= args.values[i];
213	
214	            votingPowers[i] = _contribute(
215	                payable(msg.sender),
216	                args.delegate,
217	                args.values[i],
218	                args.tokenIds[i],
219	                args.gateDatas[i]
220	            );
221	        }
222	
223	        // Refund any unused ETH.
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
225	    }
```
[204..225](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L204-L225)


</details>


## NonCritical Risk Issues

### [N-01] `Constants` in comparisons should appear on the left side
<a name="N-01"></a>
[To the top](#TOP)

Doing so will prevent [typo bugs](https://www.moserware.com/2008/01/constants-on-left-are-better-but-this.html)

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 107 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
141	        if (initialContribution > 0) {
...
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
...
283	        if (delegate == address(0)) {
...
298	        if (amount == 0) return 0;
...
300	        if (tokenId == 0) {
...
331	        if (amount > 0) {
...
377	        uint256 authoritiesLength = opts.authorities.length + 1;
...
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
...
382	        authorities[authoritiesLength - 1] = address(this);
...
384	        if (address(customMetadataProvider) == address(0)) {
```
[141](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L141)
[224](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L224)
[283](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L283)
[298](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L298)
[300](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L300)
[331](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L331)
[377](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L377)
[379](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L379)
[382](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L382)
[384](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L384)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
153	        if (opts.maxTotalContributions == 0) {
...
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
...
176	        if (maxTotalContributions == 0) {
...
181	        if (expiry_ == 0) {
...
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
...
213	        if (amount == 0) return 0;
...
239	            if (refundAmount > 0) {
...
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
...
270	        votingPower = (amount * exchangeRateBps) / 1e4;
...
272	        if (votingPower == 0) revert ZeroVotingPowerError();
...
281	        amount = (votingPower * 1e4) / exchangeRateBps;
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
...
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
...
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
...
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
...
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
```
[153](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L153)
[165](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L165)
[176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L176)
[181](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L181)
[202](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L202)
[213](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L213)
[239](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L239)
[263](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263)
[263](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263)
[266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L266)
[270](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L270)
[272](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L272)
[281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L281)
[286](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286)
[286](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286)
[287](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L287)
[324](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324)
[324](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324)
[325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L325)
[329](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L329)
[348](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L348)
[348](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L348)
[355](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L355)

---

	 - contracts/party/PartyGovernance.sol

```solidity
186	    uint256 private constant UINT40_HIGH_BIT = 1 << 39;
...
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
277	        if (govOpts.feeBps > 1e4) {
...
280	        if (govOpts.passThresholdBps > 1e4) {
...
338	            interfaceId == 0x49064906;
...
434	            uint256 mid = (low + high) / 2;
...
440	                low = mid + 1;
...
445	        return high == 0 ? type(uint256).max : high - 1;
...
445	        return high == 0 ? type(uint256).max : high - 1;
...
460	        if (newPartyHost != address(0)) {
...
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
...
634	        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);
...
644	            values.passedTime == 0 &&
...
797	            if (globalMaxCancelDelay != 0) {
...
803	            if (globalMinCancelDelay != 0) {
...
900	        return nextProgressData.length == 0;
...
911	        if (snapsLength != 0) {
...
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
...
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
...
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
...
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
...
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
...
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
...
1033	        if (n != 0) {
...
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
...
1036	                voterSnaps[n - 1] = snap;
...
1048	        if (n != 0) {
...
1049	            snap = voterSnaps[n - 1];
...
1068	        if (pv.proposedTime == 0) {
...
1072	        if (pv.executedTime != 0) {
...
1073	            if (pv.completedTime == 0) {
...
1088	        if (pv.passedTime != 0) {
...
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
...
1119	        return acceptanceRatio >= 0.9999e4;
...
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
...
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
```
[186](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L186)
[225](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L225)
[225](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L225)
[277](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L277)
[280](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L280)
[338](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L338)
[434](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L434)
[440](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L440)
[445](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L445)
[445](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L445)
[460](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L460)
[505](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L505)
[505](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L505)
[510](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L510)
[634](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L634)
[644](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L644)
[797](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L797)
[803](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L803)
[900](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L900)
[911](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L911)
[918](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L918)
[918](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L918)
[949](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L949)
[951](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L951)
[979](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L979)
[979](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L979)
[1033](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1033)
[1034](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1034)
[1036](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1036)
[1048](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1048)
[1049](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1049)
[1068](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1068)
[1072](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1072)
[1073](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1073)
[1088](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1088)
[1115](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1115)
[1119](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1119)
[1126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1126)
[1134](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1134)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
106	        if (customizationPresetId != 0) {
...
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
...
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
...
179	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {
...
196	        if (delegate_ != address(0)) {
...
216	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {
...
350	        if (tokenIds.length == 0) revert NothingToBurnError();
...
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
...
413	                uint256 fee = (amount * feeBps_) / 1e4;
...
415	                if (fee > 0) {
...
426	                if (amount > 0) {
```
[106](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L106)
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)
[179](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L179)
[196](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L196)
[216](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L216)
[350](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L350)
[393](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L393)
[413](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L413)
[415](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L415)
[426](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L426)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
128	        if (oldImpl != address(0)) return;
...
131	        if (initializeData.length == 0) return;
...
150	        if (params.proposalId == 0) {
...
155	        if (currentInProgressProposalId == 0) {
...
165	            if (nextProgressDataHash == 0) {
...
168	                assert(currentInProgressProposalId == 0);
...
169	                if (params.progressData.length != 0) {
...
197	        if (nextProgressData.length == 0) {
...
209	        if (proposalId == 0) {
...
227	        if (address(validator) == address(1)) {
...
231	        if (address(validator) != address(0)) {
...
234	        if (tx.origin == address(0)) {
...
236	            if (address(validator) == address(0)) {
...
303	        if (proposalData.length < 4) {
```
[128](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L128)
[131](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L131)
[150](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L150)
[155](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L155)
[165](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L165)
[168](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L168)
[169](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L169)
[197](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L197)
[209](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L209)
[227](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L227)
[231](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L231)
[234](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L234)
[236](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L236)
[303](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L303)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
32	        if (proposalData.voteDuration != 0) {
...
33	            if (proposalData.voteDuration < 1 hours) {
...
42	        if (proposalData.executionDelay != 0) {
...
43	            if (proposalData.executionDelay > 30 days) {
...
53	        if (proposalData.passThresholdBps != 0) {
...
54	            if (proposalData.passThresholdBps > 10000) {
```
[32](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L32)
[33](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L33)
[42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L42)
[43](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L43)
[53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L53)
[54](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L54)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
60	            10000;
...
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
...
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
...
72	            thresholdBps == 0 ||
```
[59..60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L59-L60)
[62](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L62)
[62](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L62)
[72](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L72)


</details>

-------
### [N-02] Unused contract variables
<a name="N-02"></a>
[To the top](#TOP)

Note that there may be cases where a variable appears to be used, but this is only because there are multiple definitions of the varible in different files. In such cases, the variable definition should be moved into a separate file. The instances below are the unused variables.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 83 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
...
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
...
240	    ) external payable onlyDelegateCall returns (uint96 votingPower) {
```
[167](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L167)
[189](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L189)
[240](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L240)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
35	        address payable initialContributor;
...
36	        address initialDelegate;
...
46	        IGateKeeper gateKeeper;
...
47	        bytes12 gateKeeperId;
...
50	    error WrongLifecycleError(CrowdfundLifecycle lc);
...
52	        address contributor,
...
53	        IGateKeeper gateKeeper,
...
54	        bytes12 gateKeeperId,
...
55	        bytes gateData
...
58	    error OnlyPartyDaoError(address notDao);
...
59	    error OnlyPartyDaoOrHostError(address notDao);
...
60	    error NotOwnerError(uint256 tokenId);
...
63	    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);
...
63	    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);
...
64	    error MinGreaterThanMaxError(uint96 min, uint96 max);
...
64	    error MinGreaterThanMaxError(uint96 min, uint96 max);
...
65	    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);
...
66	    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);
...
66	    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);
...
67	    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);
...
67	    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);
...
68	    error InvalidExchangeRateError(uint16 exchangeRateBps);
...
127	    IGateKeeper public gateKeeper;
...
129	    bytes12 public gateKeeperId;
...
175	    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {
```
[35](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L35)
[36](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L36)
[46](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L46)
[47](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L47)
[50](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L50)
[52](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L52)
[53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L53)
[54](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L54)
[55](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L55)
[58](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L58)
[59](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L59)
[60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L60)
[63](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L63)
[63](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L63)
[64](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L64)
[64](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L64)
[65](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L65)
[66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L66)
[66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L66)
[67](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L67)
[67](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L67)
[68](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L68)
[127](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L127)
[129](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L129)
[175](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L175)

---

	 - contracts/party/PartyGovernance.sol

```solidity
169	    error BadProposalStatusError(ProposalStatus status);
...
170	    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);
...
170	    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);
...
171	    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);
...
171	    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);
...
177	    error AlreadyVotedError(address voter);
...
179	    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);
...
179	    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);
...
180	    error InvalidBpsError(uint16 bps);
...
358	    ) external view returns (uint96 votingPower) {
...
372	    ) public view returns (uint96 votingPower) {
...
406	        bytes32 dataHash = keccak256(proposal.proposalData);
...
399	    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {
...
426	    ) public view returns (uint256 index) {
...
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
...
595	    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {
...
868	    ) private returns (bool completed) {
...
1066	    ) private view returns (ProposalStatus status) {
...
1155	        IERC721[] memory preciousTokens,
...
1156	        uint256[] memory preciousTokenIds
1157	    ) internal pure returns (bytes32 h) {
...
1157	    ) internal pure returns (bytes32 h) {
```
[169](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L169)
[170](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L170)
[170](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L170)
[171](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L171)
[171](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L171)
[177](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L177)
[179](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L179)
[179](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L179)
[180](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L180)
[358](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L358)
[372](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L372)
[406](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L406)
[399](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L399)
[426](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L426)
[492](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L492)
[595](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L595)
[868](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L868)
[1066](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1066)
[1155](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1155)
[1156..1157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1156-L1157)
[1157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1157)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
20	    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);
...
21	    error CannotRageQuitError(uint40 rageQuitTimestamp);
...
24	    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);
...
24	    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);
```
[20](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L20)
[21](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L21)
[24](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L24)
[24](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L24)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
42	    error UnsupportedProposalTypeError(uint32 proposalType);
...
85	    error ProposalDisabled(ProposalType proposalType);
...
88	    error ProposalExecutionBlockedError(uint256 proposalId, uint256 currentInProgressProposalId);
...
88	    error ProposalExecutionBlockedError(uint256 proposalId, uint256 currentInProgressProposalId);
...
90	        bytes32 actualProgressDataHash,
...
91	        bytes32 expectedProgressDataHash
...
93	    error ProposalNotInProgressError(uint256 proposalId);
...
95	        IProposalExecutionEngine actualImpl,
...
96	        IProposalExecutionEngine expectedImpl
...
141	    function getCurrentInProgressProposalId() external view returns (uint256 id) {
...
299	    ) private pure returns (ProposalType proposalType, bytes memory offsetProposalData) {
...
336	        uint256 slot = _STORAGE_SLOT;
...
335	    function _getStorage() internal pure returns (Storage storage stor) {
```
[42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L42)
[85](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L85)
[88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L88)
[88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L88)
[90](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L90)
[91](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L91)
[93](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L93)
[95](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L95)
[96](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L96)
[141](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L141)
[299](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L299)
[336](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L336)
[335](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L335)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
15	        ProposalEngineOpts opts;
...
16	        GovernanceValues governanceValues;
...
21	        uint40 voteDuration;
...
22	        uint40 executionDelay;
...
23	        uint16 passThresholdBps;
...
24	        uint96 totalVotingPower;
...
29	        bool enableAddAuthorityProposal;
...
32	        bool allowArbCallsToSpendPartyEth;
...
34	        bool allowOperators;
...
36	        bool distributionsRequireVote;
...
39	    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;
...
60	        uint256 s = SHARED_STORAGE_SLOT;
...
58	        returns (SharedProposalStorage storage stor)
```
[15](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L15)
[16](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L16)
[21](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L21)
[22](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L22)
[23](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L23)
[24](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L24)
[29](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L29)
[32](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L32)
[34](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L34)
[36](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L36)
[39](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L39)
[60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L60)
[58](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L58)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
9	    error InvalidGovernanceParameter(uint256 value);
```
[9](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L9)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
52	        uint256 slot = _SET_SIGNATURE_VALIDATOR_PROPOSAL_STORAGE_SLOT;
...
50	        returns (SetSignatureValidatorProposalStorage storage stor)
```
[52](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L52)
[50](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L50)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
28	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
```
[28](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L28)


</details>

-------
### [N-03] Contract functions should use an `interface`
<a name="N-03"></a>
[To the top](#TOP)

All `external`/`public` functions should extend an `interface`. This is useful to make sure that the whole API is extracted.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 51 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
108	    function initialize(
109	        InitialETHCrowdfundOptions memory crowdfundOpts,
110	        ETHPartyOptions memory partyOpts,
111	        MetadataProvider customMetadataProvider,
112	        bytes memory customMetadata
113	    ) external payable onlyInitialize {
114	        // Create party the initial crowdfund will be for.
115	        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);
116	
117	        // Initialize the crowdfund.
118	        _initialize(
119	            ETHCrowdfundOptions({
120	                party: party_,
121	                initialContributor: crowdfundOpts.initialContributor,
122	                initialDelegate: crowdfundOpts.initialDelegate,
123	                minContribution: crowdfundOpts.minContribution,
124	                maxContribution: crowdfundOpts.maxContribution,
125	                disableContributingForExistingCard: crowdfundOpts
126	                    .disableContributingForExistingCard,
127	                minTotalContributions: crowdfundOpts.minTotalContributions,
128	                maxTotalContributions: crowdfundOpts.maxTotalContributions,
129	                exchangeRateBps: crowdfundOpts.exchangeRateBps,
130	                fundingSplitBps: crowdfundOpts.fundingSplitBps,
131	                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,
132	                duration: crowdfundOpts.duration,
133	                gateKeeper: crowdfundOpts.gateKeeper,
134	                gateKeeperId: crowdfundOpts.gateKeeperId
135	            })
136	        );
137	
138	        // If the deployer passed in some ETH during deployment, credit them
139	        // for the initial contribution.
140	        uint96 initialContribution = msg.value.safeCastUint256ToUint96();
141	        if (initialContribution > 0) {
142	            // If this contract has ETH, either passed in during deployment or
143	            // pre-existing, credit it to the `initialContributor`.
144	            _contribute(
145	                crowdfundOpts.initialContributor,
146	                crowdfundOpts.initialDelegate,
147	                initialContribution,
148	                0,
149	                ""
150	            );
151	        }
152	
153	        // Set up gatekeeper after initial contribution (initial always gets in).
154	        gateKeeper = crowdfundOpts.gateKeeper;
155	        gateKeeperId = crowdfundOpts.gateKeeperId;
156	    }
...
164	    function contribute(
165	        address delegate,
166	        bytes memory gateData
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
168	        return
169	            _contribute(
170	                payable(msg.sender),
171	                delegate,
172	                msg.value.safeCastUint256ToUint96(),
173	                0, // Mint a new party card for the contributor.
174	                gateData
175	            );
176	    }
...
185	    function contribute(
186	        uint256 tokenId,
187	        address delegate,
188	        bytes memory gateData
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
190	        return
191	            _contribute(
192	                payable(msg.sender),
193	                delegate,
194	                msg.value.safeCastUint256ToUint96(),
195	                tokenId,
196	                gateData
197	            );
198	    }
...
204	    function batchContribute(
205	        BatchContributeArgs calldata args
206	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
207	        uint256 numContributions = args.tokenIds.length;
208	        votingPowers = new uint96[](numContributions);
209	
210	        uint256 ethAvailable = msg.value;
211	        for (uint256 i; i < numContributions; ++i) {
212	            ethAvailable -= args.values[i];
213	
214	            votingPowers[i] = _contribute(
215	                payable(msg.sender),
216	                args.delegate,
217	                args.values[i],
218	                args.tokenIds[i],
219	                args.gateDatas[i]
220	            );
221	        }
222	
223	        // Refund any unused ETH.
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
225	    }
...
235	    function contributeFor(
236	        uint256 tokenId,
237	        address payable recipient,
238	        address initialDelegate,
239	        bytes memory gateData
240	    ) external payable onlyDelegateCall returns (uint96 votingPower) {
241	        return
242	            _contribute(
243	                recipient,
244	                initialDelegate,
245	                msg.value.safeCastUint256ToUint96(),
246	                tokenId,
247	                gateData
248	            );
249	    }
...
255	    function batchContributeFor(
256	        BatchContributeForArgs calldata args
257	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
258	        votingPowers = new uint96[](args.recipients.length);
259	        uint256 valuesSum;
260	        for (uint256 i; i < args.recipients.length; ++i) {
261	            votingPowers[i] = _contribute(
262	                args.recipients[i],
263	                args.initialDelegates[i],
264	                args.values[i],
265	                args.tokenIds[i],
266	                args.gateDatas[i]
267	            );
268	            valuesSum += args.values[i];
269	        }
270	        if (msg.value != valuesSum) {
271	            revert InvalidMessageValue();
272	        }
273	    }
...
318	    function refund(uint256 tokenId) external returns (uint96 amount) {
319	        // Check crowdfund lifecycle.
320	        {
321	            CrowdfundLifecycle lc = getCrowdfundLifecycle();
322	            if (lc != CrowdfundLifecycle.Lost) {
323	                revert WrongLifecycleError(lc);
324	            }
325	        }
326	
327	        // Get amount to refund.
328	        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();
329	        amount = convertVotingPowerToContribution(votingPower);
330	
331	        if (amount > 0) {
332	            // Get contributor to refund.
333	            address payable contributor = payable(party.ownerOf(tokenId));
334	
335	            // Burn contributor's party card.
336	            party.burn(tokenId);
337	
338	            // Refund contributor.
339	            contributor.transferEth(amount);
340	
341	            emit Refunded(contributor, tokenId, amount);
342	        }
343	    }
...
350	    function batchRefund(
351	        uint256[] calldata tokenIds,
352	        bool revertOnFailure
353	    ) external returns (uint96[] memory amounts) {
354	        uint256 numRefunds = tokenIds.length;
355	        amounts = new uint96[](numRefunds);
356	
357	        for (uint256 i; i < numRefunds; ++i) {
358	            (bool s, bytes memory r) = address(this).call(
359	                abi.encodeCall(this.refund, (tokenIds[i]))
360	            );
361	
362	            if (!s) {
363	                if (revertOnFailure) {
364	                    r.rawRevert();
365	                }
366	            } else {
367	                amounts[i] = abi.decode(r, (uint96));
368	            }
369	        }
370	    }
```
[108..156](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L108-L156)
[164..176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L164-L176)
[185..198](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L185-L198)
[204..225](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L204-L225)
[235..249](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L249)
[255..273](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L255-L273)
[318..343](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L318-L343)
[350..370](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L350-L370)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
175	    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {
176	        if (maxTotalContributions == 0) {
177	            return CrowdfundLifecycle.Invalid;
178	        }
179	
180	        uint256 expiry_ = expiry;
181	        if (expiry_ == 0) {
182	            return CrowdfundLifecycle.Finalized;
183	        }
184	
185	        if (block.timestamp >= expiry_) {
186	            if (totalContributions >= minTotalContributions) {
187	                return CrowdfundLifecycle.Won;
188	            } else {
189	                return CrowdfundLifecycle.Lost;
190	            }
191	        }
192	
193	        return CrowdfundLifecycle.Active;
194	    }
195	
...
278	    function convertVotingPowerToContribution(
279	        uint96 votingPower
280	    ) public view returns (uint96 amount) {
281	        amount = (votingPower * 1e4) / exchangeRateBps;
282	
283	        // Add back funding split to contribution amount if applicable.
284	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
285	        uint16 fundingSplitBps_ = fundingSplitBps;
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
288	        }
289	    }
290	
...
291	    function finalize() external {
292	        uint96 totalContributions_ = totalContributions;
293	
294	        // Check that the crowdfund is not already finalized.
295	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
296	        if (lc == CrowdfundLifecycle.Active) {
297	            // Allow host to finalize crowdfund early if it has reached its minimum goal.
298	            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();
299	
300	            // Check that the crowdfund has reached its minimum goal.
301	            uint96 minTotalContributions_ = minTotalContributions;
302	            if (totalContributions_ < minTotalContributions_) {
303	                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);
304	            }
305	        } else {
306	            // Otherwise only allow finalization if the crowdfund has expired
307	            // and been won. Can be finalized by anyone.
308	            if (lc != CrowdfundLifecycle.Won) {
309	                revert WrongLifecycleError(lc);
310	            }
311	        }
312	
313	        // Finalize the crowdfund.
314	        _finalize(totalContributions_);
315	    }
316	
...
339	    function sendFundingSplit() external returns (uint96 splitAmount) {
340	        // Check that the crowdfund is finalized.
341	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
342	        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);
343	
344	        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();
345	
346	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
347	        uint16 fundingSplitBps_ = fundingSplitBps;
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
349	            revert FundingSplitNotConfiguredError();
350	        }
351	
352	        fundingSplitPaid = true;
353	
354	        // Transfer funding split to recipient.
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
356	        payable(fundingSplitRecipient_).transferEth(splitAmount);
357	
358	        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);
359	    }
360	
...
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
371	        // Must be called by the DAO.
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
384	    }
385	
...
388	    function disableEmergencyExecute() external {
389	        // Only the DAO or a host can call this.
390	        if (
391	            !party.isHost(msg.sender) &&
392	            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender
393	        ) {
394	            revert OnlyPartyDaoOrHostError(msg.sender);
395	        }
396	        emergencyExecuteDisabled = true;
397	        emit EmergencyExecuteDisabled();
398	    }
399	}
```
[175..195](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L175-L195)
[278..290](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L278-L290)
[291..316](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L291-L316)
[339..360](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L339-L360)
[366..385](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L366-L385)
[388..399](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L388-L399)

---

	 - contracts/party/PartyGovernance.sol

```solidity
333	    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {
334	        return
335	            interfaceId == type(IERC721Receiver).interfaceId ||
336	            interfaceId == type(ERC1155TokenReceiverBase).interfaceId ||
337	            // ERC4906 interface ID
338	            interfaceId == 0x49064906;
339	    }
340	
...
342	    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {
343	        return _getSharedProposalStorage().engineImpl;
344	    }
345	
...
347	    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {
348	        return _getSharedProposalStorage().opts;
349	    }
350	
...
355	    function getVotingPowerAt(
356	        address voter,
357	        uint40 timestamp
358	    ) external view returns (uint96 votingPower) {
359	        return getVotingPowerAt(voter, timestamp, type(uint256).max);
360	    }
361	
...
368	    function getVotingPowerAt(
369	        address voter,
370	        uint40 timestamp,
371	        uint256 snapIndex
372	    ) public view returns (uint96 votingPower) {
373	        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);
374	        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;
375	    }
376	
...
381	    function getProposalStateInfo(
382	        uint256 proposalId
383	    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {
384	        values = _proposalStateByProposalId[proposalId].values;
385	        status = _getProposalStatus(values);
386	    }
387	
...
390	    function getGovernanceValues() external view returns (GovernanceValues memory) {
391	        return _getSharedProposalStorage().governanceValues;
392	    }
393	
...
399	    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {
400	        // Hash the proposal in-place. Equivalent to:
401	        // keccak256(abi.encode(
402	        //   proposal.maxExecutableTime,
403	        //   proposal.cancelDelay,
404	        //   keccak256(proposal.proposalData)
405	        // ))
406	        bytes32 dataHash = keccak256(proposal.proposalData);
407	        assembly {
408	            // Overwrite the data field with the hash of its contents and then
409	            // hash the struct.
410	            let dataPos := add(proposal, 0x40)
411	            let t := mload(dataPos)
412	            mstore(dataPos, dataHash)
413	            proposalHash := keccak256(proposal, 0x60)
414	            // Restore the data field.
415	            mstore(dataPos, t)
416	        }
417	    }
418	
...
423	    function findVotingPowerSnapshotIndex(
424	        address voter,
425	        uint40 timestamp
426	    ) public view returns (uint256 index) {
427	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
428	
429	        // Derived from Open Zeppelin binary search
430	        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39
431	        uint256 high = snaps.length;
432	        uint256 low = 0;
433	        while (low < high) {
434	            uint256 mid = (low + high) / 2;
435	            if (snaps[mid].timestamp > timestamp) {
436	                // Entry is too recent.
437	                high = mid;
438	            } else {
439	                // Entry is older. This is our best guess for now.
440	                low = mid + 1;
441	            }
442	        }
443	
444	        // Return `type(uint256).max` if no valid voting snapshots found.
445	        return high == 0 ? type(uint256).max : high - 1;
446	    }
447	
...
451	    function delegateVotingPower(address delegate) external {
452	        _adjustVotingPower(msg.sender, 0, delegate);
453	    }
454	
...
457	    function abdicateHost(address newPartyHost) external {
458	        _assertHost();
459	        // 0 is a special case burn address.
460	        if (newPartyHost != address(0)) {
461	            // Cannot transfer host status to an existing host.
462	            if (isHost[newPartyHost]) {
463	                revert InvalidNewHostError();
464	            }
465	            isHost[newPartyHost] = true;
466	        } else {
467	            // Burned the host status
468	            --numHosts;
469	        }
470	        isHost[msg.sender] = false;
471	        emit HostStatusTransferred(msg.sender, newPartyHost);
472	    }
473	
...
487	    function distribute(
488	        uint256 amount,
489	        ITokenDistributor.TokenType tokenType,
490	        address token,
491	        uint256 tokenId
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
493	        _assertNotGloballyDisabled();
494	        // Ignore if the party is calling functions on itself, like with
495	        // `FractionalizeProposal` and `DistributionProposal`.
496	        if (msg.sender != address(this)) {
497	            // Must not require a vote to create a distribution, otherwise
498	            // distributions can only be created through a distribution
499	            // proposal.
500	            if (_getSharedProposalStorage().opts.distributionsRequireVote) {
501	                revert DistributionsRequireVoteError();
502	            }
503	            // Must be an active member.
504	            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
509	        // Prevent creating a distribution if the party has not started.
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
511	            revert PartyNotStartedError();
512	        }
513	        // Get the address of the token distributor.
514	        ITokenDistributor distributor = ITokenDistributor(
515	            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)
516	        );
517	        emit DistributionCreated(tokenType, token, tokenId);
518	        // Notify third-party platforms that the governance NFT metadata has
519	        // updated for all tokens.
520	        emit BatchMetadataUpdate(0, type(uint256).max);
521	        // Create a native token distribution.
522	        address payable feeRecipient_ = feeRecipient;
523	        uint16 feeBps_ = feeBps;
524	        if (tokenType == ITokenDistributor.TokenType.Native) {
525	            return
526	                distributor.createNativeDistribution{ value: amount }(
527	                    Party(payable(address(this))),
528	                    feeRecipient_,
529	                    feeBps_
530	                );
531	        }
532	        // Otherwise must be an ERC20 token distribution.
533	        assert(tokenType == ITokenDistributor.TokenType.Erc20);
534	        IERC20(token).compatTransfer(address(distributor), amount);
535	        return
536	            distributor.createErc20Distribution(
537	                IERC20(token),
538	                Party(payable(address(this))),
539	                feeRecipient_,
540	                feeBps_
541	            );
542	    }
543	
...
553	    function propose(
554	        Proposal memory proposal,
555	        uint256 latestSnapIndex
556	    ) external returns (uint256 proposalId) {
557	        _assertActiveMember();
558	        proposalId = ++lastProposalId;
559	        // Store the time the proposal was created and the proposal hash.
560	        (
561	            _proposalStateByProposalId[proposalId].values,
562	            _proposalStateByProposalId[proposalId].hash
563	        ) = (
564	            ProposalStateValues({
565	                proposedTime: uint40(block.timestamp),
566	                passedTime: 0,
567	                executedTime: 0,
568	                completedTime: 0,
569	                votes: 0,
570	                totalVotingPower: _getSharedProposalStorage().governanceValues.totalVotingPower,
571	                numHosts: numHosts,
572	                numHostsAccepted: 0
573	            }),
574	            getProposalHash(proposal)
575	        );
576	        emit Proposed(proposalId, msg.sender, proposal);
577	        accept(proposalId, latestSnapIndex);
578	
579	        // Notify third-party platforms that the governance NFT metadata has
580	        // updated for all tokens.
581	        emit BatchMetadataUpdate(0, type(uint256).max);
582	    }
583	
...
595	    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {
596	        // Get the information about the proposal.
597	        ProposalState storage info = _proposalStateByProposalId[proposalId];
598	        ProposalStateValues memory values = info.values;
599	
600	        // Can only vote in certain proposal statuses.
601	        {
602	            ProposalStatus status = _getProposalStatus(values);
603	            // Allow voting even if the proposal is passed/ready so it can
604	            // potentially reach 100% consensus, which unlocks special
605	            // behaviors for certain proposal types.
606	            if (
607	                status != ProposalStatus.Voting &&
608	                status != ProposalStatus.Passed &&
609	                status != ProposalStatus.Ready
610	            ) {
611	                revert BadProposalStatusError(status);
612	            }
613	        }
614	
615	        // Prevent voting in the same block as the last rage quit timestamp.
616	        // This is to prevent an exploit where a member can rage quit to reduce
617	        // the total voting power of the party, then propose and vote in the
618	        // same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.
619	        // This would allow them to use the voting power snapshot just before
620	        // their card was burned to vote, potentially passing a proposal that
621	        // would have otherwise not passed.
622	        if (lastRageQuitTimestamp == block.timestamp) {
623	            revert CannotRageQuitAndAcceptError();
624	        }
625	
626	        // Cannot vote twice.
627	        if (info.hasVoted[msg.sender]) {
628	            revert AlreadyVotedError(msg.sender);
629	        }
630	        // Mark the caller as having voted.
631	        info.hasVoted[msg.sender] = true;
632	
633	        // Increase the total votes that have been cast on this proposal.
634	        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);
635	        values.votes += votingPower;
636	        if (isHost[msg.sender]) {
637	            ++values.numHostsAccepted;
638	        }
639	        info.values = values;
640	        emit ProposalAccepted(proposalId, msg.sender, votingPower);
641	
642	        // Update the proposal status if it has reached the pass threshold.
643	        if (
644	            values.passedTime == 0 &&
645	            _areVotesPassing(
646	                values.votes,
647	                values.totalVotingPower,
648	                _getSharedProposalStorage().governanceValues.passThresholdBps
649	            )
650	        ) {
651	            info.values.passedTime = uint40(block.timestamp);
652	            emit ProposalPassed(proposalId);
653	            // Notify third-party platforms that the governance NFT metadata has
654	            // updated for all tokens.
655	            emit BatchMetadataUpdate(0, type(uint256).max);
656	        }
657	        return values.votes;
658	    }
659	
...
665	    function veto(uint256 proposalId) external {
666	        _assertHost();
667	        // Setting `votes` to -1 indicates a veto.
668	        ProposalState storage info = _proposalStateByProposalId[proposalId];
669	        ProposalStateValues memory values = info.values;
670	
671	        {
672	            ProposalStatus status = _getProposalStatus(values);
673	            // Proposal must be in one of the following states.
674	            if (
675	                status != ProposalStatus.Voting &&
676	                status != ProposalStatus.Passed &&
677	                status != ProposalStatus.Ready
678	            ) {
679	                revert BadProposalStatusError(status);
680	            }
681	        }
682	
683	        // -1 indicates veto.
684	        info.values.votes = VETO_VALUE;
685	        emit ProposalVetoed(proposalId, msg.sender);
686	        // Notify third-party platforms that the governance NFT metadata has
687	        // updated for all tokens.
688	        emit BatchMetadataUpdate(0, type(uint256).max);
689	    }
690	
...
706	    function execute(
707	        uint256 proposalId,
708	        Proposal memory proposal,
709	        IERC721[] memory preciousTokens,
710	        uint256[] memory preciousTokenIds,
711	        bytes calldata progressData,
712	        bytes calldata extraData
713	    ) external payable {
714	        _assertNotGloballyDisabled();
715	        _assertActiveMember();
716	        // Get information about the proposal.
717	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
718	        // Proposal details must remain the same from `propose()`.
719	        _validateProposalHash(proposal, proposalState.hash);
720	        ProposalStateValues memory values = proposalState.values;
721	        ProposalStatus status = _getProposalStatus(values);
722	        // The proposal must be executable or have already been executed but still
723	        // has more steps to go.
724	        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {
725	            revert BadProposalStatusError(status);
726	        }
727	        if (status == ProposalStatus.Ready) {
728	            // If the proposal has not been executed yet, make sure it hasn't
729	            // expired. Note that proposals that have been executed
730	            // (but still have more steps) ignore `maxExecutableTime`.
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
738	        }
739	        // Check that the precious list is valid.
740	        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {
741	            revert BadPreciousListError();
742	        }
743	        // Preemptively set the proposal to completed to avoid it being executed
744	        // again in a deeper call.
745	        proposalState.values.completedTime = uint40(block.timestamp);
746	        // Execute the proposal.
747	        bool completed = _executeProposal(
748	            proposalId,
749	            proposal,
750	            preciousTokens,
751	            preciousTokenIds,
752	            _getProposalFlags(values),
753	            progressData,
754	            extraData
755	        );
756	        if (!completed) {
757	            // Proposal did not complete.
758	            proposalState.values.completedTime = 0;
759	        }
760	    }
761	
...
771	    function cancel(uint256 proposalId, Proposal calldata proposal) external {
772	        _assertActiveMember();
773	        // Get information about the proposal.
774	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
775	        // Proposal details must remain the same from `propose()`.
776	        _validateProposalHash(proposal, proposalState.hash);
777	        ProposalStateValues memory values = proposalState.values;
778	        {
779	            // Must be `InProgress`.
780	            ProposalStatus status = _getProposalStatus(values);
781	            if (status != ProposalStatus.InProgress) {
782	                revert BadProposalStatusError(status);
783	            }
784	        }
785	        {
786	            // Limit the `cancelDelay` to the global max and min cancel delay
787	            // to mitigate parties accidentally getting stuck forever by setting an
788	            // unrealistic `cancelDelay` or being reckless with too low a
789	            // cancel delay.
790	            uint256 cancelDelay = proposal.cancelDelay;
791	            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(
792	                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION
793	            );
794	            uint256 globalMinCancelDelay = _GLOBALS.getUint256(
795	                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION
796	            );
797	            if (globalMaxCancelDelay != 0) {
798	                // Only if we have one set.
799	                if (cancelDelay > globalMaxCancelDelay) {
800	                    cancelDelay = globalMaxCancelDelay;
801	                }
802	            }
803	            if (globalMinCancelDelay != 0) {
804	                // Only if we have one set.
805	                if (cancelDelay < globalMinCancelDelay) {
806	                    cancelDelay = globalMinCancelDelay;
807	                }
808	            }
809	            uint256 cancelTime = values.executedTime + cancelDelay;
810	            // Must not be too early.
811	            if (block.timestamp < cancelTime) {
812	                revert ProposalCannotBeCancelledYetError(
813	                    uint40(block.timestamp),
814	                    uint40(cancelTime)
815	                );
816	            }
817	        }
818	        // Mark the proposal as cancelled by setting the completed time to the current
819	        // time with the high bit set.
820	        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);
821	        {
822	            // Delegatecall into the proposal engine impl to perform the cancel.
823	            (bool success, bytes memory resultData) = (
824	                address(_getSharedProposalStorage().engineImpl)
825	            ).delegatecall(abi.encodeCall(IProposalExecutionEngine.cancelProposal, (proposalId)));
826	            if (!success) {
827	                resultData.rawRevert();
828	            }
829	        }
830	        emit ProposalCancelled(proposalId);
831	        // Notify third-party platforms that the governance NFT metadata has
832	        // updated for all tokens.
833	        emit BatchMetadataUpdate(0, type(uint256).max);
834	    }
835	
...
841	    function emergencyExecute(
842	        address targetAddress,
843	        bytes calldata targetCallData,
844	        uint256 amountEth
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
846	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
847	        if (!success) {
848	            res.rawRevert();
849	        }
850	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
851	    }
852	
...
855	    function disableEmergencyExecute() external onlyPartyDaoOrHost {
856	        emergencyExecuteDisabled = true;
857	        emit EmergencyExecuteDisabled();
858	    }
859	
```
[333..340](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L333-L340)
[342..345](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L342-L345)
[347..350](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L347-L350)
[355..361](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L355-L361)
[368..376](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L368-L376)
[381..387](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L381-L387)
[390..393](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L390-L393)
[399..418](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L399-L418)
[423..447](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L423-L447)
[451..454](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L451-L454)
[457..473](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L457-L473)
[487..543](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L487-L543)
[553..583](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L553-L583)
[595..659](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L595-L659)
[665..690](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L665-L690)
[706..761](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L706-L761)
[771..835](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L771-L835)
[841..852](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L841-L852)
[855..859](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L855-L859)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
129	    function contractURI() external view returns (string memory) {
130	        _delegateToRenderer();
131	        return ""; // Just to make the compiler happy.
132	    }
...
146	    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {
147	        return votingPowerByTokenId[tokenId];
148	    }
...
154	    function getVotingPowerShareOf(uint256 tokenId) public view returns (uint256) {
155	        uint256 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
156	        return
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
158	    }
...
166	    function mint(
167	        address owner,
168	        uint256 votingPower,
169	        address delegate
170	    ) external returns (uint256 tokenId) {
171	        _assertAuthority();
172	        uint96 mintedVotingPower_ = mintedVotingPower;
173	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
174	
175	        // Cap voting power to remaining unminted voting power supply.
176	        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();
177	        // Allow minting past total voting power if minting party cards for
178	        // initial crowdfund when there is no total voting power.
179	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {
180	            unchecked {
181	                votingPower_ = totalVotingPower - mintedVotingPower_;
182	            }
183	        }
184	
185	        // Update state.
186	        unchecked {
187	            tokenId = ++tokenCount;
188	        }
189	        mintedVotingPower += votingPower_;
190	        votingPowerByTokenId[tokenId] = votingPower_;
191	
192	        emit PartyCardIntrinsicVotingPowerSet(tokenId, votingPower_);
193	
194	        // Use delegate from party over the one set during crowdfund.
195	        address delegate_ = delegationsByVoter[owner];
196	        if (delegate_ != address(0)) {
197	            delegate = delegate_;
198	        }
199	
200	        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);
201	        _safeMint(owner, tokenId);
202	    }
...
208	    function increaseVotingPower(uint256 tokenId, uint96 votingPower) external {
209	        _assertAuthority();
210	        uint96 mintedVotingPower_ = mintedVotingPower;
211	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
212	
213	        // Cap voting power to remaining unminted voting power supply. Allow
214	        // minting past total voting power if minting party cards for initial
215	        // crowdfund when there is no total voting power.
216	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {
217	            unchecked {
218	                votingPower = totalVotingPower - mintedVotingPower_;
219	            }
220	        }
221	
222	        // Update state.
223	        mintedVotingPower += votingPower;
224	        uint256 newIntrinsicVotingPower = votingPowerByTokenId[tokenId] + votingPower;
225	        votingPowerByTokenId[tokenId] = newIntrinsicVotingPower;
226	
227	        emit PartyCardIntrinsicVotingPowerSet(tokenId, newIntrinsicVotingPower);
228	
229	        _adjustVotingPower(ownerOf(tokenId), votingPower.safeCastUint96ToInt192(), address(0));
230	    }
...
236	    function decreaseVotingPower(uint256 tokenId, uint96 votingPower) external {
237	        _assertAuthority();
238	        mintedVotingPower -= votingPower;
239	        votingPowerByTokenId[tokenId] -= votingPower;
240	
241	        _adjustVotingPower(ownerOf(tokenId), -votingPower.safeCastUint96ToInt192(), address(0));
242	    }
...
247	    function increaseTotalVotingPower(uint96 votingPower) external {
248	        _assertAuthority();
249	        _getSharedProposalStorage().governanceValues.totalVotingPower += votingPower;
250	    }
...
255	    function decreaseTotalVotingPower(uint96 votingPower) external {
256	        _assertAuthority();
257	        _getSharedProposalStorage().governanceValues.totalVotingPower -= votingPower;
258	    }
...
263	    function burn(uint256[] memory tokenIds) public {
264	        _assertAuthority();
265	        _burnAndUpdateVotingPower(tokenIds, false);
266	    }
...
310	    function burn(uint256 tokenId) external {
311	        uint256[] memory tokenIds = new uint256[](1);
312	        tokenIds[0] = tokenId;
313	        burn(tokenIds);
314	    }
...
318	    function setRageQuit(uint40 newRageQuitTimestamp) external {
319	        _assertHost();
320	        // Prevent disabling ragequit after initialization.
321	        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {
322	            revert CannotDisableRageQuitAfterInitializationError();
323	        }
324	
325	        uint40 oldRageQuitTimestamp = rageQuitTimestamp;
326	
327	        // Prevent setting timestamp if it is permanently enabled/disabled.
328	        if (
329	            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||
330	            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY
331	        ) {
332	            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);
333	        }
334	
335	        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);
336	    }
...
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
...
479	    function addAuthority(address authority) external onlySelf {
480	        isAuthority[authority] = true;
481	
482	        emit AuthorityAdded(authority);
483	    }
...
486	    function abdicateAuthority() external {
487	        _assertAuthority();
488	        delete isAuthority[msg.sender];
489	
490	        emit AuthorityRemoved(msg.sender);
491	    }
```
[129..132](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L129-L132)
[146..148](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L146-L148)
[154..158](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L154-L158)
[166..202](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L166-L202)
[208..230](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L208-L230)
[236..242](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L236-L242)
[247..250](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L247-L250)
[255..258](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L255-L258)
[263..266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L263-L266)
[310..314](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L310-L314)
[318..336](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L318-L336)
[344..448](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L344-L448)
[479..483](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L479-L483)
[486..491](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L486-L491)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
141	    function getCurrentInProgressProposalId() external view returns (uint256 id) {
142	        return _getStorage().currentInProgressProposalId;
143	    }
144	
```
[141..144](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L141-L144)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
42	    function getSignatureValidatorForHash(bytes32 hash) public view returns (IERC1271) {
43	        return _getSetSignatureValidatorProposalStorage().signatureValidators[hash];
44	    }
```
[42..44](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L42-L44)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
84	    function setSigningThresholdBps(uint96 thresholdBps) external {
85	        Party party = Party(payable(msg.sender));
86	        emit SigningThresholdBpsSet(party, signingThersholdBps[party], thresholdBps);
87	        signingThersholdBps[party] = thresholdBps;
88	    }
```
[84..88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L84-L88)

---

	 - contracts/utils/Implementation.sol

```solidity
40	    function IMPL() external view returns (address) {
41	        return implementation;
42	    }
```
[40..42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L40-L42)


</details>

-------
### [N-04] NatSpec` @param` is missing
<a name="N-04"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 48 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
99	    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}
...
275	    function _contribute(
276	        address payable contributor,
277	        address delegate,
278	        uint96 amount,
279	        uint256 tokenId,
280	        bytes memory gateData
281	    ) private returns (uint96 votingPower) {
282	        // Require a non-null delegate.
283	        if (delegate == address(0)) {
284	            revert InvalidDelegateError();
285	        }
286	
287	        // Must not be blocked by gatekeeper.
288	        IGateKeeper _gateKeeper = gateKeeper;
289	        if (_gateKeeper != IGateKeeper(address(0))) {
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
291	                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);
292	            }
293	        }
294	
295	        votingPower = _processContribution(contributor, delegate, amount);
296	
297	        // OK to contribute with zero just to update delegate.
298	        if (amount == 0) return 0;
299	
300	        if (tokenId == 0) {
301	            // Mint contributor a new party card.
302	            party.mint(contributor, votingPower, delegate);
303	        } else if (disableContributingForExistingCard) {
304	            revert ContributingForExistingCardDisabledError();
305	        } else if (party.ownerOf(tokenId) == contributor) {
306	            // Increase voting power of contributor's existing party card.
307	            party.increaseVotingPower(tokenId, votingPower);
308	        } else {
309	            revert NotOwnerError(tokenId);
310	        }
311	    }
...
372	    function _createParty(
373	        ETHPartyOptions memory opts,
374	        MetadataProvider customMetadataProvider,
375	        bytes memory customMetadata
376	    ) private returns (Party) {
377	        uint256 authoritiesLength = opts.authorities.length + 1;
378	        address[] memory authorities = new address[](authoritiesLength);
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
382	        authorities[authoritiesLength - 1] = address(this);
383	
384	        if (address(customMetadataProvider) == address(0)) {
385	            return
386	                opts.governanceOpts.partyFactory.createParty(
387	                    opts.governanceOpts.partyImpl,
388	                    authorities,
389	                    Party.PartyOptions({
390	                        name: opts.name,
391	                        symbol: opts.symbol,
392	                        customizationPresetId: opts.customizationPresetId,
393	                        governance: PartyGovernance.GovernanceOpts({
394	                            hosts: opts.governanceOpts.hosts,
395	                            voteDuration: opts.governanceOpts.voteDuration,
396	                            executionDelay: opts.governanceOpts.executionDelay,
397	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
398	                            totalVotingPower: 0,
399	                            feeBps: opts.governanceOpts.feeBps,
400	                            feeRecipient: opts.governanceOpts.feeRecipient
401	                        }),
402	                        proposalEngine: opts.proposalEngineOpts
403	                    }),
404	                    opts.preciousTokens,
405	                    opts.preciousTokenIds,
406	                    opts.rageQuitTimestamp
407	                );
408	        } else {
409	            return
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
411	                    opts.governanceOpts.partyImpl,
412	                    authorities,
413	                    Party.PartyOptions({
414	                        name: opts.name,
415	                        symbol: opts.symbol,
416	                        customizationPresetId: opts.customizationPresetId,
417	                        governance: PartyGovernance.GovernanceOpts({
418	                            hosts: opts.governanceOpts.hosts,
419	                            voteDuration: opts.governanceOpts.voteDuration,
420	                            executionDelay: opts.governanceOpts.executionDelay,
421	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
422	                            totalVotingPower: 0,
423	                            feeBps: opts.governanceOpts.feeBps,
424	                            feeRecipient: opts.governanceOpts.feeRecipient
425	                        }),
426	                        proposalEngine: opts.proposalEngineOpts
427	                    }),
428	                    opts.preciousTokens,
429	                    opts.preciousTokenIds,
430	                    opts.rageQuitTimestamp,
431	                    customMetadataProvider,
432	                    customMetadata
433	                );
434	        }
435	    }
```
[99](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L99)
[275..311](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L275-L311)
[372..435](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L372-L435)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
134	    constructor(IGlobals globals) {
135	        _GLOBALS = globals;
136	    }
137	
...
140	    function _initialize(ETHCrowdfundOptions memory opts) internal {
141	        // Set the minimum and maximum contribution amounts.
142	        if (opts.minContribution > opts.maxContribution) {
143	            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);
144	        }
145	        minContribution = opts.minContribution;
146	        maxContribution = opts.maxContribution;
147	        // Set the min total contributions.
148	        if (opts.minTotalContributions > opts.maxTotalContributions) {
149	            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);
150	        }
151	        minTotalContributions = opts.minTotalContributions;
152	        // Set the max total contributions.
153	        if (opts.maxTotalContributions == 0) {
154	            // Prevent this because when `maxTotalContributions` is 0 the
155	            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has
156	            // never been initialized.
157	            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);
158	        }
159	        maxTotalContributions = opts.maxTotalContributions;
160	        // Set the party crowdfund is for.
161	        party = opts.party;
162	        // Set the crowdfund start and end timestamps.
163	        expiry = uint40(block.timestamp + opts.duration);
164	        // Set the exchange rate.
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
166	        exchangeRateBps = opts.exchangeRateBps;
167	        // Set the funding split and its recipient.
168	        fundingSplitBps = opts.fundingSplitBps;
169	        fundingSplitRecipient = opts.fundingSplitRecipient;
170	        // Set whether to disable contributing for existing card.
171	        disableContributingForExistingCard = opts.disableContributingForExistingCard;
172	    }
173	
...
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
...
317	    function _finalize(uint96 totalContributions_) internal {
318	        // Finalize the crowdfund.
319	        delete expiry;
320	
321	        // Transfer funding split to recipient if applicable.
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
323	        uint16 fundingSplitBps_ = fundingSplitBps;
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
326	        }
327	
328	        // Update the party's total voting power.
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
330	        party.increaseTotalVotingPower(newVotingPower);
331	
332	        // Transfer ETH to the party.
333	        payable(address(party)).transferEth(totalContributions_);
334	
335	        emit Finalized();
336	    }
337	
```
[134..137](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L134-L137)
[140..173](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L140-L173)
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)
[317..337](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L317-L337)

---

	 - contracts/party/PartyGovernance.sol

```solidity
265	    constructor(IGlobals globals) {
266	        _GLOBALS = globals;
267	    }
268	
...
270	    function _initialize(
271	        GovernanceOpts memory govOpts,
272	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
273	        IERC721[] memory preciousTokens,
274	        uint256[] memory preciousTokenIds
275	    ) internal virtual {
276	        // Check BPS are valid.
277	        if (govOpts.feeBps > 1e4) {
278	            revert InvalidBpsError(govOpts.feeBps);
279	        }
280	        if (govOpts.passThresholdBps > 1e4) {
281	            revert InvalidBpsError(govOpts.passThresholdBps);
282	        }
283	        // Initialize the proposal execution engine.
284	        _initProposalImpl(
285	            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),
286	            abi.encode(proposalEngineOpts)
287	        );
288	        // Set the governance parameters.
289	        _getSharedProposalStorage().governanceValues = GovernanceValues({
290	            voteDuration: govOpts.voteDuration,
291	            executionDelay: govOpts.executionDelay,
292	            passThresholdBps: govOpts.passThresholdBps,
293	            totalVotingPower: govOpts.totalVotingPower
294	        });
295	        numHosts = uint8(govOpts.hosts.length);
296	        // Set fees.
297	        feeBps = govOpts.feeBps;
298	        feeRecipient = govOpts.feeRecipient;
299	        // Set the precious list.
300	        _setPreciousList(preciousTokens, preciousTokenIds);
301	        // Set the party hosts.
302	        if (govOpts.hosts.length > type(uint8).max) {
303	            revert TooManyHosts();
304	        }
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
309	
...
487	    function distribute(
488	        uint256 amount,
489	        ITokenDistributor.TokenType tokenType,
490	        address token,
491	        uint256 tokenId
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
493	        _assertNotGloballyDisabled();
494	        // Ignore if the party is calling functions on itself, like with
495	        // `FractionalizeProposal` and `DistributionProposal`.
496	        if (msg.sender != address(this)) {
497	            // Must not require a vote to create a distribution, otherwise
498	            // distributions can only be created through a distribution
499	            // proposal.
500	            if (_getSharedProposalStorage().opts.distributionsRequireVote) {
501	                revert DistributionsRequireVoteError();
502	            }
503	            // Must be an active member.
504	            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
509	        // Prevent creating a distribution if the party has not started.
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
511	            revert PartyNotStartedError();
512	        }
513	        // Get the address of the token distributor.
514	        ITokenDistributor distributor = ITokenDistributor(
515	            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)
516	        );
517	        emit DistributionCreated(tokenType, token, tokenId);
518	        // Notify third-party platforms that the governance NFT metadata has
519	        // updated for all tokens.
520	        emit BatchMetadataUpdate(0, type(uint256).max);
521	        // Create a native token distribution.
522	        address payable feeRecipient_ = feeRecipient;
523	        uint16 feeBps_ = feeBps;
524	        if (tokenType == ITokenDistributor.TokenType.Native) {
525	            return
526	                distributor.createNativeDistribution{ value: amount }(
527	                    Party(payable(address(this))),
528	                    feeRecipient_,
529	                    feeBps_
530	                );
531	        }
532	        // Otherwise must be an ERC20 token distribution.
533	        assert(tokenType == ITokenDistributor.TokenType.Erc20);
534	        IERC20(token).compatTransfer(address(distributor), amount);
535	        return
536	            distributor.createErc20Distribution(
537	                IERC20(token),
538	                Party(payable(address(this))),
539	                feeRecipient_,
540	                feeBps_
541	            );
542	    }
543	
...
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
...
904	    function _getVotingPowerSnapshotAt(
905	        address voter,
906	        uint40 timestamp,
907	        uint256 hintIndex
908	    ) internal view returns (VotingPowerSnapshot memory snap) {
909	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
910	        uint256 snapsLength = snaps.length;
911	        if (snapsLength != 0) {
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
923	            // Hint was wrong, fallback to binary search to find snapshot.
924	            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);
925	            // Check that snapshot was found.
926	            if (hintIndex != type(uint256).max) {
927	                return snaps[hintIndex];
928	            }
929	        }
930	
931	        // No snapshot found.
932	        return snap;
933	    }
934	
...
937	    function _transferVotingPower(address from, address to, uint256 power) internal {
938	        int192 powerI192 = power.safeCastUint256ToInt192();
939	        _adjustVotingPower(from, -powerI192, address(0));
940	        _adjustVotingPower(to, powerI192, address(0));
941	    }
942	
...
944	    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {
945	        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);
946	        address oldDelegate = delegationsByVoter[voter];
947	        // If `oldDelegate` is zero and `voter` never delegated, then have
948	        // `voter` delegate to themself.
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
950	        // If the new `delegate` is zero, use the current (old) delegate.
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
952	
953	        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({
954	            timestamp: uint40(block.timestamp),
955	            delegatedVotingPower: oldSnap.delegatedVotingPower,
956	            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +
957	                votingPower).safeCastInt192ToUint96(),
958	            isDelegated: delegate != voter
959	        });
960	        _insertVotingPowerSnapshot(voter, newSnap);
961	        delegationsByVoter[voter] = delegate;
962	
963	        // This event is emitted even if the delegate did not change.
964	        emit PartyDelegateUpdated(voter, delegate);
965	
966	        // Handle rebalancing delegates.
967	        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);
968	    }
969	
...
972	    function _rebalanceDelegates(
973	        address voter,
974	        address oldDelegate,
975	        address newDelegate,
976	        VotingPowerSnapshot memory oldSnap,
977	        VotingPowerSnapshot memory newSnap
978	    ) private {
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
980	            revert InvalidDelegateError();
981	        }
982	        if (oldDelegate != voter && oldDelegate != newDelegate) {
983	            // Remove past voting power from old delegate.
984	            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(
985	                oldDelegate
986	            );
987	            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({
988	                timestamp: uint40(block.timestamp),
989	                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -
990	                    oldSnap.intrinsicVotingPower,
991	                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,
992	                isDelegated: oldDelegateSnap.isDelegated
993	            });
994	            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);
995	        }
996	        if (newDelegate != voter) {
997	            // Not delegating to self.
998	            // Add new voting power to new delegate.
999	            VotingPowerSnapshot memory newDelegateSnap = _getLastVotingPowerSnapshotForVoter(
1000	                newDelegate
1001	            );
1002	            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +
1003	                newSnap.intrinsicVotingPower;
1004	            if (newDelegate == oldDelegate) {
1005	                // If the old and new delegate are the same, subtract the old
1006	                // intrinsic voting power of the voter, or else we will double
1007	                // count a portion of it.
1008	                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;
1009	            }
1010	            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({
1011	                timestamp: uint40(block.timestamp),
1012	                delegatedVotingPower: newDelegateDelegatedVotingPower,
1013	                intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,
1014	                isDelegated: newDelegateSnap.isDelegated
1015	            });
1016	            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);
1017	        }
1018	    }
1019	
...
1021	    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap) private {
1022	        emit PartyVotingSnapshotCreated(
1023	            voter,
1024	            snap.timestamp,
1025	            snap.delegatedVotingPower,
1026	            snap.intrinsicVotingPower,
1027	            snap.isDelegated
1028	        );
1029	
1030	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1031	        uint256 n = voterSnaps.length;
1032	        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.
1033	        if (n != 0) {
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
1035	            if (lastSnap.timestamp == snap.timestamp) {
1036	                voterSnaps[n - 1] = snap;
1037	                return;
1038	            }
1039	        }
1040	        voterSnaps.push(snap);
1041	    }
1042	
...
1043	    function _getLastVotingPowerSnapshotForVoter(
1044	        address voter
1045	    ) private view returns (VotingPowerSnapshot memory snap) {
1046	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1047	        uint256 n = voterSnaps.length;
1048	        if (n != 0) {
1049	            snap = voterSnaps[n - 1];
1050	        }
1051	    }
1052	
...
1053	    function _getProposalFlags(ProposalStateValues memory pv) private pure returns (uint256) {
1054	        uint256 flags = 0;
1055	        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1056	            flags = flags | LibProposal.PROPOSAL_FLAG_UNANIMOUS;
1057	        }
1058	        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1059	            flags = flags | LibProposal.PROPOSAL_FLAG_HOSTS_ACCEPT;
1060	        }
1061	        return flags;
1062	    }
1063	
...
1064	    function _getProposalStatus(
1065	        ProposalStateValues memory pv
1066	    ) private view returns (ProposalStatus status) {
1067	        // Never proposed.
1068	        if (pv.proposedTime == 0) {
1069	            return ProposalStatus.Invalid;
1070	        }
1071	        // Executed at least once.
1072	        if (pv.executedTime != 0) {
1073	            if (pv.completedTime == 0) {
1074	                return ProposalStatus.InProgress;
1075	            }
1076	            // completedTime high bit will be set if cancelled.
1077	            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {
1078	                return ProposalStatus.Cancelled;
1079	            }
1080	            return ProposalStatus.Complete;
1081	        }
1082	        // Vetoed.
1083	        if (pv.votes == type(uint96).max) {
1084	            return ProposalStatus.Defeated;
1085	        }
1086	        uint40 t = uint40(block.timestamp);
1087	        GovernanceValues memory gv = _getSharedProposalStorage().governanceValues;
1088	        if (pv.passedTime != 0) {
1089	            // Ready.
1090	            if (pv.passedTime + gv.executionDelay <= t) {
1091	                return ProposalStatus.Ready;
1092	            }
1093	            // If unanimous, we skip the execution delay.
1094	            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1095	                return ProposalStatus.Ready;
1096	            }
1097	            // If all hosts voted, skip execution delay
1098	            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1099	                return ProposalStatus.Ready;
1100	            }
1101	            // Passed.
1102	            return ProposalStatus.Passed;
1103	        }
1104	        // Voting window expired.
1105	        if (pv.proposedTime + gv.voteDuration <= t) {
1106	            return ProposalStatus.Defeated;
1107	        }
1108	        return ProposalStatus.Voting;
1109	    }
1110	
...
1111	    function _isUnanimousVotes(
1112	        uint96 totalVotes,
1113	        uint96 totalVotingPower
1114	    ) private pure returns (bool) {
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
1116	        // If >= 99.99% acceptance, consider it unanimous.
1117	        // The minting formula for voting power is a bit lossy, so we check
1118	        // for slightly less than 100%.
1119	        return acceptanceRatio >= 0.9999e4;
1120	    }
1121	
...
1122	    function _hostsAccepted(
1123	        uint8 snapshotNumHosts,
1124	        uint8 numHostsAccepted
1125	    ) private pure returns (bool) {
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
1127	    }
1128	
...
1129	    function _areVotesPassing(
1130	        uint96 voteCount,
1131	        uint96 totalVotingPower,
1132	        uint16 passThresholdBps
1133	    ) private pure returns (bool) {
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
1135	    }
1136	
...
1137	    function _setPreciousList(
1138	        IERC721[] memory preciousTokens,
1139	        uint256[] memory preciousTokenIds
1140	    ) private {
1141	        if (preciousTokens.length != preciousTokenIds.length) {
1142	            revert MismatchedPreciousListLengths();
1143	        }
1144	        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);
1145	    }
1146	
...
1147	    function _isPreciousListCorrect(
1148	        IERC721[] memory preciousTokens,
1149	        uint256[] memory preciousTokenIds
1150	    ) private view returns (bool) {
1151	        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);
1152	    }
1153	
...
1154	    function _hashPreciousList(
1155	        IERC721[] memory preciousTokens,
1156	        uint256[] memory preciousTokenIds
1157	    ) internal pure returns (bytes32 h) {
1158	        assembly {
1159	            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))
1160	            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))
1161	            h := keccak256(0x00, 0x40)
1162	        }
1163	    }
1164	
...
1166	    function _validateProposalHash(Proposal memory proposal, bytes32 expectedHash) private pure {
1167	        bytes32 actualHash = getProposalHash(proposal);
1168	        if (expectedHash != actualHash) {
1169	            revert BadProposalHashError(actualHash, expectedHash);
1170	        }
1171	    }
1172	}
```
[265..268](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L265-L268)
[270..309](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L270-L309)
[487..543](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L487-L543)
[860..902](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L860-L902)
[904..934](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L904-L934)
[937..942](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L937-L942)
[944..969](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L944-L969)
[972..1019](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L972-L1019)
[1021..1042](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1021-L1042)
[1043..1052](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1043-L1052)
[1053..1063](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1053-L1063)
[1064..1110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1064-L1110)
[1111..1121](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1111-L1121)
[1122..1128](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1122-L1128)
[1129..1136](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1129-L1136)
[1137..1146](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1137-L1146)
[1147..1153](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1147-L1153)
[1154..1164](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1154-L1164)
[1166..1172](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1166-L1172)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
76	    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721("", "") {
77	        _GLOBALS = globals;
78	    }
...
81	    function _initialize(
82	        string memory name_,
83	        string memory symbol_,
84	        uint256 customizationPresetId,
85	        PartyGovernance.GovernanceOpts memory governanceOpts,
86	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
87	        IERC721[] memory preciousTokens,
88	        uint256[] memory preciousTokenIds,
89	        address[] memory authorities,
90	        uint40 rageQuitTimestamp_
91	    ) internal {
92	        PartyGovernance._initialize(
93	            governanceOpts,
94	            proposalEngineOpts,
95	            preciousTokens,
96	            preciousTokenIds
97	        );
98	        name = name_;
99	        symbol = symbol_;
100	        rageQuitTimestamp = rageQuitTimestamp_;
101	        unchecked {
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
105	        }
106	        if (customizationPresetId != 0) {
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
109	        }
110	    }
...
113	    function supportsInterface(
114	        bytes4 interfaceId
115	    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {
116	        return
117	            PartyGovernance.supportsInterface(interfaceId) ||
118	            ERC721.supportsInterface(interfaceId) ||
119	            interfaceId == type(IERC2981).interfaceId;
120	    }
...
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
...
136	    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {
137	        _delegateToRenderer();
138	        return (address(0), 0); // Just to make the compiler happy.
139	    }
...
268	    function _burnAndUpdateVotingPower(
269	        uint256[] memory tokenIds,
270	        bool checkIfAuthorizedToBurn
271	    ) private returns (uint96 totalVotingPowerBurned) {
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
302	
303	        // Update minted voting power.
304	        mintedVotingPower -= totalVotingPowerBurned;
305	    }
...
451	    function transferFrom(address owner, address to, uint256 tokenId) public override {
452	        // Transfer voting along with token.
453	        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);
454	        super.transferFrom(owner, to, tokenId);
455	    }
...
458	    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {
459	        // super.safeTransferFrom() will call transferFrom() first which will
460	        // transfer voting power.
461	        super.safeTransferFrom(owner, to, tokenId);
462	    }
...
465	    function safeTransferFrom(
466	        address owner,
467	        address to,
468	        uint256 tokenId,
469	        bytes calldata data
470	    ) public override {
471	        // super.safeTransferFrom() will call transferFrom() first which will
472	        // transfer voting power.
473	        super.safeTransferFrom(owner, to, tokenId, data);
474	    }
...
479	    function addAuthority(address authority) external onlySelf {
480	        isAuthority[authority] = true;
481	
482	        emit AuthorityAdded(authority);
483	    }
```
[76..78](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L76-L78)
[81..110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L81-L110)
[113..120](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L113-L120)
[123..126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L123-L126)
[136..139](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L136-L139)
[268..305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L268-L305)
[451..455](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L451-L455)
[458..462](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L458-L462)
[465..474](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L465-L474)
[479..483](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L479-L483)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
107	    constructor(
108	        IGlobals globals,
109	        IReserveAuctionCoreEth zora,
110	        IFractionalV1VaultFactory fractionalVaultFactory
111	    )
112	        ListOnOpenseaAdvancedProposal(globals)
113	        ListOnZoraProposal(globals, zora)
114	        FractionalizeProposal(fractionalVaultFactory)
115	        ArbitraryCallsProposal(zora)
116	    {
117	        _GLOBALS = globals;
118	    }
119	
...
146	    function executeProposal(
147	        ExecuteProposalParams memory params
148	    ) external onlyDelegateCall returns (bytes memory nextProgressData) {
149	        // Must have a valid proposal ID.
150	        if (params.proposalId == 0) {
151	            revert ZeroProposalIdError();
152	        }
153	        Storage storage stor = _getStorage();
154	        uint256 currentInProgressProposalId = stor.currentInProgressProposalId;
155	        if (currentInProgressProposalId == 0) {
156	            // No proposal is currently in progress.
157	            // Mark this proposal as the one in progress.
158	            stor.currentInProgressProposalId = params.proposalId;
159	        } else if (currentInProgressProposalId != params.proposalId) {
160	            // Only one proposal can be in progress at a time.
161	            revert ProposalExecutionBlockedError(params.proposalId, currentInProgressProposalId);
162	        }
163	        {
164	            bytes32 nextProgressDataHash = stor.nextProgressDataHash;
165	            if (nextProgressDataHash == 0) {
166	                // Expecting no progress data.
167	                // This is the state if there is no current `InProgress` proposal.
168	                assert(currentInProgressProposalId == 0);
169	                if (params.progressData.length != 0) {
170	                    revert ProposalProgressDataInvalidError(
171	                        keccak256(params.progressData),
172	                        nextProgressDataHash
173	                    );
174	                }
175	            } else {
176	                // Expecting progress data.
177	                bytes32 progressDataHash = keccak256(params.progressData);
178	                // Progress data must match the one stored.
179	                if (nextProgressDataHash != progressDataHash) {
180	                    revert ProposalProgressDataInvalidError(progressDataHash, nextProgressDataHash);
181	                }
182	            }
183	            // Temporarily set the expected next progress data hash to an
184	            // unachievable constant to act as a reentrancy guard.
185	            stor.nextProgressDataHash = bytes32(type(uint256).max);
186	        }
187	
188	        // Note that we do not enforce that the proposal has not been executed
189	        // (and completed) before in this contract. That is enforced by PartyGovernance.
190	
191	        // Execute the proposal.
192	        ProposalType pt;
193	        (pt, params.proposalData) = _extractProposalType(params.proposalData);
194	        nextProgressData = _execute(pt, params);
195	
196	        // If progress data is empty, the proposal is complete.
197	        if (nextProgressData.length == 0) {
198	            stor.currentInProgressProposalId = 0;
199	            stor.nextProgressDataHash = 0;
200	        } else {
201	            // Remember the next progress data.
202	            stor.nextProgressDataHash = keccak256(nextProgressData);
203	        }
204	    }
205	
...
207	    function cancelProposal(uint256 proposalId) external onlyDelegateCall {
208	        // Must be a valid proposal ID.
209	        if (proposalId == 0) {
210	            revert ZeroProposalIdError();
211	        }
212	        Storage storage stor = _getStorage();
213	        {
214	            // Must be the current InProgress proposal.
215	            uint256 currentInProgressProposalId = stor.currentInProgressProposalId;
216	            if (currentInProgressProposalId != proposalId) {
217	                revert ProposalNotInProgressError(proposalId);
218	            }
219	        }
220	        // Clear the current InProgress proposal ID and next progress data.
221	        stor.currentInProgressProposalId = 0;
222	        stor.nextProgressDataHash = 0;
223	    }
224	
...
225	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
226	        IERC1271 validator = getSignatureValidatorForHash(hash);
227	        if (address(validator) == address(1)) {
228	            // Signature set by party to be always valid
229	            return IERC1271.isValidSignature.selector;
230	        }
231	        if (address(validator) != address(0)) {
232	            return validator.isValidSignature(hash, signature);
233	        }
234	        if (tx.origin == address(0)) {
235	            validator = getSignatureValidatorForHash(0);
236	            if (address(validator) == address(0)) {
237	                // Use global off-chain signature validator
238	                validator = IERC1271(
239	                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)
240	                );
241	            }
242	            return validator.isValidSignature(hash, signature);
243	        }
244	        return 0;
245	    }
246	
...
248	    function _execute(
249	        ProposalType pt,
250	        ExecuteProposalParams memory params
251	    ) internal virtual returns (bytes memory nextProgressData) {
252	        if (pt == ProposalType.ListOnOpensea) {
253	            nextProgressData = _executeListOnOpensea(params);
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
293	
...
297	    function _extractProposalType(
298	        bytes memory proposalData
299	    ) private pure returns (ProposalType proposalType, bytes memory offsetProposalData) {
300	        // First 4 bytes is proposal type. While the proposal type could be
301	        // stored in just 1 byte, this makes it easier to encode with
302	        // `abi.encodeWithSelector`.
303	        if (proposalData.length < 4) {
304	            revert MalformedProposalDataError();
305	        }
306	        assembly {
307	            // By reading 4 bytes into the length prefix, the leading 4 bytes
308	            // of the data will be in the lower bits of the read word.
309	            proposalType := and(mload(add(proposalData, 4)), 0xffffffff)
310	            mstore(add(proposalData, 4), sub(mload(proposalData), 4))
311	            offsetProposalData := add(proposalData, 4)
312	        }
313	        require(proposalType != ProposalType.Invalid);
314	        require(uint8(proposalType) <= uint8(type(ProposalType).max));
315	    }
316	
...
318	    function _executeUpgradeProposalsImplementation(bytes memory proposalData) private {
319	        (address expectedImpl, bytes memory initData) = abi.decode(proposalData, (address, bytes));
320	        // Always upgrade to latest implementation stored in `_GLOBALS`.
321	        IProposalExecutionEngine newImpl = IProposalExecutionEngine(
322	            _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)
323	        );
324	        if (expectedImpl != address(newImpl)) {
325	            revert UnexpectedProposalEngineImplementationError(
326	                newImpl,
327	                IProposalExecutionEngine(expectedImpl)
328	            );
329	        }
330	        _initProposalImpl(newImpl, initData);
331	        emit ProposalEngineImplementationUpgraded(address(implementation), expectedImpl);
332	    }
333	
```
[107..119](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L107-L119)
[146..205](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L146-L205)
[207..224](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L207-L224)
[225..246](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L225-L246)
[248..293](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L248-L293)
[297..316](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L297-L316)
[318..333](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L318-L333)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
43	    function _initProposalImpl(IProposalExecutionEngine impl, bytes memory initData) internal {
44	        SharedProposalStorage storage stor = _getSharedProposalStorage();
45	        IProposalExecutionEngine oldImpl = stor.engineImpl;
46	        stor.engineImpl = impl;
47	        (bool s, bytes memory r) = address(impl).delegatecall(
48	            abi.encodeCall(IProposalExecutionEngine.initialize, (address(oldImpl), initData))
49	        );
50	        if (!s) {
51	            r.rawRevert();
52	        }
53	    }
```
[43..53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L43-L53)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
25	    function _executeSetGovernanceParameter(
26	        IProposalExecutionEngine.ExecuteProposalParams memory params
27	    ) internal returns (bytes memory) {
28	        SetGovernanceParameterProposalData memory proposalData = abi.decode(
29	            params.proposalData,
30	            (SetGovernanceParameterProposalData)
31	        );
32	        if (proposalData.voteDuration != 0) {
33	            if (proposalData.voteDuration < 1 hours) {
34	                revert InvalidGovernanceParameter(proposalData.voteDuration);
35	            }
36	            emit VoteDurationSet(
37	                _getSharedProposalStorage().governanceValues.voteDuration,
38	                proposalData.voteDuration
39	            );
40	            _getSharedProposalStorage().governanceValues.voteDuration = proposalData.voteDuration;
41	        }
42	        if (proposalData.executionDelay != 0) {
43	            if (proposalData.executionDelay > 30 days) {
44	                revert InvalidGovernanceParameter(proposalData.executionDelay);
45	            }
46	            emit ExecutionDelaySet(
47	                _getSharedProposalStorage().governanceValues.executionDelay,
48	                proposalData.executionDelay
49	            );
50	            _getSharedProposalStorage().governanceValues.executionDelay = proposalData
51	                .executionDelay;
52	        }
53	        if (proposalData.passThresholdBps != 0) {
54	            if (proposalData.passThresholdBps > 10000) {
55	                revert InvalidGovernanceParameter(proposalData.passThresholdBps);
56	            }
57	            emit PassThresholdBpsSet(
58	                _getSharedProposalStorage().governanceValues.passThresholdBps,
59	                proposalData.passThresholdBps
60	            );
61	            _getSharedProposalStorage().governanceValues.passThresholdBps = proposalData
62	                .passThresholdBps;
63	        }
64	
65	        return "";
66	    }
```
[25..66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L25-L66)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
28	    function _executeSetSignatureValidator(
29	        IProposalExecutionEngine.ExecuteProposalParams memory params
30	    ) internal returns (bytes memory nextProgressData) {
31	        SetSignatureValidatorProposalData memory data = abi.decode(
32	            params.proposalData,
33	            (SetSignatureValidatorProposalData)
34	        );
35	        _getSetSignatureValidatorProposalStorage().signatureValidators[data.signatureHash] = data
36	            .signatureValidator;
37	        nextProgressData = "";
38	
39	        emit SignatureValidatorSet(data.signatureHash, data.signatureValidator);
40	    }
...
42	    function getSignatureValidatorForHash(bytes32 hash) public view returns (IERC1271) {
43	        return _getSetSignatureValidatorProposalStorage().signatureValidators[hash];
44	    }
```
[28..40](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L28-L40)
[42..44](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L42-L44)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
28	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
29	        uint8 v;
30	        bytes32 r;
31	        bytes32 s;
32	        assembly {
33	            // First word of signature after size contains r
34	            r := mload(add(signature, 0x20))
35	            s := mload(add(signature, 0x40))
36	            // v is one byte which starts after s. type is uint8 so extra data will be ignored
37	            v := mload(add(signature, 0x41))
38	        }
39	
40	        bytes memory message;
41	        assembly {
42	            // Raw message data begins after v. Overwriting part of s and v with size of `message`
43	            message := add(signature, 0x41)
44	            mstore(message, sub(mload(signature), 0x41))
45	        }
46	
47	        // Recreate the message pre-hash from the raw data
48	        bytes memory encodedPacket = abi.encodePacked(
49	            "\x19Ethereum Signed Message:\n",
50	            Strings.toString(message.length),
51	            message
52	        );
53	        if (keccak256(encodedPacket) != hash) {
54	            revert MessageHashMismatch();
55	        }
56	
57	        Party party = Party(payable(msg.sender));
58	        address signer = ecrecover(hash, v, r, s);
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
60	            10000;
61	
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
63	            // Must own a party card or be delegatated voting power
64	            revert NotMemberOfParty();
65	        }
66	
67	        uint96 totalVotingPower = party.getGovernanceValues().totalVotingPower;
68	        uint96 thresholdBps = signingThersholdBps[party];
69	
70	        // Either threshold is 0 or signer votes above threshold
71	        if (
72	            thresholdBps == 0 ||
73	            (signerVotingPowerBps > totalVotingPower &&
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
75	        ) {
76	            return IERC1271.isValidSignature.selector;
77	        }
78	
79	        revert InsufficientVotingPower();
80	    }
```
[28..80](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L28-L80)


</details>

-------
### [N-05] Function declarations should have NatSpec descriptions
<a name="N-05"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 44 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
99	    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}
...
275	    function _contribute(
276	        address payable contributor,
277	        address delegate,
278	        uint96 amount,
279	        uint256 tokenId,
280	        bytes memory gateData
281	    ) private returns (uint96 votingPower) {
282	        // Require a non-null delegate.
283	        if (delegate == address(0)) {
284	            revert InvalidDelegateError();
285	        }
286	
287	        // Must not be blocked by gatekeeper.
288	        IGateKeeper _gateKeeper = gateKeeper;
289	        if (_gateKeeper != IGateKeeper(address(0))) {
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
291	                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);
292	            }
293	        }
294	
295	        votingPower = _processContribution(contributor, delegate, amount);
296	
297	        // OK to contribute with zero just to update delegate.
298	        if (amount == 0) return 0;
299	
300	        if (tokenId == 0) {
301	            // Mint contributor a new party card.
302	            party.mint(contributor, votingPower, delegate);
303	        } else if (disableContributingForExistingCard) {
304	            revert ContributingForExistingCardDisabledError();
305	        } else if (party.ownerOf(tokenId) == contributor) {
306	            // Increase voting power of contributor's existing party card.
307	            party.increaseVotingPower(tokenId, votingPower);
308	        } else {
309	            revert NotOwnerError(tokenId);
310	        }
311	    }
...
372	    function _createParty(
373	        ETHPartyOptions memory opts,
374	        MetadataProvider customMetadataProvider,
375	        bytes memory customMetadata
376	    ) private returns (Party) {
377	        uint256 authoritiesLength = opts.authorities.length + 1;
378	        address[] memory authorities = new address[](authoritiesLength);
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
382	        authorities[authoritiesLength - 1] = address(this);
383	
384	        if (address(customMetadataProvider) == address(0)) {
385	            return
386	                opts.governanceOpts.partyFactory.createParty(
387	                    opts.governanceOpts.partyImpl,
388	                    authorities,
389	                    Party.PartyOptions({
390	                        name: opts.name,
391	                        symbol: opts.symbol,
392	                        customizationPresetId: opts.customizationPresetId,
393	                        governance: PartyGovernance.GovernanceOpts({
394	                            hosts: opts.governanceOpts.hosts,
395	                            voteDuration: opts.governanceOpts.voteDuration,
396	                            executionDelay: opts.governanceOpts.executionDelay,
397	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
398	                            totalVotingPower: 0,
399	                            feeBps: opts.governanceOpts.feeBps,
400	                            feeRecipient: opts.governanceOpts.feeRecipient
401	                        }),
402	                        proposalEngine: opts.proposalEngineOpts
403	                    }),
404	                    opts.preciousTokens,
405	                    opts.preciousTokenIds,
406	                    opts.rageQuitTimestamp
407	                );
408	        } else {
409	            return
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
411	                    opts.governanceOpts.partyImpl,
412	                    authorities,
413	                    Party.PartyOptions({
414	                        name: opts.name,
415	                        symbol: opts.symbol,
416	                        customizationPresetId: opts.customizationPresetId,
417	                        governance: PartyGovernance.GovernanceOpts({
418	                            hosts: opts.governanceOpts.hosts,
419	                            voteDuration: opts.governanceOpts.voteDuration,
420	                            executionDelay: opts.governanceOpts.executionDelay,
421	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
422	                            totalVotingPower: 0,
423	                            feeBps: opts.governanceOpts.feeBps,
424	                            feeRecipient: opts.governanceOpts.feeRecipient
425	                        }),
426	                        proposalEngine: opts.proposalEngineOpts
427	                    }),
428	                    opts.preciousTokens,
429	                    opts.preciousTokenIds,
430	                    opts.rageQuitTimestamp,
431	                    customMetadataProvider,
432	                    customMetadata
433	                );
434	        }
435	    }
```
[99](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L99)
[275..311](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L275-L311)
[372..435](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L372-L435)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
134	    constructor(IGlobals globals) {
135	        _GLOBALS = globals;
136	    }
137	
...
140	    function _initialize(ETHCrowdfundOptions memory opts) internal {
141	        // Set the minimum and maximum contribution amounts.
142	        if (opts.minContribution > opts.maxContribution) {
143	            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);
144	        }
145	        minContribution = opts.minContribution;
146	        maxContribution = opts.maxContribution;
147	        // Set the min total contributions.
148	        if (opts.minTotalContributions > opts.maxTotalContributions) {
149	            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);
150	        }
151	        minTotalContributions = opts.minTotalContributions;
152	        // Set the max total contributions.
153	        if (opts.maxTotalContributions == 0) {
154	            // Prevent this because when `maxTotalContributions` is 0 the
155	            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has
156	            // never been initialized.
157	            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);
158	        }
159	        maxTotalContributions = opts.maxTotalContributions;
160	        // Set the party crowdfund is for.
161	        party = opts.party;
162	        // Set the crowdfund start and end timestamps.
163	        expiry = uint40(block.timestamp + opts.duration);
164	        // Set the exchange rate.
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
166	        exchangeRateBps = opts.exchangeRateBps;
167	        // Set the funding split and its recipient.
168	        fundingSplitBps = opts.fundingSplitBps;
169	        fundingSplitRecipient = opts.fundingSplitRecipient;
170	        // Set whether to disable contributing for existing card.
171	        disableContributingForExistingCard = opts.disableContributingForExistingCard;
172	    }
173	
...
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
...
291	    function finalize() external {
292	        uint96 totalContributions_ = totalContributions;
293	
294	        // Check that the crowdfund is not already finalized.
295	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
296	        if (lc == CrowdfundLifecycle.Active) {
297	            // Allow host to finalize crowdfund early if it has reached its minimum goal.
298	            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();
299	
300	            // Check that the crowdfund has reached its minimum goal.
301	            uint96 minTotalContributions_ = minTotalContributions;
302	            if (totalContributions_ < minTotalContributions_) {
303	                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);
304	            }
305	        } else {
306	            // Otherwise only allow finalization if the crowdfund has expired
307	            // and been won. Can be finalized by anyone.
308	            if (lc != CrowdfundLifecycle.Won) {
309	                revert WrongLifecycleError(lc);
310	            }
311	        }
312	
313	        // Finalize the crowdfund.
314	        _finalize(totalContributions_);
315	    }
316	
...
317	    function _finalize(uint96 totalContributions_) internal {
318	        // Finalize the crowdfund.
319	        delete expiry;
320	
321	        // Transfer funding split to recipient if applicable.
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
323	        uint16 fundingSplitBps_ = fundingSplitBps;
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
326	        }
327	
328	        // Update the party's total voting power.
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
330	        party.increaseTotalVotingPower(newVotingPower);
331	
332	        // Transfer ETH to the party.
333	        payable(address(party)).transferEth(totalContributions_);
334	
335	        emit Finalized();
336	    }
337	
```
[134..137](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L134-L137)
[140..173](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L140-L173)
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)
[291..316](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L291-L316)
[317..337](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L317-L337)

---

	 - contracts/party/PartyGovernance.sol

```solidity
216	    function _assertHost() internal view {
217	        if (!isHost[msg.sender]) {
218	            revert NotAuthorized();
219	        }
220	    }
221	
...
222	    function _assertActiveMember() internal view {
223	        VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
224	        // Must have either delegated voting power or intrinsic voting power.
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
226	            revert NotAuthorized();
227	        }
228	    }
229	
...
258	    function _assertNotGloballyDisabled() internal view {
259	        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {
260	            revert OnlyWhenEnabledError();
261	        }
262	    }
263	
...
265	    constructor(IGlobals globals) {
266	        _GLOBALS = globals;
267	    }
268	
...
270	    function _initialize(
271	        GovernanceOpts memory govOpts,
272	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
273	        IERC721[] memory preciousTokens,
274	        uint256[] memory preciousTokenIds
275	    ) internal virtual {
276	        // Check BPS are valid.
277	        if (govOpts.feeBps > 1e4) {
278	            revert InvalidBpsError(govOpts.feeBps);
279	        }
280	        if (govOpts.passThresholdBps > 1e4) {
281	            revert InvalidBpsError(govOpts.passThresholdBps);
282	        }
283	        // Initialize the proposal execution engine.
284	        _initProposalImpl(
285	            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),
286	            abi.encode(proposalEngineOpts)
287	        );
288	        // Set the governance parameters.
289	        _getSharedProposalStorage().governanceValues = GovernanceValues({
290	            voteDuration: govOpts.voteDuration,
291	            executionDelay: govOpts.executionDelay,
292	            passThresholdBps: govOpts.passThresholdBps,
293	            totalVotingPower: govOpts.totalVotingPower
294	        });
295	        numHosts = uint8(govOpts.hosts.length);
296	        // Set fees.
297	        feeBps = govOpts.feeBps;
298	        feeRecipient = govOpts.feeRecipient;
299	        // Set the precious list.
300	        _setPreciousList(preciousTokens, preciousTokenIds);
301	        // Set the party hosts.
302	        if (govOpts.hosts.length > type(uint8).max) {
303	            revert TooManyHosts();
304	        }
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
309	
...
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
...
904	    function _getVotingPowerSnapshotAt(
905	        address voter,
906	        uint40 timestamp,
907	        uint256 hintIndex
908	    ) internal view returns (VotingPowerSnapshot memory snap) {
909	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
910	        uint256 snapsLength = snaps.length;
911	        if (snapsLength != 0) {
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
923	            // Hint was wrong, fallback to binary search to find snapshot.
924	            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);
925	            // Check that snapshot was found.
926	            if (hintIndex != type(uint256).max) {
927	                return snaps[hintIndex];
928	            }
929	        }
930	
931	        // No snapshot found.
932	        return snap;
933	    }
934	
...
937	    function _transferVotingPower(address from, address to, uint256 power) internal {
938	        int192 powerI192 = power.safeCastUint256ToInt192();
939	        _adjustVotingPower(from, -powerI192, address(0));
940	        _adjustVotingPower(to, powerI192, address(0));
941	    }
942	
...
944	    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {
945	        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);
946	        address oldDelegate = delegationsByVoter[voter];
947	        // If `oldDelegate` is zero and `voter` never delegated, then have
948	        // `voter` delegate to themself.
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
950	        // If the new `delegate` is zero, use the current (old) delegate.
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
952	
953	        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({
954	            timestamp: uint40(block.timestamp),
955	            delegatedVotingPower: oldSnap.delegatedVotingPower,
956	            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +
957	                votingPower).safeCastInt192ToUint96(),
958	            isDelegated: delegate != voter
959	        });
960	        _insertVotingPowerSnapshot(voter, newSnap);
961	        delegationsByVoter[voter] = delegate;
962	
963	        // This event is emitted even if the delegate did not change.
964	        emit PartyDelegateUpdated(voter, delegate);
965	
966	        // Handle rebalancing delegates.
967	        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);
968	    }
969	
...
972	    function _rebalanceDelegates(
973	        address voter,
974	        address oldDelegate,
975	        address newDelegate,
976	        VotingPowerSnapshot memory oldSnap,
977	        VotingPowerSnapshot memory newSnap
978	    ) private {
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
980	            revert InvalidDelegateError();
981	        }
982	        if (oldDelegate != voter && oldDelegate != newDelegate) {
983	            // Remove past voting power from old delegate.
984	            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(
985	                oldDelegate
986	            );
987	            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({
988	                timestamp: uint40(block.timestamp),
989	                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -
990	                    oldSnap.intrinsicVotingPower,
991	                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,
992	                isDelegated: oldDelegateSnap.isDelegated
993	            });
994	            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);
995	        }
996	        if (newDelegate != voter) {
997	            // Not delegating to self.
998	            // Add new voting power to new delegate.
999	            VotingPowerSnapshot memory newDelegateSnap = _getLastVotingPowerSnapshotForVoter(
1000	                newDelegate
1001	            );
1002	            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +
1003	                newSnap.intrinsicVotingPower;
1004	            if (newDelegate == oldDelegate) {
1005	                // If the old and new delegate are the same, subtract the old
1006	                // intrinsic voting power of the voter, or else we will double
1007	                // count a portion of it.
1008	                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;
1009	            }
1010	            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({
1011	                timestamp: uint40(block.timestamp),
1012	                delegatedVotingPower: newDelegateDelegatedVotingPower,
1013	                intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,
1014	                isDelegated: newDelegateSnap.isDelegated
1015	            });
1016	            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);
1017	        }
1018	    }
1019	
...
1021	    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap) private {
1022	        emit PartyVotingSnapshotCreated(
1023	            voter,
1024	            snap.timestamp,
1025	            snap.delegatedVotingPower,
1026	            snap.intrinsicVotingPower,
1027	            snap.isDelegated
1028	        );
1029	
1030	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1031	        uint256 n = voterSnaps.length;
1032	        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.
1033	        if (n != 0) {
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
1035	            if (lastSnap.timestamp == snap.timestamp) {
1036	                voterSnaps[n - 1] = snap;
1037	                return;
1038	            }
1039	        }
1040	        voterSnaps.push(snap);
1041	    }
1042	
...
1043	    function _getLastVotingPowerSnapshotForVoter(
1044	        address voter
1045	    ) private view returns (VotingPowerSnapshot memory snap) {
1046	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1047	        uint256 n = voterSnaps.length;
1048	        if (n != 0) {
1049	            snap = voterSnaps[n - 1];
1050	        }
1051	    }
1052	
...
1053	    function _getProposalFlags(ProposalStateValues memory pv) private pure returns (uint256) {
1054	        uint256 flags = 0;
1055	        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1056	            flags = flags | LibProposal.PROPOSAL_FLAG_UNANIMOUS;
1057	        }
1058	        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1059	            flags = flags | LibProposal.PROPOSAL_FLAG_HOSTS_ACCEPT;
1060	        }
1061	        return flags;
1062	    }
1063	
...
1064	    function _getProposalStatus(
1065	        ProposalStateValues memory pv
1066	    ) private view returns (ProposalStatus status) {
1067	        // Never proposed.
1068	        if (pv.proposedTime == 0) {
1069	            return ProposalStatus.Invalid;
1070	        }
1071	        // Executed at least once.
1072	        if (pv.executedTime != 0) {
1073	            if (pv.completedTime == 0) {
1074	                return ProposalStatus.InProgress;
1075	            }
1076	            // completedTime high bit will be set if cancelled.
1077	            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {
1078	                return ProposalStatus.Cancelled;
1079	            }
1080	            return ProposalStatus.Complete;
1081	        }
1082	        // Vetoed.
1083	        if (pv.votes == type(uint96).max) {
1084	            return ProposalStatus.Defeated;
1085	        }
1086	        uint40 t = uint40(block.timestamp);
1087	        GovernanceValues memory gv = _getSharedProposalStorage().governanceValues;
1088	        if (pv.passedTime != 0) {
1089	            // Ready.
1090	            if (pv.passedTime + gv.executionDelay <= t) {
1091	                return ProposalStatus.Ready;
1092	            }
1093	            // If unanimous, we skip the execution delay.
1094	            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1095	                return ProposalStatus.Ready;
1096	            }
1097	            // If all hosts voted, skip execution delay
1098	            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1099	                return ProposalStatus.Ready;
1100	            }
1101	            // Passed.
1102	            return ProposalStatus.Passed;
1103	        }
1104	        // Voting window expired.
1105	        if (pv.proposedTime + gv.voteDuration <= t) {
1106	            return ProposalStatus.Defeated;
1107	        }
1108	        return ProposalStatus.Voting;
1109	    }
1110	
...
1111	    function _isUnanimousVotes(
1112	        uint96 totalVotes,
1113	        uint96 totalVotingPower
1114	    ) private pure returns (bool) {
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
1116	        // If >= 99.99% acceptance, consider it unanimous.
1117	        // The minting formula for voting power is a bit lossy, so we check
1118	        // for slightly less than 100%.
1119	        return acceptanceRatio >= 0.9999e4;
1120	    }
1121	
...
1122	    function _hostsAccepted(
1123	        uint8 snapshotNumHosts,
1124	        uint8 numHostsAccepted
1125	    ) private pure returns (bool) {
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
1127	    }
1128	
...
1129	    function _areVotesPassing(
1130	        uint96 voteCount,
1131	        uint96 totalVotingPower,
1132	        uint16 passThresholdBps
1133	    ) private pure returns (bool) {
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
1135	    }
1136	
...
1137	    function _setPreciousList(
1138	        IERC721[] memory preciousTokens,
1139	        uint256[] memory preciousTokenIds
1140	    ) private {
1141	        if (preciousTokens.length != preciousTokenIds.length) {
1142	            revert MismatchedPreciousListLengths();
1143	        }
1144	        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);
1145	    }
1146	
...
1147	    function _isPreciousListCorrect(
1148	        IERC721[] memory preciousTokens,
1149	        uint256[] memory preciousTokenIds
1150	    ) private view returns (bool) {
1151	        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);
1152	    }
1153	
...
1154	    function _hashPreciousList(
1155	        IERC721[] memory preciousTokens,
1156	        uint256[] memory preciousTokenIds
1157	    ) internal pure returns (bytes32 h) {
1158	        assembly {
1159	            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))
1160	            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))
1161	            h := keccak256(0x00, 0x40)
1162	        }
1163	    }
1164	
...
1166	    function _validateProposalHash(Proposal memory proposal, bytes32 expectedHash) private pure {
1167	        bytes32 actualHash = getProposalHash(proposal);
1168	        if (expectedHash != actualHash) {
1169	            revert BadProposalHashError(actualHash, expectedHash);
1170	        }
1171	    }
1172	}
```
[216..221](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L216-L221)
[222..229](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L222-L229)
[258..263](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L258-L263)
[265..268](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L265-L268)
[270..309](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L270-L309)
[860..902](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L860-L902)
[904..934](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L904-L934)
[937..942](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L937-L942)
[944..969](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L944-L969)
[972..1019](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L972-L1019)
[1021..1042](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1021-L1042)
[1043..1052](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1043-L1052)
[1053..1063](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1053-L1063)
[1064..1110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1064-L1110)
[1111..1121](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1111-L1121)
[1122..1128](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1122-L1128)
[1129..1136](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1129-L1136)
[1137..1146](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1137-L1146)
[1147..1153](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1147-L1153)
[1154..1164](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1154-L1164)
[1166..1172](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1166-L1172)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
61	    function _assertAuthority() internal view {
62	        if (!isAuthority[msg.sender]) {
63	            revert NotAuthorized();
64	        }
65	    }
...
76	    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721("", "") {
77	        _GLOBALS = globals;
78	    }
...
81	    function _initialize(
82	        string memory name_,
83	        string memory symbol_,
84	        uint256 customizationPresetId,
85	        PartyGovernance.GovernanceOpts memory governanceOpts,
86	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
87	        IERC721[] memory preciousTokens,
88	        uint256[] memory preciousTokenIds,
89	        address[] memory authorities,
90	        uint40 rageQuitTimestamp_
91	    ) internal {
92	        PartyGovernance._initialize(
93	            governanceOpts,
94	            proposalEngineOpts,
95	            preciousTokens,
96	            preciousTokenIds
97	        );
98	        name = name_;
99	        symbol = symbol_;
100	        rageQuitTimestamp = rageQuitTimestamp_;
101	        unchecked {
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
105	        }
106	        if (customizationPresetId != 0) {
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
109	        }
110	    }
...
268	    function _burnAndUpdateVotingPower(
269	        uint256[] memory tokenIds,
270	        bool checkIfAuthorizedToBurn
271	    ) private returns (uint96 totalVotingPowerBurned) {
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
302	
303	        // Update minted voting power.
304	        mintedVotingPower -= totalVotingPowerBurned;
305	    }
...
493	    function _delegateToRenderer() private view {
494	        _readOnlyDelegateCall(
495	            // Instance of IERC721Renderer.
496	            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),
497	            msg.data
498	        );
499	        assert(false); // Will not be reached.
500	    }
```
[61..65](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L61-L65)
[76..78](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L76-L78)
[81..110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L81-L110)
[268..305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L268-L305)
[493..500](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L493-L500)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
107	    constructor(
108	        IGlobals globals,
109	        IReserveAuctionCoreEth zora,
110	        IFractionalV1VaultFactory fractionalVaultFactory
111	    )
112	        ListOnOpenseaAdvancedProposal(globals)
113	        ListOnZoraProposal(globals, zora)
114	        FractionalizeProposal(fractionalVaultFactory)
115	        ArbitraryCallsProposal(zora)
116	    {
117	        _GLOBALS = globals;
118	    }
119	
...
225	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
226	        IERC1271 validator = getSignatureValidatorForHash(hash);
227	        if (address(validator) == address(1)) {
228	            // Signature set by party to be always valid
229	            return IERC1271.isValidSignature.selector;
230	        }
231	        if (address(validator) != address(0)) {
232	            return validator.isValidSignature(hash, signature);
233	        }
234	        if (tx.origin == address(0)) {
235	            validator = getSignatureValidatorForHash(0);
236	            if (address(validator) == address(0)) {
237	                // Use global off-chain signature validator
238	                validator = IERC1271(
239	                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)
240	                );
241	            }
242	            return validator.isValidSignature(hash, signature);
243	        }
244	        return 0;
245	    }
246	
...
248	    function _execute(
249	        ProposalType pt,
250	        ExecuteProposalParams memory params
251	    ) internal virtual returns (bytes memory nextProgressData) {
252	        if (pt == ProposalType.ListOnOpensea) {
253	            nextProgressData = _executeListOnOpensea(params);
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
293	
...
297	    function _extractProposalType(
298	        bytes memory proposalData
299	    ) private pure returns (ProposalType proposalType, bytes memory offsetProposalData) {
300	        // First 4 bytes is proposal type. While the proposal type could be
301	        // stored in just 1 byte, this makes it easier to encode with
302	        // `abi.encodeWithSelector`.
303	        if (proposalData.length < 4) {
304	            revert MalformedProposalDataError();
305	        }
306	        assembly {
307	            // By reading 4 bytes into the length prefix, the leading 4 bytes
308	            // of the data will be in the lower bits of the read word.
309	            proposalType := and(mload(add(proposalData, 4)), 0xffffffff)
310	            mstore(add(proposalData, 4), sub(mload(proposalData), 4))
311	            offsetProposalData := add(proposalData, 4)
312	        }
313	        require(proposalType != ProposalType.Invalid);
314	        require(uint8(proposalType) <= uint8(type(ProposalType).max));
315	    }
316	
...
318	    function _executeUpgradeProposalsImplementation(bytes memory proposalData) private {
319	        (address expectedImpl, bytes memory initData) = abi.decode(proposalData, (address, bytes));
320	        // Always upgrade to latest implementation stored in `_GLOBALS`.
321	        IProposalExecutionEngine newImpl = IProposalExecutionEngine(
322	            _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)
323	        );
324	        if (expectedImpl != address(newImpl)) {
325	            revert UnexpectedProposalEngineImplementationError(
326	                newImpl,
327	                IProposalExecutionEngine(expectedImpl)
328	            );
329	        }
330	        _initProposalImpl(newImpl, initData);
331	        emit ProposalEngineImplementationUpgraded(address(implementation), expectedImpl);
332	    }
333	
...
335	    function _getStorage() internal pure returns (Storage storage stor) {
336	        uint256 slot = _STORAGE_SLOT;
337	        assembly {
338	            stor.slot := slot
339	        }
340	    }
341	}
```
[107..119](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L107-L119)
[225..246](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L225-L246)
[248..293](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L248-L293)
[297..316](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L297-L316)
[318..333](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L318-L333)
[335..341](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L335-L341)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
43	    function _initProposalImpl(IProposalExecutionEngine impl, bytes memory initData) internal {
44	        SharedProposalStorage storage stor = _getSharedProposalStorage();
45	        IProposalExecutionEngine oldImpl = stor.engineImpl;
46	        stor.engineImpl = impl;
47	        (bool s, bytes memory r) = address(impl).delegatecall(
48	            abi.encodeCall(IProposalExecutionEngine.initialize, (address(oldImpl), initData))
49	        );
50	        if (!s) {
51	            r.rawRevert();
52	        }
53	    }
...
55	    function _getSharedProposalStorage()
56	        internal
57	        pure
58	        returns (SharedProposalStorage storage stor)
59	    {
60	        uint256 s = SHARED_STORAGE_SLOT;
61	        assembly {
62	            stor.slot := s
63	        }
64	    }
```
[43..53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L43-L53)
[55..64](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L55-L64)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
42	    function getSignatureValidatorForHash(bytes32 hash) public view returns (IERC1271) {
43	        return _getSetSignatureValidatorProposalStorage().signatureValidators[hash];
44	    }
```
[42..44](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L42-L44)

---

	 - contracts/utils/Implementation.sol

```solidity
17	    constructor() {
18	        implementation = address(this);
19	    }
```
[17..19](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L17-L19)


</details>

-------
### [N-06] `constants` should be defined rather than using magic numbers
<a name="N-06"></a>
[To the top](#TOP)

Magic numbers are numbers that appear without explanation in the code. They should be replaced with named constants.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 38 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
377	        uint256 authoritiesLength = opts.authorities.length + 1;
...
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
...
382	        authorities[authoritiesLength - 1] = address(this);
```
[377](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L377)
[379](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L379)
[382](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L382)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
...
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
...
270	        votingPower = (amount * exchangeRateBps) / 1e4;
...
281	        amount = (votingPower * 1e4) / exchangeRateBps;
...
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
...
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
...
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
...
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
...
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
```
[266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L266)
[266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L266)
[270](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L270)
[281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L281)
[287](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L287)
[287](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L287)
[325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L325)
[329](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L329)
[355](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L355)

---

	 - contracts/party/PartyGovernance.sol

```solidity
277	        if (govOpts.feeBps > 1e4) {
...
280	        if (govOpts.passThresholdBps > 1e4) {
...
313	        bytes4 functionSelector = bytes4(msg.data[0:4]);
...
338	            interfaceId == 0x49064906;
...
434	            uint256 mid = (low + high) / 2;
...
440	                low = mid + 1;
...
445	        return high == 0 ? type(uint256).max : high - 1;
...
634	        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);
...
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
...
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
...
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
...
1036	                voterSnaps[n - 1] = snap;
...
1049	            snap = voterSnaps[n - 1];
...
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
...
1119	        return acceptanceRatio >= 0.9999e4;
...
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
```
[277](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L277)
[280](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L280)
[313](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L313)
[338](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L338)
[434](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L434)
[440](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L440)
[445](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L445)
[634](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L634)
[918](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L918)
[918](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L918)
[1034](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1034)
[1036](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1036)
[1049](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1049)
[1115](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1115)
[1119](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1119)
[1134](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1134)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
...
311	        uint256[] memory tokenIds = new uint256[](1);
...
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
...
413	                uint256 fee = (amount * feeBps_) / 1e4;
```
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)
[311](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L311)
[393](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L393)
[413](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L413)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
227	        if (address(validator) == address(1)) {
...
303	        if (proposalData.length < 4) {
```
[227](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L227)
[303](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L303)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
33	            if (proposalData.voteDuration < 1 hours) {
...
43	            if (proposalData.executionDelay > 30 days) {
...
54	            if (proposalData.passThresholdBps > 10000) {
```
[33](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L33)
[43](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L43)
[54](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L54)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
60	            10000;
```
[60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L60)


</details>

-------
### [N-07] NatSpec `@return` argument is missing
<a name="N-07"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 37 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
275	    function _contribute(
276	        address payable contributor,
277	        address delegate,
278	        uint96 amount,
279	        uint256 tokenId,
280	        bytes memory gateData
281	    ) private returns (uint96 votingPower) {
282	        // Require a non-null delegate.
283	        if (delegate == address(0)) {
284	            revert InvalidDelegateError();
285	        }
286	
287	        // Must not be blocked by gatekeeper.
288	        IGateKeeper _gateKeeper = gateKeeper;
289	        if (_gateKeeper != IGateKeeper(address(0))) {
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
291	                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);
292	            }
293	        }
294	
295	        votingPower = _processContribution(contributor, delegate, amount);
296	
297	        // OK to contribute with zero just to update delegate.
298	        if (amount == 0) return 0;
299	
300	        if (tokenId == 0) {
301	            // Mint contributor a new party card.
302	            party.mint(contributor, votingPower, delegate);
303	        } else if (disableContributingForExistingCard) {
304	            revert ContributingForExistingCardDisabledError();
305	        } else if (party.ownerOf(tokenId) == contributor) {
306	            // Increase voting power of contributor's existing party card.
307	            party.increaseVotingPower(tokenId, votingPower);
308	        } else {
309	            revert NotOwnerError(tokenId);
310	        }
311	    }
...
372	    function _createParty(
373	        ETHPartyOptions memory opts,
374	        MetadataProvider customMetadataProvider,
375	        bytes memory customMetadata
376	    ) private returns (Party) {
377	        uint256 authoritiesLength = opts.authorities.length + 1;
378	        address[] memory authorities = new address[](authoritiesLength);
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
382	        authorities[authoritiesLength - 1] = address(this);
383	
384	        if (address(customMetadataProvider) == address(0)) {
385	            return
386	                opts.governanceOpts.partyFactory.createParty(
387	                    opts.governanceOpts.partyImpl,
388	                    authorities,
389	                    Party.PartyOptions({
390	                        name: opts.name,
391	                        symbol: opts.symbol,
392	                        customizationPresetId: opts.customizationPresetId,
393	                        governance: PartyGovernance.GovernanceOpts({
394	                            hosts: opts.governanceOpts.hosts,
395	                            voteDuration: opts.governanceOpts.voteDuration,
396	                            executionDelay: opts.governanceOpts.executionDelay,
397	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
398	                            totalVotingPower: 0,
399	                            feeBps: opts.governanceOpts.feeBps,
400	                            feeRecipient: opts.governanceOpts.feeRecipient
401	                        }),
402	                        proposalEngine: opts.proposalEngineOpts
403	                    }),
404	                    opts.preciousTokens,
405	                    opts.preciousTokenIds,
406	                    opts.rageQuitTimestamp
407	                );
408	        } else {
409	            return
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
411	                    opts.governanceOpts.partyImpl,
412	                    authorities,
413	                    Party.PartyOptions({
414	                        name: opts.name,
415	                        symbol: opts.symbol,
416	                        customizationPresetId: opts.customizationPresetId,
417	                        governance: PartyGovernance.GovernanceOpts({
418	                            hosts: opts.governanceOpts.hosts,
419	                            voteDuration: opts.governanceOpts.voteDuration,
420	                            executionDelay: opts.governanceOpts.executionDelay,
421	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
422	                            totalVotingPower: 0,
423	                            feeBps: opts.governanceOpts.feeBps,
424	                            feeRecipient: opts.governanceOpts.feeRecipient
425	                        }),
426	                        proposalEngine: opts.proposalEngineOpts
427	                    }),
428	                    opts.preciousTokens,
429	                    opts.preciousTokenIds,
430	                    opts.rageQuitTimestamp,
431	                    customMetadataProvider,
432	                    customMetadata
433	                );
434	        }
435	    }
```
[275..311](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L275-L311)
[372..435](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L372-L435)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
175	    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {
176	        if (maxTotalContributions == 0) {
177	            return CrowdfundLifecycle.Invalid;
178	        }
179	
180	        uint256 expiry_ = expiry;
181	        if (expiry_ == 0) {
182	            return CrowdfundLifecycle.Finalized;
183	        }
184	
185	        if (block.timestamp >= expiry_) {
186	            if (totalContributions >= minTotalContributions) {
187	                return CrowdfundLifecycle.Won;
188	            } else {
189	                return CrowdfundLifecycle.Lost;
190	            }
191	        }
192	
193	        return CrowdfundLifecycle.Active;
194	    }
195	
...
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
...
339	    function sendFundingSplit() external returns (uint96 splitAmount) {
340	        // Check that the crowdfund is finalized.
341	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
342	        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);
343	
344	        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();
345	
346	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
347	        uint16 fundingSplitBps_ = fundingSplitBps;
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
349	            revert FundingSplitNotConfiguredError();
350	        }
351	
352	        fundingSplitPaid = true;
353	
354	        // Transfer funding split to recipient.
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
356	        payable(fundingSplitRecipient_).transferEth(splitAmount);
357	
358	        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);
359	    }
360	
```
[175..195](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L175-L195)
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)
[339..360](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L339-L360)

---

	 - contracts/party/PartyGovernance.sol

```solidity
342	    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {
343	        return _getSharedProposalStorage().engineImpl;
344	    }
345	
...
347	    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {
348	        return _getSharedProposalStorage().opts;
349	    }
350	
...
553	    function propose(
554	        Proposal memory proposal,
555	        uint256 latestSnapIndex
556	    ) external returns (uint256 proposalId) {
557	        _assertActiveMember();
558	        proposalId = ++lastProposalId;
559	        // Store the time the proposal was created and the proposal hash.
560	        (
561	            _proposalStateByProposalId[proposalId].values,
562	            _proposalStateByProposalId[proposalId].hash
563	        ) = (
564	            ProposalStateValues({
565	                proposedTime: uint40(block.timestamp),
566	                passedTime: 0,
567	                executedTime: 0,
568	                completedTime: 0,
569	                votes: 0,
570	                totalVotingPower: _getSharedProposalStorage().governanceValues.totalVotingPower,
571	                numHosts: numHosts,
572	                numHostsAccepted: 0
573	            }),
574	            getProposalHash(proposal)
575	        );
576	        emit Proposed(proposalId, msg.sender, proposal);
577	        accept(proposalId, latestSnapIndex);
578	
579	        // Notify third-party platforms that the governance NFT metadata has
580	        // updated for all tokens.
581	        emit BatchMetadataUpdate(0, type(uint256).max);
582	    }
583	
...
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
...
904	    function _getVotingPowerSnapshotAt(
905	        address voter,
906	        uint40 timestamp,
907	        uint256 hintIndex
908	    ) internal view returns (VotingPowerSnapshot memory snap) {
909	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
910	        uint256 snapsLength = snaps.length;
911	        if (snapsLength != 0) {
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
923	            // Hint was wrong, fallback to binary search to find snapshot.
924	            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);
925	            // Check that snapshot was found.
926	            if (hintIndex != type(uint256).max) {
927	                return snaps[hintIndex];
928	            }
929	        }
930	
931	        // No snapshot found.
932	        return snap;
933	    }
934	
...
1043	    function _getLastVotingPowerSnapshotForVoter(
1044	        address voter
1045	    ) private view returns (VotingPowerSnapshot memory snap) {
1046	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1047	        uint256 n = voterSnaps.length;
1048	        if (n != 0) {
1049	            snap = voterSnaps[n - 1];
1050	        }
1051	    }
1052	
...
1053	    function _getProposalFlags(ProposalStateValues memory pv) private pure returns (uint256) {
1054	        uint256 flags = 0;
1055	        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1056	            flags = flags | LibProposal.PROPOSAL_FLAG_UNANIMOUS;
1057	        }
1058	        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1059	            flags = flags | LibProposal.PROPOSAL_FLAG_HOSTS_ACCEPT;
1060	        }
1061	        return flags;
1062	    }
1063	
...
1064	    function _getProposalStatus(
1065	        ProposalStateValues memory pv
1066	    ) private view returns (ProposalStatus status) {
1067	        // Never proposed.
1068	        if (pv.proposedTime == 0) {
1069	            return ProposalStatus.Invalid;
1070	        }
1071	        // Executed at least once.
1072	        if (pv.executedTime != 0) {
1073	            if (pv.completedTime == 0) {
1074	                return ProposalStatus.InProgress;
1075	            }
1076	            // completedTime high bit will be set if cancelled.
1077	            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {
1078	                return ProposalStatus.Cancelled;
1079	            }
1080	            return ProposalStatus.Complete;
1081	        }
1082	        // Vetoed.
1083	        if (pv.votes == type(uint96).max) {
1084	            return ProposalStatus.Defeated;
1085	        }
1086	        uint40 t = uint40(block.timestamp);
1087	        GovernanceValues memory gv = _getSharedProposalStorage().governanceValues;
1088	        if (pv.passedTime != 0) {
1089	            // Ready.
1090	            if (pv.passedTime + gv.executionDelay <= t) {
1091	                return ProposalStatus.Ready;
1092	            }
1093	            // If unanimous, we skip the execution delay.
1094	            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1095	                return ProposalStatus.Ready;
1096	            }
1097	            // If all hosts voted, skip execution delay
1098	            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1099	                return ProposalStatus.Ready;
1100	            }
1101	            // Passed.
1102	            return ProposalStatus.Passed;
1103	        }
1104	        // Voting window expired.
1105	        if (pv.proposedTime + gv.voteDuration <= t) {
1106	            return ProposalStatus.Defeated;
1107	        }
1108	        return ProposalStatus.Voting;
1109	    }
1110	
...
1111	    function _isUnanimousVotes(
1112	        uint96 totalVotes,
1113	        uint96 totalVotingPower
1114	    ) private pure returns (bool) {
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
1116	        // If >= 99.99% acceptance, consider it unanimous.
1117	        // The minting formula for voting power is a bit lossy, so we check
1118	        // for slightly less than 100%.
1119	        return acceptanceRatio >= 0.9999e4;
1120	    }
1121	
...
1122	    function _hostsAccepted(
1123	        uint8 snapshotNumHosts,
1124	        uint8 numHostsAccepted
1125	    ) private pure returns (bool) {
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
1127	    }
1128	
...
1129	    function _areVotesPassing(
1130	        uint96 voteCount,
1131	        uint96 totalVotingPower,
1132	        uint16 passThresholdBps
1133	    ) private pure returns (bool) {
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
1135	    }
1136	
...
1147	    function _isPreciousListCorrect(
1148	        IERC721[] memory preciousTokens,
1149	        uint256[] memory preciousTokenIds
1150	    ) private view returns (bool) {
1151	        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);
1152	    }
1153	
...
1154	    function _hashPreciousList(
1155	        IERC721[] memory preciousTokens,
1156	        uint256[] memory preciousTokenIds
1157	    ) internal pure returns (bytes32 h) {
1158	        assembly {
1159	            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))
1160	            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))
1161	            h := keccak256(0x00, 0x40)
1162	        }
1163	    }
1164	
```
[342..345](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L342-L345)
[347..350](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L347-L350)
[553..583](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L553-L583)
[860..902](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L860-L902)
[904..934](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L904-L934)
[1043..1052](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1043-L1052)
[1053..1063](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1053-L1063)
[1064..1110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1064-L1110)
[1111..1121](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1111-L1121)
[1122..1128](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1122-L1128)
[1129..1136](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1129-L1136)
[1147..1153](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1147-L1153)
[1154..1164](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1154-L1164)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
113	    function supportsInterface(
114	        bytes4 interfaceId
115	    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {
116	        return
117	            PartyGovernance.supportsInterface(interfaceId) ||
118	            ERC721.supportsInterface(interfaceId) ||
119	            interfaceId == type(IERC2981).interfaceId;
120	    }
...
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
...
129	    function contractURI() external view returns (string memory) {
130	        _delegateToRenderer();
131	        return ""; // Just to make the compiler happy.
132	    }
...
136	    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {
137	        _delegateToRenderer();
138	        return (address(0), 0); // Just to make the compiler happy.
139	    }
...
166	    function mint(
167	        address owner,
168	        uint256 votingPower,
169	        address delegate
170	    ) external returns (uint256 tokenId) {
171	        _assertAuthority();
172	        uint96 mintedVotingPower_ = mintedVotingPower;
173	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
174	
175	        // Cap voting power to remaining unminted voting power supply.
176	        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();
177	        // Allow minting past total voting power if minting party cards for
178	        // initial crowdfund when there is no total voting power.
179	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {
180	            unchecked {
181	                votingPower_ = totalVotingPower - mintedVotingPower_;
182	            }
183	        }
184	
185	        // Update state.
186	        unchecked {
187	            tokenId = ++tokenCount;
188	        }
189	        mintedVotingPower += votingPower_;
190	        votingPowerByTokenId[tokenId] = votingPower_;
191	
192	        emit PartyCardIntrinsicVotingPowerSet(tokenId, votingPower_);
193	
194	        // Use delegate from party over the one set during crowdfund.
195	        address delegate_ = delegationsByVoter[owner];
196	        if (delegate_ != address(0)) {
197	            delegate = delegate_;
198	        }
199	
200	        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);
201	        _safeMint(owner, tokenId);
202	    }
...
268	    function _burnAndUpdateVotingPower(
269	        uint256[] memory tokenIds,
270	        bool checkIfAuthorizedToBurn
271	    ) private returns (uint96 totalVotingPowerBurned) {
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
302	
303	        // Update minted voting power.
304	        mintedVotingPower -= totalVotingPowerBurned;
305	    }
```
[113..120](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L113-L120)
[123..126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L123-L126)
[129..132](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L129-L132)
[136..139](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L136-L139)
[166..202](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L166-L202)
[268..305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L268-L305)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
141	    function getCurrentInProgressProposalId() external view returns (uint256 id) {
142	        return _getStorage().currentInProgressProposalId;
143	    }
144	
...
146	    function executeProposal(
147	        ExecuteProposalParams memory params
148	    ) external onlyDelegateCall returns (bytes memory nextProgressData) {
149	        // Must have a valid proposal ID.
150	        if (params.proposalId == 0) {
151	            revert ZeroProposalIdError();
152	        }
153	        Storage storage stor = _getStorage();
154	        uint256 currentInProgressProposalId = stor.currentInProgressProposalId;
155	        if (currentInProgressProposalId == 0) {
156	            // No proposal is currently in progress.
157	            // Mark this proposal as the one in progress.
158	            stor.currentInProgressProposalId = params.proposalId;
159	        } else if (currentInProgressProposalId != params.proposalId) {
160	            // Only one proposal can be in progress at a time.
161	            revert ProposalExecutionBlockedError(params.proposalId, currentInProgressProposalId);
162	        }
163	        {
164	            bytes32 nextProgressDataHash = stor.nextProgressDataHash;
165	            if (nextProgressDataHash == 0) {
166	                // Expecting no progress data.
167	                // This is the state if there is no current `InProgress` proposal.
168	                assert(currentInProgressProposalId == 0);
169	                if (params.progressData.length != 0) {
170	                    revert ProposalProgressDataInvalidError(
171	                        keccak256(params.progressData),
172	                        nextProgressDataHash
173	                    );
174	                }
175	            } else {
176	                // Expecting progress data.
177	                bytes32 progressDataHash = keccak256(params.progressData);
178	                // Progress data must match the one stored.
179	                if (nextProgressDataHash != progressDataHash) {
180	                    revert ProposalProgressDataInvalidError(progressDataHash, nextProgressDataHash);
181	                }
182	            }
183	            // Temporarily set the expected next progress data hash to an
184	            // unachievable constant to act as a reentrancy guard.
185	            stor.nextProgressDataHash = bytes32(type(uint256).max);
186	        }
187	
188	        // Note that we do not enforce that the proposal has not been executed
189	        // (and completed) before in this contract. That is enforced by PartyGovernance.
190	
191	        // Execute the proposal.
192	        ProposalType pt;
193	        (pt, params.proposalData) = _extractProposalType(params.proposalData);
194	        nextProgressData = _execute(pt, params);
195	
196	        // If progress data is empty, the proposal is complete.
197	        if (nextProgressData.length == 0) {
198	            stor.currentInProgressProposalId = 0;
199	            stor.nextProgressDataHash = 0;
200	        } else {
201	            // Remember the next progress data.
202	            stor.nextProgressDataHash = keccak256(nextProgressData);
203	        }
204	    }
205	
...
225	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
226	        IERC1271 validator = getSignatureValidatorForHash(hash);
227	        if (address(validator) == address(1)) {
228	            // Signature set by party to be always valid
229	            return IERC1271.isValidSignature.selector;
230	        }
231	        if (address(validator) != address(0)) {
232	            return validator.isValidSignature(hash, signature);
233	        }
234	        if (tx.origin == address(0)) {
235	            validator = getSignatureValidatorForHash(0);
236	            if (address(validator) == address(0)) {
237	                // Use global off-chain signature validator
238	                validator = IERC1271(
239	                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)
240	                );
241	            }
242	            return validator.isValidSignature(hash, signature);
243	        }
244	        return 0;
245	    }
246	
...
248	    function _execute(
249	        ProposalType pt,
250	        ExecuteProposalParams memory params
251	    ) internal virtual returns (bytes memory nextProgressData) {
252	        if (pt == ProposalType.ListOnOpensea) {
253	            nextProgressData = _executeListOnOpensea(params);
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
293	
...
297	    function _extractProposalType(
298	        bytes memory proposalData
299	    ) private pure returns (ProposalType proposalType, bytes memory offsetProposalData) {
300	        // First 4 bytes is proposal type. While the proposal type could be
301	        // stored in just 1 byte, this makes it easier to encode with
302	        // `abi.encodeWithSelector`.
303	        if (proposalData.length < 4) {
304	            revert MalformedProposalDataError();
305	        }
306	        assembly {
307	            // By reading 4 bytes into the length prefix, the leading 4 bytes
308	            // of the data will be in the lower bits of the read word.
309	            proposalType := and(mload(add(proposalData, 4)), 0xffffffff)
310	            mstore(add(proposalData, 4), sub(mload(proposalData), 4))
311	            offsetProposalData := add(proposalData, 4)
312	        }
313	        require(proposalType != ProposalType.Invalid);
314	        require(uint8(proposalType) <= uint8(type(ProposalType).max));
315	    }
316	
...
335	    function _getStorage() internal pure returns (Storage storage stor) {
336	        uint256 slot = _STORAGE_SLOT;
337	        assembly {
338	            stor.slot := slot
339	        }
340	    }
341	}
```
[141..144](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L141-L144)
[146..205](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L146-L205)
[225..246](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L225-L246)
[248..293](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L248-L293)
[297..316](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L297-L316)
[335..341](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L335-L341)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
55	    function _getSharedProposalStorage()
56	        internal
57	        pure
58	        returns (SharedProposalStorage storage stor)
59	    {
60	        uint256 s = SHARED_STORAGE_SLOT;
61	        assembly {
62	            stor.slot := s
63	        }
64	    }
```
[55..64](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L55-L64)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
25	    function _executeSetGovernanceParameter(
26	        IProposalExecutionEngine.ExecuteProposalParams memory params
27	    ) internal returns (bytes memory) {
28	        SetGovernanceParameterProposalData memory proposalData = abi.decode(
29	            params.proposalData,
30	            (SetGovernanceParameterProposalData)
31	        );
32	        if (proposalData.voteDuration != 0) {
33	            if (proposalData.voteDuration < 1 hours) {
34	                revert InvalidGovernanceParameter(proposalData.voteDuration);
35	            }
36	            emit VoteDurationSet(
37	                _getSharedProposalStorage().governanceValues.voteDuration,
38	                proposalData.voteDuration
39	            );
40	            _getSharedProposalStorage().governanceValues.voteDuration = proposalData.voteDuration;
41	        }
42	        if (proposalData.executionDelay != 0) {
43	            if (proposalData.executionDelay > 30 days) {
44	                revert InvalidGovernanceParameter(proposalData.executionDelay);
45	            }
46	            emit ExecutionDelaySet(
47	                _getSharedProposalStorage().governanceValues.executionDelay,
48	                proposalData.executionDelay
49	            );
50	            _getSharedProposalStorage().governanceValues.executionDelay = proposalData
51	                .executionDelay;
52	        }
53	        if (proposalData.passThresholdBps != 0) {
54	            if (proposalData.passThresholdBps > 10000) {
55	                revert InvalidGovernanceParameter(proposalData.passThresholdBps);
56	            }
57	            emit PassThresholdBpsSet(
58	                _getSharedProposalStorage().governanceValues.passThresholdBps,
59	                proposalData.passThresholdBps
60	            );
61	            _getSharedProposalStorage().governanceValues.passThresholdBps = proposalData
62	                .passThresholdBps;
63	        }
64	
65	        return "";
66	    }
```
[25..66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L25-L66)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
28	    function _executeSetSignatureValidator(
29	        IProposalExecutionEngine.ExecuteProposalParams memory params
30	    ) internal returns (bytes memory nextProgressData) {
31	        SetSignatureValidatorProposalData memory data = abi.decode(
32	            params.proposalData,
33	            (SetSignatureValidatorProposalData)
34	        );
35	        _getSetSignatureValidatorProposalStorage().signatureValidators[data.signatureHash] = data
36	            .signatureValidator;
37	        nextProgressData = "";
38	
39	        emit SignatureValidatorSet(data.signatureHash, data.signatureValidator);
40	    }
...
42	    function getSignatureValidatorForHash(bytes32 hash) public view returns (IERC1271) {
43	        return _getSetSignatureValidatorProposalStorage().signatureValidators[hash];
44	    }
...
47	    function _getSetSignatureValidatorProposalStorage()
48	        private
49	        pure
50	        returns (SetSignatureValidatorProposalStorage storage stor)
51	    {
52	        uint256 slot = _SET_SIGNATURE_VALIDATOR_PROPOSAL_STORAGE_SLOT;
53	        assembly {
54	            stor.slot := slot
55	        }
56	    }
```
[28..40](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L28-L40)
[42..44](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L42-L44)
[47..56](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L47-L56)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
28	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
29	        uint8 v;
30	        bytes32 r;
31	        bytes32 s;
32	        assembly {
33	            // First word of signature after size contains r
34	            r := mload(add(signature, 0x20))
35	            s := mload(add(signature, 0x40))
36	            // v is one byte which starts after s. type is uint8 so extra data will be ignored
37	            v := mload(add(signature, 0x41))
38	        }
39	
40	        bytes memory message;
41	        assembly {
42	            // Raw message data begins after v. Overwriting part of s and v with size of `message`
43	            message := add(signature, 0x41)
44	            mstore(message, sub(mload(signature), 0x41))
45	        }
46	
47	        // Recreate the message pre-hash from the raw data
48	        bytes memory encodedPacket = abi.encodePacked(
49	            "\x19Ethereum Signed Message:\n",
50	            Strings.toString(message.length),
51	            message
52	        );
53	        if (keccak256(encodedPacket) != hash) {
54	            revert MessageHashMismatch();
55	        }
56	
57	        Party party = Party(payable(msg.sender));
58	        address signer = ecrecover(hash, v, r, s);
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
60	            10000;
61	
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
63	            // Must own a party card or be delegatated voting power
64	            revert NotMemberOfParty();
65	        }
66	
67	        uint96 totalVotingPower = party.getGovernanceValues().totalVotingPower;
68	        uint96 thresholdBps = signingThersholdBps[party];
69	
70	        // Either threshold is 0 or signer votes above threshold
71	        if (
72	            thresholdBps == 0 ||
73	            (signerVotingPowerBps > totalVotingPower &&
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
75	        ) {
76	            return IERC1271.isValidSignature.selector;
77	        }
78	
79	        revert InsufficientVotingPower();
80	    }
```
[28..80](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L28-L80)

---

	 - contracts/utils/Implementation.sol

```solidity
40	    function IMPL() external view returns (address) {
41	        return implementation;
42	    }
```
[40..42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L40-L42)


</details>

-------
### [N-08] Variable names don't follow the Solidity naming convention
<a name="N-08"></a>
[To the top](#TOP)

Use `mixedCase` for local and state variables that are not constants, and add a trailing underscore for internal variables. [Documentation](https://docs.soliditylang.org/en/latest/style-guide.html#local-and-state-variable-names)

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 30 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
115	        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);
...
288	        IGateKeeper _gateKeeper = gateKeeper;
```
[115](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L115)
[288](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L288)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
88	    IGlobals private immutable _GLOBALS;
...
180	        uint256 expiry_ = expiry;
...
222	        uint96 maxContribution_ = maxContribution;
...
228	        uint96 maxTotalContributions_ = maxTotalContributions;
...
255	        uint96 minContribution_ = minContribution;
...
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
262	        uint16 fundingSplitBps_ = fundingSplitBps;
...
284	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
285	        uint16 fundingSplitBps_ = fundingSplitBps;
...
292	        uint96 totalContributions_ = totalContributions;
...
301	            uint96 minTotalContributions_ = minTotalContributions;
...
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
323	        uint16 fundingSplitBps_ = fundingSplitBps;
...
346	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
347	        uint16 fundingSplitBps_ = fundingSplitBps;
```
[88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L88)
[180](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L180)
[222](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L222)
[228](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L228)
[255](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L255)
[261](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L261)
[262](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L262)
[284](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L284)
[285](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L285)
[292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L292)
[301](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L301)
[322](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L322)
[323](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L323)
[346](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L346)
[347](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L347)

---

	 - contracts/party/PartyGovernance.sol

```solidity
191	    IGlobals private immutable _GLOBALS;
...
212	    mapping(uint256 => ProposalState) private _proposalStateByProposalId;
...
214	    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;
...
522	        address payable feeRecipient_ = feeRecipient;
...
523	        uint16 feeBps_ = feeBps;
```
[191](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L191)
[212](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L212)
[214](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L214)
[522](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L522)
[523](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L523)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
42	    IGlobals private immutable _GLOBALS;
...
172	        uint96 mintedVotingPower_ = mintedVotingPower;
...
176	        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();
...
195	        address delegate_ = delegationsByVoter[owner];
...
210	        uint96 mintedVotingPower_ = mintedVotingPower;
...
353	        bool isAuthority_ = isAuthority[msg.sender];
...
407	            uint16 feeBps_ = feeBps;
```
[42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L42)
[172](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L172)
[176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L176)
[195](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L195)
[210](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L210)
[353](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L353)
[407](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L407)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
101	    IGlobals private immutable _GLOBALS;
```
[101](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L101)


</details>

-------
### [N-09] Custom `error` without details
<a name="N-09"></a>
[To the top](#TOP)

Consider adding some parameters to the error to indicate which user or values caused the failure.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 29 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
57	    error OnlyPartyHostError();
...
61	    error OnlyWhenEmergencyActionsAllowedError();
...
62	    error InvalidDelegateError();
...
69	    error ContributingForExistingCardDisabledError();
...
70	    error ZeroVotingPowerError();
...
71	    error FundingSplitAlreadyPaidError();
...
72	    error FundingSplitNotConfiguredError();
...
73	    error InvalidMessageValue();
```
[57](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L57)
[61](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L61)
[62](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L62)
[69](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L69)
[70](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L70)
[71](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L71)
[72](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L72)
[73](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L73)

---

	 - contracts/party/PartyGovernance.sol

```solidity
168	    error MismatchedPreciousListLengths();
...
172	    error NotAuthorized();
...
173	    error InvalidDelegateError();
...
174	    error BadPreciousListError();
...
175	    error OnlyWhenEmergencyActionsAllowedError();
...
176	    error OnlyWhenEnabledError();
...
178	    error InvalidNewHostError();
...
181	    error DistributionsRequireVoteError();
...
182	    error PartyNotStartedError();
...
183	    error CannotRageQuitAndAcceptError();
...
184	    error TooManyHosts();
```
[168](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L168)
[172](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L172)
[173](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L173)
[174](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L174)
[175](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L175)
[176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L176)
[178](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L178)
[181](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L181)
[182](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L182)
[183](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L183)
[184](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L184)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
22	    error CannotDisableRageQuitAfterInitializationError();
...
23	    error InvalidTokenOrderError();
...
25	    error NothingToBurnError();
```
[22](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L22)
[23](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L23)
[25](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L25)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
86	    error ZeroProposalIdError();
...
87	    error MalformedProposalDataError();
```
[86](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L86)
[87](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L87)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
10	    error NotMemberOfParty();
...
11	    error InsufficientVotingPower();
...
12	    error MessageHashMismatch();
```
[10](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L10)
[11](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L11)
[12](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L12)

---

	 - contracts/utils/Implementation.sol

```solidity
8	    error AlreadyInitialized();
...
9	    error OnlyDelegateCallError();
```
[8](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L8)
[9](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L9)


</details>

-------
### [N-10] `Import` only specific files
<a name="N-10"></a>
[To the top](#TOP)

Using import declarations of the form `import {<identifier_name>} from "some/file.sol"` avoids polluting the symbol namespace making flattened files smaller, and speeds up compilation

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 27 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
4	import "../utils/LibAddress.sol";
...
5	import "../utils/LibSafeCast.sol";
...
6	import "../party/Party.sol";
...
7	import "../gatekeepers/IGateKeeper.sol";
```
[4](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L4)
[5](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L5)
[6](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L6)
[7](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L7)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
4	import "../utils/LibSafeCast.sol";
...
5	import "../utils/LibAddress.sol";
...
6	import "openzeppelin/contracts/interfaces/IERC2981.sol";
...
7	import "../globals/IGlobals.sol";
...
8	import "../tokens/IERC721.sol";
...
9	import "../vendor/solmate/ERC721.sol";
...
10	import "./PartyGovernance.sol";
...
11	import "../renderers/RendererStorage.sol";
```
[4](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L4)
[5](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L5)
[6](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L6)
[7](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L7)
[8](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L8)
[9](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L9)
[10](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L10)
[11](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L11)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
4	import "../utils/Implementation.sol";
...
5	import "../utils/LibRawResult.sol";
...
6	import "../globals/IGlobals.sol";
...
9	import "./IProposalExecutionEngine.sol";
...
10	import "./ListOnOpenseaProposal.sol";
...
11	import "./ListOnOpenseaAdvancedProposal.sol";
...
12	import "./ListOnZoraProposal.sol";
...
13	import "./FractionalizeProposal.sol";
...
14	import "./ArbitraryCallsProposal.sol";
...
15	import "./ProposalStorage.sol";
...
16	import "./DistributeProposal.sol";
...
17	import "./AddAuthorityProposal.sol";
...
18	import "./OperatorProposal.sol";
```
[4](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L4)
[5](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L5)
[6](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L6)
[9](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L9)
[10](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L10)
[11](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L11)
[12](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L12)
[13](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L13)
[14](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L14)
[15](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L15)
[16](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L16)
[17](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L17)
[18](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L18)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
4	import "./IProposalExecutionEngine.sol";
...
5	import "../utils/LibRawResult.sol";
```
[4](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L4)
[5](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L5)


</details>

-------
### [N-11] Do not use underscore at the end of variable name
<a name="N-11"></a>
[To the top](#TOP)

The use of underscore at the end of the variable name is uncommon and also suggests that the variable name was not completely changed.

Consider refactoring variableName_ to variableName.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 27 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
115	        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);
```
[115](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L115)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
180	        uint256 expiry_ = expiry;
...
222	        uint96 maxContribution_ = maxContribution;
...
228	        uint96 maxTotalContributions_ = maxTotalContributions;
...
255	        uint96 minContribution_ = minContribution;
...
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
262	        uint16 fundingSplitBps_ = fundingSplitBps;
...
284	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
285	        uint16 fundingSplitBps_ = fundingSplitBps;
...
292	        uint96 totalContributions_ = totalContributions;
...
301	            uint96 minTotalContributions_ = minTotalContributions;
...
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
323	        uint16 fundingSplitBps_ = fundingSplitBps;
...
317	    function _finalize(uint96 totalContributions_) internal {
...
346	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
347	        uint16 fundingSplitBps_ = fundingSplitBps;
```
[180](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L180)
[222](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L222)
[228](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L228)
[255](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L255)
[261](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L261)
[262](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L262)
[284](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L284)
[285](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L285)
[292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L292)
[301](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L301)
[322](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L322)
[323](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L323)
[317](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L317)
[346](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L346)
[347](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L347)

---

	 - contracts/party/PartyGovernance.sol

```solidity
522	        address payable feeRecipient_ = feeRecipient;
...
523	        uint16 feeBps_ = feeBps;
```
[522](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L522)
[523](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L523)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
82	        string memory name_,
...
83	        string memory symbol_,
...
90	        uint40 rageQuitTimestamp_
...
172	        uint96 mintedVotingPower_ = mintedVotingPower;
...
176	        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();
...
195	        address delegate_ = delegationsByVoter[owner];
...
210	        uint96 mintedVotingPower_ = mintedVotingPower;
...
353	        bool isAuthority_ = isAuthority[msg.sender];
...
407	            uint16 feeBps_ = feeBps;
```
[82](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L82)
[83](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L83)
[90](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L90)
[172](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L172)
[176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L176)
[195](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L195)
[210](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L210)
[353](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L353)
[407](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L407)


</details>

-------
### [N-12] Event declarations should have NatSpec descriptions
<a name="N-12"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 26 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
96	    event Refunded(address indexed contributor, uint256 indexed tokenId, uint256 amount);
```
[96](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L96)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
75	    event Contributed(
76	        address indexed sender,
77	        address indexed contributor,
78	        uint256 amount,
79	        address delegate
80	    );
...
81	    event Finalized();
...
82	    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);
...
83	    event EmergencyExecuteDisabled();
...
84	    event EmergencyExecute(address target, bytes data, uint256 amountEth);
```
[75..80](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L75-L80)
[81](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L81)
[82](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L82)
[83](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L83)
[84](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L84)

---

	 - contracts/party/PartyGovernance.sol

```solidity
144	    event Proposed(uint256 proposalId, address proposer, Proposal proposal);
...
145	    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);
...
146	    event EmergencyExecute(address target, bytes data, uint256 amountEth);
...
148	    event ProposalPassed(uint256 indexed proposalId);
...
149	    event ProposalVetoed(uint256 indexed proposalId, address host);
...
150	    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);
...
151	    event ProposalCancelled(uint256 indexed proposalId);
...
152	    event DistributionCreated(
153	        ITokenDistributor.TokenType tokenType,
154	        address token,
155	        uint256 tokenId
156	    );
...
157	    event PartyDelegateUpdated(address indexed owner, address indexed delegate);
...
158	    event HostStatusTransferred(address oldHost, address newHost);
...
159	    event EmergencyExecuteDisabled();
...
160	    event PartyVotingSnapshotCreated(
161	        address indexed voter,
162	        uint40 timestamp,
163	        uint96 delegatedVotingPower,
164	        uint96 intrinsicVotingPower,
165	        bool isDelegated
166	    );
```
[144](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L144)
[145](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L145)
[146](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L146)
[148](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L148)
[149](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L149)
[150](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L150)
[151](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L151)
[152..156](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L152-L156)
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L157)
[158](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L158)
[159](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L159)
[160..166](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L160-L166)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
27	    event AuthorityAdded(address indexed authority);
...
28	    event AuthorityRemoved(address indexed authority);
...
29	    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);
...
30	    event Burn(address caller, uint256 tokenId, uint256 votingPower);
...
31	    event RageQuit(address caller, uint256[] tokenIds, IERC20[] withdrawTokens, address receiver);
...
32	    event PartyCardIntrinsicVotingPowerSet(uint256 indexed tokenId, uint256 intrinsicVotingPower);
```
[27](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L27)
[28](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L28)
[29](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L29)
[30](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L30)
[31](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L31)
[32](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L32)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
83	    event ProposalEngineImplementationUpgraded(address oldImpl, address newImpl);
```
[83](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L83)

---

	 - contracts/utils/Implementation.sol

```solidity
6	    event Initialized();
```
[6](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L6)


</details>

-------
### [N-13] Event is missing `indexed` field
<a name="N-13"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 21 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
96	    event Refunded(address indexed contributor, uint256 indexed tokenId, uint256 amount);
```
[96](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L96)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
75	    event Contributed(
76	        address indexed sender,
77	        address indexed contributor,
78	        uint256 amount,
79	        address delegate
80	    );
...
82	    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);
...
84	    event EmergencyExecute(address target, bytes data, uint256 amountEth);
```
[75..80](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L75-L80)
[82](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L82)
[84](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L84)

---

	 - contracts/party/PartyGovernance.sol

```solidity
144	    event Proposed(uint256 proposalId, address proposer, Proposal proposal);
...
145	    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);
...
146	    event EmergencyExecute(address target, bytes data, uint256 amountEth);
...
149	    event ProposalVetoed(uint256 indexed proposalId, address host);
...
150	    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);
...
152	    event DistributionCreated(
153	        ITokenDistributor.TokenType tokenType,
154	        address token,
155	        uint256 tokenId
156	    );
...
158	    event HostStatusTransferred(address oldHost, address newHost);
...
160	    event PartyVotingSnapshotCreated(
161	        address indexed voter,
162	        uint40 timestamp,
163	        uint96 delegatedVotingPower,
164	        uint96 intrinsicVotingPower,
165	        bool isDelegated
166	    );
```
[144](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L144)
[145](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L145)
[146](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L146)
[149](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L149)
[150](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L150)
[152..156](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L152-L156)
[158](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L158)
[160..166](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L160-L166)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
29	    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);
...
30	    event Burn(address caller, uint256 tokenId, uint256 votingPower);
...
31	    event RageQuit(address caller, uint256[] tokenIds, IERC20[] withdrawTokens, address receiver);
...
32	    event PartyCardIntrinsicVotingPowerSet(uint256 indexed tokenId, uint256 intrinsicVotingPower);
```
[29](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L29)
[30](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L30)
[31](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L31)
[32](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L32)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
83	    event ProposalEngineImplementationUpgraded(address oldImpl, address newImpl);
```
[83](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L83)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
11	    event VoteDurationSet(uint256 oldValue, uint256 newValue);
...
13	    event ExecutionDelaySet(uint256 oldValue, uint256 newValue);
...
15	    event PassThresholdBpsSet(uint256 oldValue, uint256 newValue);
```
[11](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L11)
[13](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L13)
[15](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L15)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
15	    event SigningThresholdBpsSet(
16	        Party indexed party,
17	        uint96 oldThresholdBps,
18	        uint96 newThresholdBps
19	    );
```
[15..19](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L15-L19)


</details>

-------
### [N-14] Duplicated `require/if` statements should be refactored
<a name="N-14"></a>
[To the top](#TOP)

These statements should be refactored to a separate function, as there are multiple parts of the codebase that use the same logic, to improve the code readability and reduce code duplication.



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 20 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
```
[263](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263)
[286](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286)
[324](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324)

---

	 - contracts/party/PartyGovernance.sol

```solidity
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
607	                status != ProposalStatus.Voting &&
608	                status != ProposalStatus.Passed &&
609	                status != ProposalStatus.Ready
610	            ) {
...
675	                status != ProposalStatus.Voting &&
676	                status != ProposalStatus.Passed &&
677	                status != ProposalStatus.Ready
678	            ) {
...
826	            if (!success) {
...
847	        if (!success) {
...
889	            if (!success) {
...
1033	        if (n != 0) {
...
1048	        if (n != 0) {
...
1055	        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
...
1058	        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
...
1094	            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
...
1098	            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
```
[225](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L225)
[505](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L505)
[607..610](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L607-L610)
[675..678](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L675-L678)
[826](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L826)
[847](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L847)
[889](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L889)
[1033](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1033)
[1048](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1048)
[1055](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1055)
[1058](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1058)
[1094](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1094)
[1098](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1098)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
419	                    if (address(token) == ETH_ADDRESS) {
...
435	                    if (address(token) == ETH_ADDRESS) {
```
[419](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L419)
[435](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L435)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
236	            if (address(validator) == address(0)) {
...
227	        if (address(validator) == address(1)) {
```
[236](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L236)
[227](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L227)


</details>

-------
### [N-15] Use SafeCast to safely downcast variables
<a name="N-15"></a>
[To the top](#TOP)

Downcasting int/uints in Solidity can be unsafe due to the potential for data loss and unintended behavior. When downcasting a larger integer type to a smaller one (e.g., `uint256` to `uint128`), the value may exceed the range of the target type, leading to truncation and loss of significant digits. This data loss can result in unexpected state changes, incorrect calculations, or other contract vulnerabilities, ultimately compromising the contracts functionality and reliability. To prevent these risks, developers should carefully consider the range of values their variables may hold and ensure that proper checks are in place to prevent out-of-range values before performing downcasting. Also consider using OZ SafeCast functionality.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 19 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
163	        expiry = uint40(block.timestamp + opts.duration);
```
[163](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L163)

---

	 - contracts/party/PartyGovernance.sol

```solidity
295	        numHosts = uint8(govOpts.hosts.length);
...
565	                proposedTime: uint40(block.timestamp),
...
651	            info.values.passedTime = uint40(block.timestamp);
...
734	                    uint40(block.timestamp)
735	                );
...
737	            proposalState.values.executedTime = uint40(block.timestamp);
...
745	        proposalState.values.completedTime = uint40(block.timestamp);
...
813	                    uint40(block.timestamp),
...
814	                    uint40(cancelTime)
815	                );
...
820	        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);
...
954	            timestamp: uint40(block.timestamp),
...
988	                timestamp: uint40(block.timestamp),
...
1011	                timestamp: uint40(block.timestamp),
...
1086	        uint40 t = uint40(block.timestamp);
```
[295](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L295)
[565](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L565)
[651](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L651)
[734..735](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L734-L735)
[737](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L737)
[745](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L745)
[813](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L813)
[814..815](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L814-L815)
[820](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L820)
[954](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L954)
[988](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L988)
[1011](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1011)
[1086](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1086)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
372	        lastRageQuitTimestamp = uint40(block.timestamp);
```
[372](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L372)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
290	            revert UnsupportedProposalTypeError(uint32(pt));
...
314	        require(uint8(proposalType) <= uint8(type(ProposalType).max));
...
314	        require(uint8(proposalType) <= uint8(type(ProposalType).max));
```
[290](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L290)
[314](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L314)
[314](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L314)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
```
[59](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L59)


</details>

-------
### [N-16] Use multiple `require()` and `if` statements instead of `&&`
<a name="N-16"></a>
[To the top](#TOP)

Using multiple `require()` and `if` improves code readability and makes it easier to debug.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 18 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
288	        }
289	    }
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
326	        }
327	
...
390	        if (
391	            !party.isHost(msg.sender) &&
392	            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender
393	        ) {
394	            revert OnlyPartyDaoOrHostError(msg.sender);
395	        }
396	        emergencyExecuteDisabled = true;
```
[263..268](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263-L268)
[286..289](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286-L289)
[324..327](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324-L327)
[390..396](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L390-L396)

---

	 - contracts/party/PartyGovernance.sol

```solidity
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
226	            revert NotAuthorized();
227	        }
228	    }
...
244	        if (msg.sender != partyDao && !isHost[msg.sender]) {
245	            revert NotAuthorized();
246	        }
247	        _;
...
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
...
606	            if (
607	                status != ProposalStatus.Voting &&
608	                status != ProposalStatus.Passed &&
609	                status != ProposalStatus.Ready
610	            ) {
611	                revert BadProposalStatusError(status);
612	            }
613	        }
...
643	        if (
644	            values.passedTime == 0 &&
645	            _areVotesPassing(
646	                values.votes,
647	                values.totalVotingPower,
648	                _getSharedProposalStorage().governanceValues.passThresholdBps
649	            )
650	        ) {
651	            info.values.passedTime = uint40(block.timestamp);
652	            emit ProposalPassed(proposalId);
653	            // Notify third-party platforms that the governance NFT metadata has
654	            // updated for all tokens.
655	            emit BatchMetadataUpdate(0, type(uint256).max);
656	        }
657	        return values.votes;
...
674	            if (
675	                status != ProposalStatus.Voting &&
676	                status != ProposalStatus.Passed &&
677	                status != ProposalStatus.Ready
678	            ) {
679	                revert BadProposalStatusError(status);
680	            }
681	        }
...
724	        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {
725	            revert BadProposalStatusError(status);
726	        }
727	        if (status == ProposalStatus.Ready) {
...
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
...
982	        if (oldDelegate != voter && oldDelegate != newDelegate) {
983	            // Remove past voting power from old delegate.
984	            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(
985	                oldDelegate
986	            );
987	            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({
988	                timestamp: uint40(block.timestamp),
989	                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -
990	                    oldSnap.intrinsicVotingPower,
991	                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,
992	                isDelegated: oldDelegateSnap.isDelegated
993	            });
994	            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);
995	        }
996	        if (newDelegate != voter) {
```
[225..228](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L225-L228)
[244..247](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L244-L247)
[505..508](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L505-L508)
[606..613](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L606-L613)
[643..657](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L643-L657)
[674..681](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L674-L681)
[724..727](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L724-L727)
[912..922](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L912-L922)
[982..996](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L982-L996)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
179	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {
180	            unchecked {
181	                votingPower_ = totalVotingPower - mintedVotingPower_;
182	            }
183	        }
...
216	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {
217	            unchecked {
218	                votingPower = totalVotingPower - mintedVotingPower_;
219	            }
220	        }
...
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
```
[179..183](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L179-L183)
[216..220](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L216-L220)
[278..284](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L278-L284)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
63	            // Must own a party card or be delegatated voting power
64	            revert NotMemberOfParty();
65	        }
...
71	        if (
72	            thresholdBps == 0 ||
73	            (signerVotingPowerBps > totalVotingPower &&
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
75	        ) {
76	            return IERC1271.isValidSignature.selector;
77	        }
```
[62..65](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L62-L65)
[71..77](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L71-L77)


</details>

-------
### [N-17] Function state mutability can be restricted to pure
<a name="N-17"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 16 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
372	    function _createParty(
373	        ETHPartyOptions memory opts,
374	        MetadataProvider customMetadataProvider,
375	        bytes memory customMetadata
376	    ) private returns (Party) {
377	        uint256 authoritiesLength = opts.authorities.length + 1;
378	        address[] memory authorities = new address[](authoritiesLength);
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
382	        authorities[authoritiesLength - 1] = address(this);
383	
384	        if (address(customMetadataProvider) == address(0)) {
385	            return
386	                opts.governanceOpts.partyFactory.createParty(
387	                    opts.governanceOpts.partyImpl,
388	                    authorities,
389	                    Party.PartyOptions({
390	                        name: opts.name,
391	                        symbol: opts.symbol,
392	                        customizationPresetId: opts.customizationPresetId,
393	                        governance: PartyGovernance.GovernanceOpts({
394	                            hosts: opts.governanceOpts.hosts,
395	                            voteDuration: opts.governanceOpts.voteDuration,
396	                            executionDelay: opts.governanceOpts.executionDelay,
397	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
398	                            totalVotingPower: 0,
399	                            feeBps: opts.governanceOpts.feeBps,
400	                            feeRecipient: opts.governanceOpts.feeRecipient
401	                        }),
402	                        proposalEngine: opts.proposalEngineOpts
403	                    }),
404	                    opts.preciousTokens,
405	                    opts.preciousTokenIds,
406	                    opts.rageQuitTimestamp
407	                );
408	        } else {
409	            return
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
411	                    opts.governanceOpts.partyImpl,
412	                    authorities,
413	                    Party.PartyOptions({
414	                        name: opts.name,
415	                        symbol: opts.symbol,
416	                        customizationPresetId: opts.customizationPresetId,
417	                        governance: PartyGovernance.GovernanceOpts({
418	                            hosts: opts.governanceOpts.hosts,
419	                            voteDuration: opts.governanceOpts.voteDuration,
420	                            executionDelay: opts.governanceOpts.executionDelay,
421	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
422	                            totalVotingPower: 0,
423	                            feeBps: opts.governanceOpts.feeBps,
424	                            feeRecipient: opts.governanceOpts.feeRecipient
425	                        }),
426	                        proposalEngine: opts.proposalEngineOpts
427	                    }),
428	                    opts.preciousTokens,
429	                    opts.preciousTokenIds,
430	                    opts.rageQuitTimestamp,
431	                    customMetadataProvider,
432	                    customMetadata
433	                );
434	        }
435	    }
```
[372..435](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L372-L435)

---

	 - contracts/party/PartyGovernance.sol

```solidity
342	    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {
343	        return _getSharedProposalStorage().engineImpl;
344	    }
345	
...
347	    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {
348	        return _getSharedProposalStorage().opts;
349	    }
350	
...
355	    function getVotingPowerAt(
356	        address voter,
357	        uint40 timestamp
358	    ) external view returns (uint96 votingPower) {
359	        return getVotingPowerAt(voter, timestamp, type(uint256).max);
360	    }
361	
...
368	    function getVotingPowerAt(
369	        address voter,
370	        uint40 timestamp,
371	        uint256 snapIndex
372	    ) public view returns (uint96 votingPower) {
373	        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);
374	        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;
375	    }
376	
...
390	    function getGovernanceValues() external view returns (GovernanceValues memory) {
391	        return _getSharedProposalStorage().governanceValues;
392	    }
393	
```
[342..345](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L342-L345)
[347..350](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L347-L350)
[355..361](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L355-L361)
[368..376](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L368-L376)
[390..393](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L390-L393)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
...
129	    function contractURI() external view returns (string memory) {
130	        _delegateToRenderer();
131	        return ""; // Just to make the compiler happy.
132	    }
...
136	    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {
137	        _delegateToRenderer();
138	        return (address(0), 0); // Just to make the compiler happy.
139	    }
...
247	    function increaseTotalVotingPower(uint96 votingPower) external {
248	        _assertAuthority();
249	        _getSharedProposalStorage().governanceValues.totalVotingPower += votingPower;
250	    }
...
255	    function decreaseTotalVotingPower(uint96 votingPower) external {
256	        _assertAuthority();
257	        _getSharedProposalStorage().governanceValues.totalVotingPower -= votingPower;
258	    }
...
458	    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {
459	        // super.safeTransferFrom() will call transferFrom() first which will
460	        // transfer voting power.
461	        super.safeTransferFrom(owner, to, tokenId);
462	    }
...
465	    function safeTransferFrom(
466	        address owner,
467	        address to,
468	        uint256 tokenId,
469	        bytes calldata data
470	    ) public override {
471	        // super.safeTransferFrom() will call transferFrom() first which will
472	        // transfer voting power.
473	        super.safeTransferFrom(owner, to, tokenId, data);
474	    }
```
[123..126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L123-L126)
[129..132](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L129-L132)
[136..139](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L136-L139)
[247..250](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L247-L250)
[255..258](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L255-L258)
[458..462](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L458-L462)
[465..474](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L465-L474)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
123	    function initialize(
124	        address oldImpl,
125	        bytes calldata initializeData
126	    ) external override onlyDelegateCall {
127	        // Prevent old parties from configuring new options to maintain security guarantees.
128	        if (oldImpl != address(0)) return;
129	
130	        // If there is no initialize data, there is nothing to do.
131	        if (initializeData.length == 0) return;
132	
133	        ProposalEngineOpts memory opts = abi.decode(initializeData, (ProposalEngineOpts));
134	
135	        // Set proposal engine opts
136	        _getSharedProposalStorage().opts = opts;
137	    }
138	
...
141	    function getCurrentInProgressProposalId() external view returns (uint256 id) {
142	        return _getStorage().currentInProgressProposalId;
143	    }
144	
```
[123..138](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L123-L138)
[141..144](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L141-L144)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
42	    function getSignatureValidatorForHash(bytes32 hash) public view returns (IERC1271) {
43	        return _getSetSignatureValidatorProposalStorage().signatureValidators[hash];
44	    }
```
[42..44](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L42-L44)


</details>

-------
### [N-18] A function which defines named returns in it's declaration doesn't need to use return
<a name="N-18"></a>
[To the top](#TOP)

Once the return variable has been assigned (or has its default value), there is no need to explicitly return it at the end of the function, since it's returned automatically.
Remove the return statement once ensuring it is safe to do so

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 15 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
164	    function contribute(
165	        address delegate,
166	        bytes memory gateData
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
168	        return
169	            _contribute(
170	                payable(msg.sender),
171	                delegate,
172	                msg.value.safeCastUint256ToUint96(),
173	                0, // Mint a new party card for the contributor.
174	                gateData
175	            );
176	    }
...
185	    function contribute(
186	        uint256 tokenId,
187	        address delegate,
188	        bytes memory gateData
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
190	        return
191	            _contribute(
192	                payable(msg.sender),
193	                delegate,
194	                msg.value.safeCastUint256ToUint96(),
195	                tokenId,
196	                gateData
197	            );
198	    }
...
235	    function contributeFor(
236	        uint256 tokenId,
237	        address payable recipient,
238	        address initialDelegate,
239	        bytes memory gateData
240	    ) external payable onlyDelegateCall returns (uint96 votingPower) {
241	        return
242	            _contribute(
243	                recipient,
244	                initialDelegate,
245	                msg.value.safeCastUint256ToUint96(),
246	                tokenId,
247	                gateData
248	            );
249	    }
...
275	    function _contribute(
276	        address payable contributor,
277	        address delegate,
278	        uint96 amount,
279	        uint256 tokenId,
280	        bytes memory gateData
281	    ) private returns (uint96 votingPower) {
282	        // Require a non-null delegate.
283	        if (delegate == address(0)) {
284	            revert InvalidDelegateError();
285	        }
286	
287	        // Must not be blocked by gatekeeper.
288	        IGateKeeper _gateKeeper = gateKeeper;
289	        if (_gateKeeper != IGateKeeper(address(0))) {
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
291	                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);
292	            }
293	        }
294	
295	        votingPower = _processContribution(contributor, delegate, amount);
296	
297	        // OK to contribute with zero just to update delegate.
298	        if (amount == 0) return 0;
299	
300	        if (tokenId == 0) {
301	            // Mint contributor a new party card.
302	            party.mint(contributor, votingPower, delegate);
303	        } else if (disableContributingForExistingCard) {
304	            revert ContributingForExistingCardDisabledError();
305	        } else if (party.ownerOf(tokenId) == contributor) {
306	            // Increase voting power of contributor's existing party card.
307	            party.increaseVotingPower(tokenId, votingPower);
308	        } else {
309	            revert NotOwnerError(tokenId);
310	        }
311	    }
```
[164..176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L164-L176)
[185..198](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L185-L198)
[235..249](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L249)
[275..311](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L275-L311)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
175	    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {
176	        if (maxTotalContributions == 0) {
177	            return CrowdfundLifecycle.Invalid;
178	        }
179	
180	        uint256 expiry_ = expiry;
181	        if (expiry_ == 0) {
182	            return CrowdfundLifecycle.Finalized;
183	        }
184	
185	        if (block.timestamp >= expiry_) {
186	            if (totalContributions >= minTotalContributions) {
187	                return CrowdfundLifecycle.Won;
188	            } else {
189	                return CrowdfundLifecycle.Lost;
190	            }
191	        }
192	
193	        return CrowdfundLifecycle.Active;
194	    }
195	
...
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
```
[175..195](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L175-L195)
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)

---

	 - contracts/party/PartyGovernance.sol

```solidity
355	    function getVotingPowerAt(
356	        address voter,
357	        uint40 timestamp
358	    ) external view returns (uint96 votingPower) {
359	        return getVotingPowerAt(voter, timestamp, type(uint256).max);
360	    }
361	
...
368	    function getVotingPowerAt(
369	        address voter,
370	        uint40 timestamp,
371	        uint256 snapIndex
372	    ) public view returns (uint96 votingPower) {
373	        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);
374	        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;
375	    }
376	
...
423	    function findVotingPowerSnapshotIndex(
424	        address voter,
425	        uint40 timestamp
426	    ) public view returns (uint256 index) {
427	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
428	
429	        // Derived from Open Zeppelin binary search
430	        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39
431	        uint256 high = snaps.length;
432	        uint256 low = 0;
433	        while (low < high) {
434	            uint256 mid = (low + high) / 2;
435	            if (snaps[mid].timestamp > timestamp) {
436	                // Entry is too recent.
437	                high = mid;
438	            } else {
439	                // Entry is older. This is our best guess for now.
440	                low = mid + 1;
441	            }
442	        }
443	
444	        // Return `type(uint256).max` if no valid voting snapshots found.
445	        return high == 0 ? type(uint256).max : high - 1;
446	    }
447	
...
487	    function distribute(
488	        uint256 amount,
489	        ITokenDistributor.TokenType tokenType,
490	        address token,
491	        uint256 tokenId
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
493	        _assertNotGloballyDisabled();
494	        // Ignore if the party is calling functions on itself, like with
495	        // `FractionalizeProposal` and `DistributionProposal`.
496	        if (msg.sender != address(this)) {
497	            // Must not require a vote to create a distribution, otherwise
498	            // distributions can only be created through a distribution
499	            // proposal.
500	            if (_getSharedProposalStorage().opts.distributionsRequireVote) {
501	                revert DistributionsRequireVoteError();
502	            }
503	            // Must be an active member.
504	            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
509	        // Prevent creating a distribution if the party has not started.
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
511	            revert PartyNotStartedError();
512	        }
513	        // Get the address of the token distributor.
514	        ITokenDistributor distributor = ITokenDistributor(
515	            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)
516	        );
517	        emit DistributionCreated(tokenType, token, tokenId);
518	        // Notify third-party platforms that the governance NFT metadata has
519	        // updated for all tokens.
520	        emit BatchMetadataUpdate(0, type(uint256).max);
521	        // Create a native token distribution.
522	        address payable feeRecipient_ = feeRecipient;
523	        uint16 feeBps_ = feeBps;
524	        if (tokenType == ITokenDistributor.TokenType.Native) {
525	            return
526	                distributor.createNativeDistribution{ value: amount }(
527	                    Party(payable(address(this))),
528	                    feeRecipient_,
529	                    feeBps_
530	                );
531	        }
532	        // Otherwise must be an ERC20 token distribution.
533	        assert(tokenType == ITokenDistributor.TokenType.Erc20);
534	        IERC20(token).compatTransfer(address(distributor), amount);
535	        return
536	            distributor.createErc20Distribution(
537	                IERC20(token),
538	                Party(payable(address(this))),
539	                feeRecipient_,
540	                feeBps_
541	            );
542	    }
543	
...
595	    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {
596	        // Get the information about the proposal.
597	        ProposalState storage info = _proposalStateByProposalId[proposalId];
598	        ProposalStateValues memory values = info.values;
599	
600	        // Can only vote in certain proposal statuses.
601	        {
602	            ProposalStatus status = _getProposalStatus(values);
603	            // Allow voting even if the proposal is passed/ready so it can
604	            // potentially reach 100% consensus, which unlocks special
605	            // behaviors for certain proposal types.
606	            if (
607	                status != ProposalStatus.Voting &&
608	                status != ProposalStatus.Passed &&
609	                status != ProposalStatus.Ready
610	            ) {
611	                revert BadProposalStatusError(status);
612	            }
613	        }
614	
615	        // Prevent voting in the same block as the last rage quit timestamp.
616	        // This is to prevent an exploit where a member can rage quit to reduce
617	        // the total voting power of the party, then propose and vote in the
618	        // same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.
619	        // This would allow them to use the voting power snapshot just before
620	        // their card was burned to vote, potentially passing a proposal that
621	        // would have otherwise not passed.
622	        if (lastRageQuitTimestamp == block.timestamp) {
623	            revert CannotRageQuitAndAcceptError();
624	        }
625	
626	        // Cannot vote twice.
627	        if (info.hasVoted[msg.sender]) {
628	            revert AlreadyVotedError(msg.sender);
629	        }
630	        // Mark the caller as having voted.
631	        info.hasVoted[msg.sender] = true;
632	
633	        // Increase the total votes that have been cast on this proposal.
634	        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);
635	        values.votes += votingPower;
636	        if (isHost[msg.sender]) {
637	            ++values.numHostsAccepted;
638	        }
639	        info.values = values;
640	        emit ProposalAccepted(proposalId, msg.sender, votingPower);
641	
642	        // Update the proposal status if it has reached the pass threshold.
643	        if (
644	            values.passedTime == 0 &&
645	            _areVotesPassing(
646	                values.votes,
647	                values.totalVotingPower,
648	                _getSharedProposalStorage().governanceValues.passThresholdBps
649	            )
650	        ) {
651	            info.values.passedTime = uint40(block.timestamp);
652	            emit ProposalPassed(proposalId);
653	            // Notify third-party platforms that the governance NFT metadata has
654	            // updated for all tokens.
655	            emit BatchMetadataUpdate(0, type(uint256).max);
656	        }
657	        return values.votes;
658	    }
659	
...
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
...
904	    function _getVotingPowerSnapshotAt(
905	        address voter,
906	        uint40 timestamp,
907	        uint256 hintIndex
908	    ) internal view returns (VotingPowerSnapshot memory snap) {
909	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
910	        uint256 snapsLength = snaps.length;
911	        if (snapsLength != 0) {
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
923	            // Hint was wrong, fallback to binary search to find snapshot.
924	            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);
925	            // Check that snapshot was found.
926	            if (hintIndex != type(uint256).max) {
927	                return snaps[hintIndex];
928	            }
929	        }
930	
931	        // No snapshot found.
932	        return snap;
933	    }
934	
...
1064	    function _getProposalStatus(
1065	        ProposalStateValues memory pv
1066	    ) private view returns (ProposalStatus status) {
1067	        // Never proposed.
1068	        if (pv.proposedTime == 0) {
1069	            return ProposalStatus.Invalid;
1070	        }
1071	        // Executed at least once.
1072	        if (pv.executedTime != 0) {
1073	            if (pv.completedTime == 0) {
1074	                return ProposalStatus.InProgress;
1075	            }
1076	            // completedTime high bit will be set if cancelled.
1077	            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {
1078	                return ProposalStatus.Cancelled;
1079	            }
1080	            return ProposalStatus.Complete;
1081	        }
1082	        // Vetoed.
1083	        if (pv.votes == type(uint96).max) {
1084	            return ProposalStatus.Defeated;
1085	        }
1086	        uint40 t = uint40(block.timestamp);
1087	        GovernanceValues memory gv = _getSharedProposalStorage().governanceValues;
1088	        if (pv.passedTime != 0) {
1089	            // Ready.
1090	            if (pv.passedTime + gv.executionDelay <= t) {
1091	                return ProposalStatus.Ready;
1092	            }
1093	            // If unanimous, we skip the execution delay.
1094	            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1095	                return ProposalStatus.Ready;
1096	            }
1097	            // If all hosts voted, skip execution delay
1098	            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1099	                return ProposalStatus.Ready;
1100	            }
1101	            // Passed.
1102	            return ProposalStatus.Passed;
1103	        }
1104	        // Voting window expired.
1105	        if (pv.proposedTime + gv.voteDuration <= t) {
1106	            return ProposalStatus.Defeated;
1107	        }
1108	        return ProposalStatus.Voting;
1109	    }
1110	
```
[355..361](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L355-L361)
[368..376](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L368-L376)
[423..447](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L423-L447)
[487..543](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L487-L543)
[595..659](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L595-L659)
[860..902](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L860-L902)
[904..934](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L904-L934)
[1064..1110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1064-L1110)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
141	    function getCurrentInProgressProposalId() external view returns (uint256 id) {
142	        return _getStorage().currentInProgressProposalId;
143	    }
144	
```
[141..144](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L141-L144)


</details>

-------
### [N-19] State variables should include comments
<a name="N-19"></a>
[To the top](#TOP)

Consider adding some comments on critical state variables to explain what they are supposed to do: this will help for future code reviews.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 12 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
88	    IGlobals private immutable _GLOBALS;
```
[88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L88)

---

	 - contracts/party/PartyGovernance.sol

```solidity
186	    uint256 private constant UINT40_HIGH_BIT = 1 << 39;
...
187	    uint96 private constant VETO_VALUE = type(uint96).max;
...
191	    IGlobals private immutable _GLOBALS;
```
[186](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L186)
[187](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L187)
[191](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L191)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
34	    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256("ENABLE_RAGEQUIT_PERMANENTLY")))
...
35	    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256("DISABLE_RAGEQUIT_PERMANENTLY")))
...
38	    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
...
42	    IGlobals private immutable _GLOBALS;
```
[34](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L34)
[35](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L35)
[38](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L38)
[42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L42)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
101	    IGlobals private immutable _GLOBALS;
...
104	    uint256 private constant _STORAGE_SLOT = uint256(keccak256("ProposalExecutionEngine.Storage"));
```
[101](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L101)
[104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L104)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
39	    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;
...
40	    uint256 private constant SHARED_STORAGE_SLOT =
41	        uint256(keccak256("ProposalStorage.SharedProposalStorage"));
```
[39](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L39)
[40..41](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L40-L41)


</details>

-------
### [N-20] Change `public` to `external` for functions that are not called internally
<a name="N-20"></a>
[To the top](#TOP)

Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 10 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
164	    function contribute(
165	        address delegate,
166	        bytes memory gateData
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
168	        return
169	            _contribute(
170	                payable(msg.sender),
171	                delegate,
172	                msg.value.safeCastUint256ToUint96(),
173	                0, // Mint a new party card for the contributor.
174	                gateData
175	            );
176	    }
...
185	    function contribute(
186	        uint256 tokenId,
187	        address delegate,
188	        bytes memory gateData
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
190	        return
191	            _contribute(
192	                payable(msg.sender),
193	                delegate,
194	                msg.value.safeCastUint256ToUint96(),
195	                tokenId,
196	                gateData
197	            );
198	    }
```
[164..176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L164-L176)
[185..198](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L185-L198)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
278	    function convertVotingPowerToContribution(
279	        uint96 votingPower
280	    ) public view returns (uint96 amount) {
281	        amount = (votingPower * 1e4) / exchangeRateBps;
282	
283	        // Add back funding split to contribution amount if applicable.
284	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
285	        uint16 fundingSplitBps_ = fundingSplitBps;
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
288	        }
289	    }
290	
```
[278..290](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L278-L290)

---

	 - contracts/party/PartyGovernance.sol

```solidity
333	    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {
334	        return
335	            interfaceId == type(IERC721Receiver).interfaceId ||
336	            interfaceId == type(ERC1155TokenReceiverBase).interfaceId ||
337	            // ERC4906 interface ID
338	            interfaceId == 0x49064906;
339	    }
340	
```
[333..340](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L333-L340)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
113	    function supportsInterface(
114	        bytes4 interfaceId
115	    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {
116	        return
117	            PartyGovernance.supportsInterface(interfaceId) ||
118	            ERC721.supportsInterface(interfaceId) ||
119	            interfaceId == type(IERC2981).interfaceId;
120	    }
...
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
...
451	    function transferFrom(address owner, address to, uint256 tokenId) public override {
452	        // Transfer voting along with token.
453	        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);
454	        super.transferFrom(owner, to, tokenId);
455	    }
...
458	    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {
459	        // super.safeTransferFrom() will call transferFrom() first which will
460	        // transfer voting power.
461	        super.safeTransferFrom(owner, to, tokenId);
462	    }
...
465	    function safeTransferFrom(
466	        address owner,
467	        address to,
468	        uint256 tokenId,
469	        bytes calldata data
470	    ) public override {
471	        // super.safeTransferFrom() will call transferFrom() first which will
472	        // transfer voting power.
473	        super.safeTransferFrom(owner, to, tokenId, data);
474	    }
```
[113..120](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L113-L120)
[123..126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L123-L126)
[451..455](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L451-L455)
[458..462](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L458-L462)
[465..474](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L465-L474)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
42	    function getSignatureValidatorForHash(bytes32 hash) public view returns (IERC1271) {
43	        return _getSetSignatureValidatorProposalStorage().signatureValidators[hash];
44	    }
```
[42..44](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L42-L44)


</details>

-------
### [N-21] `if`-statement can be converted to a ternary
<a name="N-21"></a>
[To the top](#TOP)

The code can be made more compact while also increasing readability by converting the following `if`-statements to ternaries (e.g. `foo += (x > y) ? a : b`)

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 10 instances</summary>


---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
197	        if (nextProgressData.length == 0) {
198	            stor.currentInProgressProposalId = 0;
199	            stor.nextProgressDataHash = 0;
200	        } else {
201	            // Remember the next progress data.
202	            stor.nextProgressDataHash = keccak256(nextProgressData);
203	        }
204	    }
...
252	        if (pt == ProposalType.ListOnOpensea) {
253	            nextProgressData = _executeListOnOpensea(params);
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
```
[197..204](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L197-L204)
[252..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L252-L292)
[254..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L254-L292)
[256..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L256-L292)
[258..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L258-L292)
[260..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L260-L292)
[265..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L265-L292)
[271..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L271-L292)
[277..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L277-L292)
[283..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L283-L292)


</details>

-------
### [N-22] Emits without msg.sender parameter
<a name="N-22"></a>
[To the top](#TOP)

If msg.sender play a part in the functionality of a function, any emits of this function should include msg.sender to ensure transparency with users

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 9 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
371	        // Must be called by the DAO.
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
384	    }
385	
...
388	    function disableEmergencyExecute() external {
389	        // Only the DAO or a host can call this.
390	        if (
391	            !party.isHost(msg.sender) &&
392	            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender
393	        ) {
394	            revert OnlyPartyDaoOrHostError(msg.sender);
395	        }
396	        emergencyExecuteDisabled = true;
397	        emit EmergencyExecuteDisabled();
398	    }
399	}
```
[366..385](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L366-L385)
[388..399](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L388-L399)

---

	 - contracts/party/PartyGovernance.sol

```solidity
487	    function distribute(
488	        uint256 amount,
489	        ITokenDistributor.TokenType tokenType,
490	        address token,
491	        uint256 tokenId
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
493	        _assertNotGloballyDisabled();
494	        // Ignore if the party is calling functions on itself, like with
495	        // `FractionalizeProposal` and `DistributionProposal`.
496	        if (msg.sender != address(this)) {
497	            // Must not require a vote to create a distribution, otherwise
498	            // distributions can only be created through a distribution
499	            // proposal.
500	            if (_getSharedProposalStorage().opts.distributionsRequireVote) {
501	                revert DistributionsRequireVoteError();
502	            }
503	            // Must be an active member.
504	            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
509	        // Prevent creating a distribution if the party has not started.
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
511	            revert PartyNotStartedError();
512	        }
513	        // Get the address of the token distributor.
514	        ITokenDistributor distributor = ITokenDistributor(
515	            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)
516	        );
517	        emit DistributionCreated(tokenType, token, tokenId);
518	        // Notify third-party platforms that the governance NFT metadata has
519	        // updated for all tokens.
520	        emit BatchMetadataUpdate(0, type(uint256).max);
521	        // Create a native token distribution.
522	        address payable feeRecipient_ = feeRecipient;
523	        uint16 feeBps_ = feeBps;
524	        if (tokenType == ITokenDistributor.TokenType.Native) {
525	            return
526	                distributor.createNativeDistribution{ value: amount }(
527	                    Party(payable(address(this))),
528	                    feeRecipient_,
529	                    feeBps_
530	                );
531	        }
532	        // Otherwise must be an ERC20 token distribution.
533	        assert(tokenType == ITokenDistributor.TokenType.Erc20);
534	        IERC20(token).compatTransfer(address(distributor), amount);
535	        return
536	            distributor.createErc20Distribution(
537	                IERC20(token),
538	                Party(payable(address(this))),
539	                feeRecipient_,
540	                feeBps_
541	            );
542	    }
543	
...
553	    function propose(
554	        Proposal memory proposal,
555	        uint256 latestSnapIndex
556	    ) external returns (uint256 proposalId) {
557	        _assertActiveMember();
558	        proposalId = ++lastProposalId;
559	        // Store the time the proposal was created and the proposal hash.
560	        (
561	            _proposalStateByProposalId[proposalId].values,
562	            _proposalStateByProposalId[proposalId].hash
563	        ) = (
564	            ProposalStateValues({
565	                proposedTime: uint40(block.timestamp),
566	                passedTime: 0,
567	                executedTime: 0,
568	                completedTime: 0,
569	                votes: 0,
570	                totalVotingPower: _getSharedProposalStorage().governanceValues.totalVotingPower,
571	                numHosts: numHosts,
572	                numHostsAccepted: 0
573	            }),
574	            getProposalHash(proposal)
575	        );
576	        emit Proposed(proposalId, msg.sender, proposal);
577	        accept(proposalId, latestSnapIndex);
578	
579	        // Notify third-party platforms that the governance NFT metadata has
580	        // updated for all tokens.
581	        emit BatchMetadataUpdate(0, type(uint256).max);
582	    }
583	
...
595	    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {
596	        // Get the information about the proposal.
597	        ProposalState storage info = _proposalStateByProposalId[proposalId];
598	        ProposalStateValues memory values = info.values;
599	
600	        // Can only vote in certain proposal statuses.
601	        {
602	            ProposalStatus status = _getProposalStatus(values);
603	            // Allow voting even if the proposal is passed/ready so it can
604	            // potentially reach 100% consensus, which unlocks special
605	            // behaviors for certain proposal types.
606	            if (
607	                status != ProposalStatus.Voting &&
608	                status != ProposalStatus.Passed &&
609	                status != ProposalStatus.Ready
610	            ) {
611	                revert BadProposalStatusError(status);
612	            }
613	        }
614	
615	        // Prevent voting in the same block as the last rage quit timestamp.
616	        // This is to prevent an exploit where a member can rage quit to reduce
617	        // the total voting power of the party, then propose and vote in the
618	        // same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.
619	        // This would allow them to use the voting power snapshot just before
620	        // their card was burned to vote, potentially passing a proposal that
621	        // would have otherwise not passed.
622	        if (lastRageQuitTimestamp == block.timestamp) {
623	            revert CannotRageQuitAndAcceptError();
624	        }
625	
626	        // Cannot vote twice.
627	        if (info.hasVoted[msg.sender]) {
628	            revert AlreadyVotedError(msg.sender);
629	        }
630	        // Mark the caller as having voted.
631	        info.hasVoted[msg.sender] = true;
632	
633	        // Increase the total votes that have been cast on this proposal.
634	        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);
635	        values.votes += votingPower;
636	        if (isHost[msg.sender]) {
637	            ++values.numHostsAccepted;
638	        }
639	        info.values = values;
640	        emit ProposalAccepted(proposalId, msg.sender, votingPower);
641	
642	        // Update the proposal status if it has reached the pass threshold.
643	        if (
644	            values.passedTime == 0 &&
645	            _areVotesPassing(
646	                values.votes,
647	                values.totalVotingPower,
648	                _getSharedProposalStorage().governanceValues.passThresholdBps
649	            )
650	        ) {
651	            info.values.passedTime = uint40(block.timestamp);
652	            emit ProposalPassed(proposalId);
653	            // Notify third-party platforms that the governance NFT metadata has
654	            // updated for all tokens.
655	            emit BatchMetadataUpdate(0, type(uint256).max);
656	        }
657	        return values.votes;
658	    }
659	
...
665	    function veto(uint256 proposalId) external {
666	        _assertHost();
667	        // Setting `votes` to -1 indicates a veto.
668	        ProposalState storage info = _proposalStateByProposalId[proposalId];
669	        ProposalStateValues memory values = info.values;
670	
671	        {
672	            ProposalStatus status = _getProposalStatus(values);
673	            // Proposal must be in one of the following states.
674	            if (
675	                status != ProposalStatus.Voting &&
676	                status != ProposalStatus.Passed &&
677	                status != ProposalStatus.Ready
678	            ) {
679	                revert BadProposalStatusError(status);
680	            }
681	        }
682	
683	        // -1 indicates veto.
684	        info.values.votes = VETO_VALUE;
685	        emit ProposalVetoed(proposalId, msg.sender);
686	        // Notify third-party platforms that the governance NFT metadata has
687	        // updated for all tokens.
688	        emit BatchMetadataUpdate(0, type(uint256).max);
689	    }
690	
...
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
```
[487..543](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L487-L543)
[553..583](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L553-L583)
[595..659](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L595-L659)
[665..690](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L665-L690)
[860..902](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L860-L902)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
268	    function _burnAndUpdateVotingPower(
269	        uint256[] memory tokenIds,
270	        bool checkIfAuthorizedToBurn
271	    ) private returns (uint96 totalVotingPowerBurned) {
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
302	
303	        // Update minted voting power.
304	        mintedVotingPower -= totalVotingPowerBurned;
305	    }
```
[268..305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L268-L305)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
84	    function setSigningThresholdBps(uint96 thresholdBps) external {
85	        Party party = Party(payable(msg.sender));
86	        emit SigningThresholdBpsSet(party, signingThersholdBps[party], thresholdBps);
87	        signingThersholdBps[party] = thresholdBps;
88	    }
```
[84..88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L84-L88)


</details>

-------
### [N-23] Using named parameters in `mapping` is best practice
<a name="N-23"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 9 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
131	    mapping(address => address) public delegationsByContributor;
```
[131](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L131)

---

	 - contracts/party/PartyGovernance.sol

```solidity
141	        mapping(address => bool) hasVoted;
...
206	    mapping(address => bool) public isHost;
...
208	    mapping(address => address) public delegationsByVoter;
...
212	    mapping(uint256 => ProposalState) private _proposalStateByProposalId;
...
214	    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;
```
[141](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L141)
[206](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L206)
[208](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L208)
[212](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L212)
[214](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L214)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
57	    mapping(uint256 => uint256) public votingPowerByTokenId;
...
59	    mapping(address => bool) public isAuthority;
```
[57](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L57)
[59](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L59)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
10	        mapping(bytes32 => IERC1271) signatureValidators;
```
[10](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L10)


</details>

-------
### [N-24] Remaining eth may not be refunded to users
<a name="N-24"></a>
[To the top](#TOP)

 When a contract function accepts Ethereum and executes a `.call()` or similar function that also forwards Ethereum value, it's important to check for and refund any remaining balance. This is because some of the supplied value may not be used during the call execution due to gas constraints, a revert in the called contract, or simply because not all the value was needed.

If you do not account for this remaining balance, it can become "locked" in the contract. It's crucial to either return the remaining balance to the sender or handle it in a way that ensures it is not permanently stuck. Neglecting to do so can lead to loss of funds and degradation of the contract's reliability. Furthermore, it's good practice to ensure fairness and trust with your users by returning unused funds. 

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 9 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
108	    function initialize(
109	        InitialETHCrowdfundOptions memory crowdfundOpts,
110	        ETHPartyOptions memory partyOpts,
111	        MetadataProvider customMetadataProvider,
112	        bytes memory customMetadata
113	    ) external payable onlyInitialize {
114	        // Create party the initial crowdfund will be for.
115	        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);
116	
117	        // Initialize the crowdfund.
118	        _initialize(
119	            ETHCrowdfundOptions({
120	                party: party_,
121	                initialContributor: crowdfundOpts.initialContributor,
122	                initialDelegate: crowdfundOpts.initialDelegate,
123	                minContribution: crowdfundOpts.minContribution,
124	                maxContribution: crowdfundOpts.maxContribution,
125	                disableContributingForExistingCard: crowdfundOpts
126	                    .disableContributingForExistingCard,
127	                minTotalContributions: crowdfundOpts.minTotalContributions,
128	                maxTotalContributions: crowdfundOpts.maxTotalContributions,
129	                exchangeRateBps: crowdfundOpts.exchangeRateBps,
130	                fundingSplitBps: crowdfundOpts.fundingSplitBps,
131	                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,
132	                duration: crowdfundOpts.duration,
133	                gateKeeper: crowdfundOpts.gateKeeper,
134	                gateKeeperId: crowdfundOpts.gateKeeperId
135	            })
136	        );
137	
138	        // If the deployer passed in some ETH during deployment, credit them
139	        // for the initial contribution.
140	        uint96 initialContribution = msg.value.safeCastUint256ToUint96();
141	        if (initialContribution > 0) {
142	            // If this contract has ETH, either passed in during deployment or
143	            // pre-existing, credit it to the `initialContributor`.
144	            _contribute(
145	                crowdfundOpts.initialContributor,
146	                crowdfundOpts.initialDelegate,
147	                initialContribution,
148	                0,
149	                ""
150	            );
151	        }
152	
153	        // Set up gatekeeper after initial contribution (initial always gets in).
154	        gateKeeper = crowdfundOpts.gateKeeper;
155	        gateKeeperId = crowdfundOpts.gateKeeperId;
156	    }
...
164	    function contribute(
165	        address delegate,
166	        bytes memory gateData
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
168	        return
169	            _contribute(
170	                payable(msg.sender),
171	                delegate,
172	                msg.value.safeCastUint256ToUint96(),
173	                0, // Mint a new party card for the contributor.
174	                gateData
175	            );
176	    }
...
185	    function contribute(
186	        uint256 tokenId,
187	        address delegate,
188	        bytes memory gateData
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
190	        return
191	            _contribute(
192	                payable(msg.sender),
193	                delegate,
194	                msg.value.safeCastUint256ToUint96(),
195	                tokenId,
196	                gateData
197	            );
198	    }
...
204	    function batchContribute(
205	        BatchContributeArgs calldata args
206	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
207	        uint256 numContributions = args.tokenIds.length;
208	        votingPowers = new uint96[](numContributions);
209	
210	        uint256 ethAvailable = msg.value;
211	        for (uint256 i; i < numContributions; ++i) {
212	            ethAvailable -= args.values[i];
213	
214	            votingPowers[i] = _contribute(
215	                payable(msg.sender),
216	                args.delegate,
217	                args.values[i],
218	                args.tokenIds[i],
219	                args.gateDatas[i]
220	            );
221	        }
222	
223	        // Refund any unused ETH.
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
225	    }
...
235	    function contributeFor(
236	        uint256 tokenId,
237	        address payable recipient,
238	        address initialDelegate,
239	        bytes memory gateData
240	    ) external payable onlyDelegateCall returns (uint96 votingPower) {
241	        return
242	            _contribute(
243	                recipient,
244	                initialDelegate,
245	                msg.value.safeCastUint256ToUint96(),
246	                tokenId,
247	                gateData
248	            );
249	    }
...
255	    function batchContributeFor(
256	        BatchContributeForArgs calldata args
257	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
258	        votingPowers = new uint96[](args.recipients.length);
259	        uint256 valuesSum;
260	        for (uint256 i; i < args.recipients.length; ++i) {
261	            votingPowers[i] = _contribute(
262	                args.recipients[i],
263	                args.initialDelegates[i],
264	                args.values[i],
265	                args.tokenIds[i],
266	                args.gateDatas[i]
267	            );
268	            valuesSum += args.values[i];
269	        }
270	        if (msg.value != valuesSum) {
271	            revert InvalidMessageValue();
272	        }
273	    }
```
[108..156](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L108-L156)
[164..176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L164-L176)
[185..198](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L185-L198)
[204..225](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L204-L225)
[235..249](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L249)
[255..273](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L255-L273)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
371	        // Must be called by the DAO.
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
384	    }
385	
```
[366..385](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L366-L385)

---

	 - contracts/party/PartyGovernance.sol

```solidity
706	    function execute(
707	        uint256 proposalId,
708	        Proposal memory proposal,
709	        IERC721[] memory preciousTokens,
710	        uint256[] memory preciousTokenIds,
711	        bytes calldata progressData,
712	        bytes calldata extraData
713	    ) external payable {
714	        _assertNotGloballyDisabled();
715	        _assertActiveMember();
716	        // Get information about the proposal.
717	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
718	        // Proposal details must remain the same from `propose()`.
719	        _validateProposalHash(proposal, proposalState.hash);
720	        ProposalStateValues memory values = proposalState.values;
721	        ProposalStatus status = _getProposalStatus(values);
722	        // The proposal must be executable or have already been executed but still
723	        // has more steps to go.
724	        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {
725	            revert BadProposalStatusError(status);
726	        }
727	        if (status == ProposalStatus.Ready) {
728	            // If the proposal has not been executed yet, make sure it hasn't
729	            // expired. Note that proposals that have been executed
730	            // (but still have more steps) ignore `maxExecutableTime`.
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
738	        }
739	        // Check that the precious list is valid.
740	        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {
741	            revert BadPreciousListError();
742	        }
743	        // Preemptively set the proposal to completed to avoid it being executed
744	        // again in a deeper call.
745	        proposalState.values.completedTime = uint40(block.timestamp);
746	        // Execute the proposal.
747	        bool completed = _executeProposal(
748	            proposalId,
749	            proposal,
750	            preciousTokens,
751	            preciousTokenIds,
752	            _getProposalFlags(values),
753	            progressData,
754	            extraData
755	        );
756	        if (!completed) {
757	            // Proposal did not complete.
758	            proposalState.values.completedTime = 0;
759	        }
760	    }
761	
...
841	    function emergencyExecute(
842	        address targetAddress,
843	        bytes calldata targetCallData,
844	        uint256 amountEth
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
846	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
847	        if (!success) {
848	            res.rawRevert();
849	        }
850	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
851	    }
852	
```
[706..761](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L706-L761)
[841..852](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L841-L852)


</details>

-------
### [N-25] Function names should differ to make the code more readable
<a name="N-25"></a>
[To the top](#TOP)

In Solidity, while function overriding allows for functions with the same name to coexist, it is advisable to avoid this practice to enhance code readability and maintainability. Having multiple functions with the same name, even with different parameters or in inherited contracts, can cause confusion and increase the likelihood of errors during development, testing, and debugging. Using distinct and descriptive function names not only clarifies the purpose and behavior of each function, but also helps prevent unintended function calls or incorrect overriding. By adopting a clear and consistent naming convention, developers can create more comprehensible and maintainable smart contracts.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 8 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
164	    function contribute(
165	        address delegate,
166	        bytes memory gateData
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
168	        return
169	            _contribute(
170	                payable(msg.sender),
171	                delegate,
172	                msg.value.safeCastUint256ToUint96(),
173	                0, // Mint a new party card for the contributor.
174	                gateData
175	            );
176	    }
...
185	    function contribute(
186	        uint256 tokenId,
187	        address delegate,
188	        bytes memory gateData
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
190	        return
191	            _contribute(
192	                payable(msg.sender),
193	                delegate,
194	                msg.value.safeCastUint256ToUint96(),
195	                tokenId,
196	                gateData
197	            );
198	    }
```
[164..176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L164-L176)
[185..198](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L185-L198)

---

	 - contracts/party/PartyGovernance.sol

```solidity
355	    function getVotingPowerAt(
356	        address voter,
357	        uint40 timestamp
358	    ) external view returns (uint96 votingPower) {
359	        return getVotingPowerAt(voter, timestamp, type(uint256).max);
360	    }
361	
...
368	    function getVotingPowerAt(
369	        address voter,
370	        uint40 timestamp,
371	        uint256 snapIndex
372	    ) public view returns (uint96 votingPower) {
373	        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);
374	        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;
375	    }
376	
```
[355..361](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L355-L361)
[368..376](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L368-L376)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
263	    function burn(uint256[] memory tokenIds) public {
264	        _assertAuthority();
265	        _burnAndUpdateVotingPower(tokenIds, false);
266	    }
...
310	    function burn(uint256 tokenId) external {
311	        uint256[] memory tokenIds = new uint256[](1);
312	        tokenIds[0] = tokenId;
313	        burn(tokenIds);
314	    }
...
458	    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {
459	        // super.safeTransferFrom() will call transferFrom() first which will
460	        // transfer voting power.
461	        super.safeTransferFrom(owner, to, tokenId);
462	    }
...
465	    function safeTransferFrom(
466	        address owner,
467	        address to,
468	        uint256 tokenId,
469	        bytes calldata data
470	    ) public override {
471	        // super.safeTransferFrom() will call transferFrom() first which will
472	        // transfer voting power.
473	        super.safeTransferFrom(owner, to, tokenId, data);
474	    }
```
[263..266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L263-L266)
[310..314](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L310-L314)
[458..462](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L458-L462)
[465..474](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L465-L474)


</details>

-------
### [N-26] Consider using `delete` rather than assigning zero/false to clear values
<a name="N-26"></a>
[To the top](#TOP)

The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 7 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
470	        isHost[msg.sender] = false;
...
758	            proposalState.values.completedTime = 0;
```
[470](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L470)
[758](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L758)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
198	            stor.currentInProgressProposalId = 0;
...
199	            stor.nextProgressDataHash = 0;
...
221	        stor.currentInProgressProposalId = 0;
...
222	        stor.nextProgressDataHash = 0;
```
[198](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L198)
[199](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L199)
[221](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L221)
[222](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L222)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
37	        nextProgressData = "";
```
[37](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L37)


</details>

-------
### [N-27] External calls in an un-bounded `for`-loop may result in a DOS
<a name="N-27"></a>
[To the top](#TOP)

Consider limiting the number of iterations in `for`-loops that make external calls

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 7 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
211	        for (uint256 i; i < numContributions; ++i) {
212	            ethAvailable -= args.values[i];
213	
214	            votingPowers[i] = _contribute(
215	                payable(msg.sender),
216	                args.delegate,
217	                args.values[i],
218	                args.tokenIds[i],
219	                args.gateDatas[i]
220	            );
221	        }
...
260	        for (uint256 i; i < args.recipients.length; ++i) {
261	            votingPowers[i] = _contribute(
262	                args.recipients[i],
263	                args.initialDelegates[i],
264	                args.values[i],
265	                args.tokenIds[i],
266	                args.gateDatas[i]
267	            );
268	            valuesSum += args.values[i];
269	        }
...
357	        for (uint256 i; i < numRefunds; ++i) {
358	            (bool s, bytes memory r) = address(this).call(
359	                abi.encodeCall(this.refund, (tokenIds[i]))
360	            );
361	
362	            if (!s) {
363	                if (revertOnFailure) {
364	                    r.rawRevert();
365	                }
366	            } else {
367	                amounts[i] = abi.decode(r, (uint96));
368	            }
369	        }
```
[211..221](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L211-L221)
[260..269](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L260-L269)
[357..369](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L357-L369)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
...
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
...
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
...
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
```
[272..301](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L272-L301)
[378..395](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L378-L395)
[391..394](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L391-L394)
[408..441](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L408-L441)


</details>

-------
### [N-28] Events may be emitted out of order due to reentrancy
<a name="N-28"></a>
[To the top](#TOP)

Ensure that events follow the best practice of check-effects-interaction, and are emitted before external calls

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 7 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
317	    function _finalize(uint96 totalContributions_) internal {
318	        // Finalize the crowdfund.
319	        delete expiry;
320	
321	        // Transfer funding split to recipient if applicable.
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
323	        uint16 fundingSplitBps_ = fundingSplitBps;
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
326	        }
327	
328	        // Update the party's total voting power.
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
330	        party.increaseTotalVotingPower(newVotingPower);
331	
332	        // Transfer ETH to the party.
333	        payable(address(party)).transferEth(totalContributions_);
334	
335	        emit Finalized();
336	    }
337	
...
339	    function sendFundingSplit() external returns (uint96 splitAmount) {
340	        // Check that the crowdfund is finalized.
341	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
342	        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);
343	
344	        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();
345	
346	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
347	        uint16 fundingSplitBps_ = fundingSplitBps;
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
349	            revert FundingSplitNotConfiguredError();
350	        }
351	
352	        fundingSplitPaid = true;
353	
354	        // Transfer funding split to recipient.
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
356	        payable(fundingSplitRecipient_).transferEth(splitAmount);
357	
358	        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);
359	    }
360	
...
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
371	        // Must be called by the DAO.
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
384	    }
385	
```
[317..337](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L317-L337)
[339..360](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L339-L360)
[366..385](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L366-L385)

---

	 - contracts/party/PartyGovernance.sol

```solidity
771	    function cancel(uint256 proposalId, Proposal calldata proposal) external {
772	        _assertActiveMember();
773	        // Get information about the proposal.
774	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
775	        // Proposal details must remain the same from `propose()`.
776	        _validateProposalHash(proposal, proposalState.hash);
777	        ProposalStateValues memory values = proposalState.values;
778	        {
779	            // Must be `InProgress`.
780	            ProposalStatus status = _getProposalStatus(values);
781	            if (status != ProposalStatus.InProgress) {
782	                revert BadProposalStatusError(status);
783	            }
784	        }
785	        {
786	            // Limit the `cancelDelay` to the global max and min cancel delay
787	            // to mitigate parties accidentally getting stuck forever by setting an
788	            // unrealistic `cancelDelay` or being reckless with too low a
789	            // cancel delay.
790	            uint256 cancelDelay = proposal.cancelDelay;
791	            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(
792	                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION
793	            );
794	            uint256 globalMinCancelDelay = _GLOBALS.getUint256(
795	                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION
796	            );
797	            if (globalMaxCancelDelay != 0) {
798	                // Only if we have one set.
799	                if (cancelDelay > globalMaxCancelDelay) {
800	                    cancelDelay = globalMaxCancelDelay;
801	                }
802	            }
803	            if (globalMinCancelDelay != 0) {
804	                // Only if we have one set.
805	                if (cancelDelay < globalMinCancelDelay) {
806	                    cancelDelay = globalMinCancelDelay;
807	                }
808	            }
809	            uint256 cancelTime = values.executedTime + cancelDelay;
810	            // Must not be too early.
811	            if (block.timestamp < cancelTime) {
812	                revert ProposalCannotBeCancelledYetError(
813	                    uint40(block.timestamp),
814	                    uint40(cancelTime)
815	                );
816	            }
817	        }
818	        // Mark the proposal as cancelled by setting the completed time to the current
819	        // time with the high bit set.
820	        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);
821	        {
822	            // Delegatecall into the proposal engine impl to perform the cancel.
823	            (bool success, bytes memory resultData) = (
824	                address(_getSharedProposalStorage().engineImpl)
825	            ).delegatecall(abi.encodeCall(IProposalExecutionEngine.cancelProposal, (proposalId)));
826	            if (!success) {
827	                resultData.rawRevert();
828	            }
829	        }
830	        emit ProposalCancelled(proposalId);
831	        // Notify third-party platforms that the governance NFT metadata has
832	        // updated for all tokens.
833	        emit BatchMetadataUpdate(0, type(uint256).max);
834	    }
835	
...
841	    function emergencyExecute(
842	        address targetAddress,
843	        bytes calldata targetCallData,
844	        uint256 amountEth
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
846	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
847	        if (!success) {
848	            res.rawRevert();
849	        }
850	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
851	    }
852	
...
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
```
[771..835](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L771-L835)
[841..852](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L841-L852)
[860..902](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L860-L902)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
```
[344..448](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L344-L448)


</details>

-------
### [N-29] Function state mutability can be restricted to view
<a name="N-29"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 6 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
372	    function _createParty(
373	        ETHPartyOptions memory opts,
374	        MetadataProvider customMetadataProvider,
375	        bytes memory customMetadata
376	    ) private returns (Party) {
377	        uint256 authoritiesLength = opts.authorities.length + 1;
378	        address[] memory authorities = new address[](authoritiesLength);
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
382	        authorities[authoritiesLength - 1] = address(this);
383	
384	        if (address(customMetadataProvider) == address(0)) {
385	            return
386	                opts.governanceOpts.partyFactory.createParty(
387	                    opts.governanceOpts.partyImpl,
388	                    authorities,
389	                    Party.PartyOptions({
390	                        name: opts.name,
391	                        symbol: opts.symbol,
392	                        customizationPresetId: opts.customizationPresetId,
393	                        governance: PartyGovernance.GovernanceOpts({
394	                            hosts: opts.governanceOpts.hosts,
395	                            voteDuration: opts.governanceOpts.voteDuration,
396	                            executionDelay: opts.governanceOpts.executionDelay,
397	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
398	                            totalVotingPower: 0,
399	                            feeBps: opts.governanceOpts.feeBps,
400	                            feeRecipient: opts.governanceOpts.feeRecipient
401	                        }),
402	                        proposalEngine: opts.proposalEngineOpts
403	                    }),
404	                    opts.preciousTokens,
405	                    opts.preciousTokenIds,
406	                    opts.rageQuitTimestamp
407	                );
408	        } else {
409	            return
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
411	                    opts.governanceOpts.partyImpl,
412	                    authorities,
413	                    Party.PartyOptions({
414	                        name: opts.name,
415	                        symbol: opts.symbol,
416	                        customizationPresetId: opts.customizationPresetId,
417	                        governance: PartyGovernance.GovernanceOpts({
418	                            hosts: opts.governanceOpts.hosts,
419	                            voteDuration: opts.governanceOpts.voteDuration,
420	                            executionDelay: opts.governanceOpts.executionDelay,
421	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
422	                            totalVotingPower: 0,
423	                            feeBps: opts.governanceOpts.feeBps,
424	                            feeRecipient: opts.governanceOpts.feeRecipient
425	                        }),
426	                        proposalEngine: opts.proposalEngineOpts
427	                    }),
428	                    opts.preciousTokens,
429	                    opts.preciousTokenIds,
430	                    opts.rageQuitTimestamp,
431	                    customMetadataProvider,
432	                    customMetadata
433	                );
434	        }
435	    }
```
[372..435](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L372-L435)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
247	    function increaseTotalVotingPower(uint96 votingPower) external {
248	        _assertAuthority();
249	        _getSharedProposalStorage().governanceValues.totalVotingPower += votingPower;
250	    }
...
255	    function decreaseTotalVotingPower(uint96 votingPower) external {
256	        _assertAuthority();
257	        _getSharedProposalStorage().governanceValues.totalVotingPower -= votingPower;
258	    }
...
458	    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {
459	        // super.safeTransferFrom() will call transferFrom() first which will
460	        // transfer voting power.
461	        super.safeTransferFrom(owner, to, tokenId);
462	    }
...
465	    function safeTransferFrom(
466	        address owner,
467	        address to,
468	        uint256 tokenId,
469	        bytes calldata data
470	    ) public override {
471	        // super.safeTransferFrom() will call transferFrom() first which will
472	        // transfer voting power.
473	        super.safeTransferFrom(owner, to, tokenId, data);
474	    }
```
[247..250](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L247-L250)
[255..258](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L255-L258)
[458..462](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L458-L462)
[465..474](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L465-L474)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
123	    function initialize(
124	        address oldImpl,
125	        bytes calldata initializeData
126	    ) external override onlyDelegateCall {
127	        // Prevent old parties from configuring new options to maintain security guarantees.
128	        if (oldImpl != address(0)) return;
129	
130	        // If there is no initialize data, there is nothing to do.
131	        if (initializeData.length == 0) return;
132	
133	        ProposalEngineOpts memory opts = abi.decode(initializeData, (ProposalEngineOpts));
134	
135	        // Set proposal engine opts
136	        _getSharedProposalStorage().opts = opts;
137	    }
138	
```
[123..138](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L123-L138)


</details>

-------
### [N-30] Use of `override` is unnecessary
<a name="N-30"></a>
[To the top](#TOP)

Starting with Solidity version [0.8.8](https://docs.soliditylang.org/en/v0.8.20/contracts.html#function-overriding), using the `override` keyword when the function solely overrides an interface function, and the function doesn't exist in multiple base contracts, is unnecessary.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 6 instances</summary>


---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
113	    function supportsInterface(
114	        bytes4 interfaceId
115	    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {
116	        return
117	            PartyGovernance.supportsInterface(interfaceId) ||
118	            ERC721.supportsInterface(interfaceId) ||
119	            interfaceId == type(IERC2981).interfaceId;
120	    }
...
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
...
451	    function transferFrom(address owner, address to, uint256 tokenId) public override {
452	        // Transfer voting along with token.
453	        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);
454	        super.transferFrom(owner, to, tokenId);
455	    }
...
458	    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {
459	        // super.safeTransferFrom() will call transferFrom() first which will
460	        // transfer voting power.
461	        super.safeTransferFrom(owner, to, tokenId);
462	    }
...
465	    function safeTransferFrom(
466	        address owner,
467	        address to,
468	        uint256 tokenId,
469	        bytes calldata data
470	    ) public override {
471	        // super.safeTransferFrom() will call transferFrom() first which will
472	        // transfer voting power.
473	        super.safeTransferFrom(owner, to, tokenId, data);
474	    }
```
[113..120](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L113-L120)
[123..126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L123-L126)
[451..455](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L451-L455)
[458..462](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L458-L462)
[465..474](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L465-L474)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
123	    function initialize(
124	        address oldImpl,
125	        bytes calldata initializeData
126	    ) external override onlyDelegateCall {
127	        // Prevent old parties from configuring new options to maintain security guarantees.
128	        if (oldImpl != address(0)) return;
129	
130	        // If there is no initialize data, there is nothing to do.
131	        if (initializeData.length == 0) return;
132	
133	        ProposalEngineOpts memory opts = abi.decode(initializeData, (ProposalEngineOpts));
134	
135	        // Set proposal engine opts
136	        _getSharedProposalStorage().opts = opts;
137	    }
138	
```
[123..138](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L123-L138)


</details>

-------
### [N-31] Modifier declarations should have NatSpec descriptions
<a name="N-31"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 6 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
231	    modifier onlyPartyDao() {
232	        {
233	            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
234	            if (msg.sender != partyDao) {
235	                revert NotAuthorized();
236	            }
237	        }
238	        _;
239	    }
240	
...
242	    modifier onlyPartyDaoOrHost() {
243	        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
244	        if (msg.sender != partyDao && !isHost[msg.sender]) {
245	            revert NotAuthorized();
246	        }
247	        _;
248	    }
249	
...
251	    modifier onlyWhenEmergencyExecuteAllowed() {
252	        if (emergencyExecuteDisabled) {
253	            revert OnlyWhenEmergencyActionsAllowedError();
254	        }
255	        _;
256	    }
257	
```
[231..240](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L231-L240)
[242..249](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L242-L249)
[251..257](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L251-L257)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
67	    modifier onlySelf() {
68	        if (msg.sender != address(this)) {
69	            revert NotAuthorized();
70	        }
71	        _;
72	    }
```
[67..72](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L67-L72)

---

	 - contracts/utils/Implementation.sol

```solidity
22	    modifier onlyDelegateCall() virtual {
23	        if (address(this) == implementation) {
24	            revert OnlyDelegateCallError();
25	        }
26	        _;
27	    }
...
29	    modifier onlyInitialize() {
30	        if (initialized) revert AlreadyInitialized();
31	
32	        initialized = true;
33	        emit Initialized();
34	
35	        _;
36	    }
```
[22..27](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L22-L27)
[29..36](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L29-L36)


</details>

-------
### [N-32] Setters should prevent re-setting of the same value
<a name="N-32"></a>
[To the top](#TOP)

This especially problematic when the setter also emits the same value, which may be confusing to offline parsers

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 5 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
```
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)

---

	 - contracts/party/PartyGovernance.sol

```solidity
944	    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {
945	        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);
946	        address oldDelegate = delegationsByVoter[voter];
947	        // If `oldDelegate` is zero and `voter` never delegated, then have
948	        // `voter` delegate to themself.
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
950	        // If the new `delegate` is zero, use the current (old) delegate.
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
952	
953	        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({
954	            timestamp: uint40(block.timestamp),
955	            delegatedVotingPower: oldSnap.delegatedVotingPower,
956	            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +
957	                votingPower).safeCastInt192ToUint96(),
958	            isDelegated: delegate != voter
959	        });
960	        _insertVotingPowerSnapshot(voter, newSnap);
961	        delegationsByVoter[voter] = delegate;
962	
963	        // This event is emitted even if the delegate did not change.
964	        emit PartyDelegateUpdated(voter, delegate);
965	
966	        // Handle rebalancing delegates.
967	        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);
968	    }
969	
```
[944..969](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L944-L969)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
81	    function _initialize(
82	        string memory name_,
83	        string memory symbol_,
84	        uint256 customizationPresetId,
85	        PartyGovernance.GovernanceOpts memory governanceOpts,
86	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
87	        IERC721[] memory preciousTokens,
88	        uint256[] memory preciousTokenIds,
89	        address[] memory authorities,
90	        uint40 rageQuitTimestamp_
91	    ) internal {
92	        PartyGovernance._initialize(
93	            governanceOpts,
94	            proposalEngineOpts,
95	            preciousTokens,
96	            preciousTokenIds
97	        );
98	        name = name_;
99	        symbol = symbol_;
100	        rageQuitTimestamp = rageQuitTimestamp_;
101	        unchecked {
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
105	        }
106	        if (customizationPresetId != 0) {
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
109	        }
110	    }
...
318	    function setRageQuit(uint40 newRageQuitTimestamp) external {
319	        _assertHost();
320	        // Prevent disabling ragequit after initialization.
321	        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {
322	            revert CannotDisableRageQuitAfterInitializationError();
323	        }
324	
325	        uint40 oldRageQuitTimestamp = rageQuitTimestamp;
326	
327	        // Prevent setting timestamp if it is permanently enabled/disabled.
328	        if (
329	            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||
330	            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY
331	        ) {
332	            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);
333	        }
334	
335	        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);
336	    }
```
[81..110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L81-L110)
[318..336](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L318-L336)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
84	    function setSigningThresholdBps(uint96 thresholdBps) external {
85	        Party party = Party(payable(msg.sender));
86	        emit SigningThresholdBpsSet(party, signingThersholdBps[party], thresholdBps);
87	        signingThersholdBps[party] = thresholdBps;
88	    }
```
[84..88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L84-L88)


</details>

-------
### [N-33] Expressions for constant values should use `immutable` rather than `constant`
<a name="N-33"></a>
[To the top](#TOP)

While it does not save gas for some simple binary expressions because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they should each be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable` variables should be used for expressions, or values calculated in, or passed into the constructor.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 5 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
186	    uint256 private constant UINT40_HIGH_BIT = 1 << 39;
...
187	    uint96 private constant VETO_VALUE = type(uint96).max;
```
[186](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L186)
[187](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L187)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
104	    uint256 private constant _STORAGE_SLOT = uint256(keccak256("ProposalExecutionEngine.Storage"));
```
[104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L104)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
40	    uint256 private constant SHARED_STORAGE_SLOT =
41	        uint256(keccak256("ProposalStorage.SharedProposalStorage"));
```
[40..41](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L40-L41)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
13	    uint256 private constant _SET_SIGNATURE_VALIDATOR_PROPOSAL_STORAGE_SLOT =
14	        uint256(keccak256("SetSignatureValidatorProposal.Storage"));
```
[13..14](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L13-L14)


</details>

-------
### [N-34] `constructor` missing zero address check
<a name="N-34"></a>
[To the top](#TOP)

It is important to ensure that the constructor does not allow zero address to be set.
    This is a common mistake that can lead to loss of funds or redeployment of the contract.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 4 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
134	    constructor(IGlobals globals) {
135	        _GLOBALS = globals;
136	    }
137	
```
[134..137](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L134-L137)

---

	 - contracts/party/PartyGovernance.sol

```solidity
265	    constructor(IGlobals globals) {
266	        _GLOBALS = globals;
267	    }
268	
```
[265..268](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L265-L268)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
76	    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721("", "") {
77	        _GLOBALS = globals;
78	    }
```
[76..78](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L76-L78)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
107	    constructor(
108	        IGlobals globals,
109	        IReserveAuctionCoreEth zora,
110	        IFractionalV1VaultFactory fractionalVaultFactory
111	    )
112	        ListOnOpenseaAdvancedProposal(globals)
113	        ListOnZoraProposal(globals, zora)
114	        FractionalizeProposal(fractionalVaultFactory)
115	        ArbitraryCallsProposal(zora)
116	    {
117	        _GLOBALS = globals;
118	    }
119	
```
[107..119](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L107-L119)


</details>

-------
### [N-35] Variable initialization with default value
<a name="N-35"></a>
[To the top](#TOP)

It's not necessary to initialize a variable with its default value, and it's actually worse in gas terms as it adds an overhead.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 4 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
```
[379](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L379)

---

	 - contracts/party/PartyGovernance.sol

```solidity
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
...
432	        uint256 low = 0;
...
1054	        uint256 flags = 0;
```
[305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L305)
[432](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L432)
[1054](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1054)


</details>

-------
### [N-36] Consider implementing two-step procedure for updating protocol addresses
<a name="N-36"></a>
[To the top](#TOP)

A copy-paste error or a typo may end up bricking protocol functionality, or sending tokens to an address with no known private key. Consider implementing a two-step procedure for updating protocol addresses, where the recipient is set as pending, and must 'accept' the assignment by making an affirmative call. A straight forward way of doing this would be to have the target contracts implement [EIP-165](https://eips.ethereum.org/EIPS/eip-165), and to have the 'set' functions ensure that the recipient is of the right interface type.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 4 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
```
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)

---

	 - contracts/party/PartyGovernance.sol

```solidity
944	    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {
945	        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);
946	        address oldDelegate = delegationsByVoter[voter];
947	        // If `oldDelegate` is zero and `voter` never delegated, then have
948	        // `voter` delegate to themself.
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
950	        // If the new `delegate` is zero, use the current (old) delegate.
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
952	
953	        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({
954	            timestamp: uint40(block.timestamp),
955	            delegatedVotingPower: oldSnap.delegatedVotingPower,
956	            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +
957	                votingPower).safeCastInt192ToUint96(),
958	            isDelegated: delegate != voter
959	        });
960	        _insertVotingPowerSnapshot(voter, newSnap);
961	        delegationsByVoter[voter] = delegate;
962	
963	        // This event is emitted even if the delegate did not change.
964	        emit PartyDelegateUpdated(voter, delegate);
965	
966	        // Handle rebalancing delegates.
967	        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);
968	    }
969	
```
[944..969](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L944-L969)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
```
[344..448](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L344-L448)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
43	    function _initProposalImpl(IProposalExecutionEngine impl, bytes memory initData) internal {
44	        SharedProposalStorage storage stor = _getSharedProposalStorage();
45	        IProposalExecutionEngine oldImpl = stor.engineImpl;
46	        stor.engineImpl = impl;
47	        (bool s, bytes memory r) = address(impl).delegatecall(
48	            abi.encodeCall(IProposalExecutionEngine.initialize, (address(oldImpl), initData))
49	        );
50	        if (!s) {
51	            r.rawRevert();
52	        }
53	    }
```
[43..53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L43-L53)


</details>

-------
### [N-37] Missing event and or timelock for critical parameter change
<a name="N-37"></a>
[To the top](#TOP)

Events help non-contract tools to track changes, and timelocks prevent users from being surprised by changes

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 4 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
1137	    function _setPreciousList(
1138	        IERC721[] memory preciousTokens,
1139	        uint256[] memory preciousTokenIds
1140	    ) private {
1141	        if (preciousTokens.length != preciousTokenIds.length) {
1142	            revert MismatchedPreciousListLengths();
1143	        }
1144	        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);
1145	    }
1146	
```
[1137..1146](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1137-L1146)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
268	    function _burnAndUpdateVotingPower(
269	        uint256[] memory tokenIds,
270	        bool checkIfAuthorizedToBurn
271	    ) private returns (uint96 totalVotingPowerBurned) {
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
302	
303	        // Update minted voting power.
304	        mintedVotingPower -= totalVotingPowerBurned;
305	    }
...
318	    function setRageQuit(uint40 newRageQuitTimestamp) external {
319	        _assertHost();
320	        // Prevent disabling ragequit after initialization.
321	        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {
322	            revert CannotDisableRageQuitAfterInitializationError();
323	        }
324	
325	        uint40 oldRageQuitTimestamp = rageQuitTimestamp;
326	
327	        // Prevent setting timestamp if it is permanently enabled/disabled.
328	        if (
329	            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||
330	            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY
331	        ) {
332	            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);
333	        }
334	
335	        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);
336	    }
```
[268..305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L268-L305)
[318..336](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L318-L336)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
84	    function setSigningThresholdBps(uint96 thresholdBps) external {
85	        Party party = Party(payable(msg.sender));
86	        emit SigningThresholdBpsSet(party, signingThersholdBps[party], thresholdBps);
87	        signingThersholdBps[party] = thresholdBps;
88	    }
```
[84..88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L84-L88)


</details>

-------
### [N-38] Consider adding a block/deny-list
<a name="N-38"></a>
[To the top](#TOP)

Doing so will significantly increase centralization, but will help to prevent hackers from using stolen tokens

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 4 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
20	contract InitialETHCrowdfund is ETHCrowdfundBase {
21	    using LibRawResult for bytes;
22	    using LibSafeCast for uint256;
23	    using LibAddress for address payable;
24	
25	    // Options to be passed into `initialize()` when the crowdfund is created.
26	    struct InitialETHCrowdfundOptions {
27	        address payable initialContributor;
28	        address initialDelegate;
29	        uint96 minContribution;
30	        uint96 maxContribution;
31	        bool disableContributingForExistingCard;
32	        uint96 minTotalContributions;
33	        uint96 maxTotalContributions;
34	        uint16 exchangeRateBps;
35	        uint16 fundingSplitBps;
36	        address payable fundingSplitRecipient;
37	        uint40 duration;
38	        IGateKeeper gateKeeper;
39	        bytes12 gateKeeperId;
40	    }
41	
42	    struct ETHPartyOptions {
43	        // Name of the party.
44	        string name;
45	        // Symbol of the party.
46	        string symbol;
47	        // The ID of the customization preset to use for the party card.
48	        uint256 customizationPresetId;
49	        // Options to initialize party governance with.
50	        Crowdfund.FixedGovernanceOpts governanceOpts;
51	        // Options to initialize party proposal engine with.
52	        ProposalStorage.ProposalEngineOpts proposalEngineOpts;
53	        // The tokens that are considered precious by the party.These are
54	        // protected assets and are subject to extra restrictions in proposals
55	        // vs other assets.
56	        IERC721[] preciousTokens;
57	        // The IDs associated with each token in `preciousTokens`.
58	        uint256[] preciousTokenIds;
59	        // The timestamp until which ragequit is enabled.
60	        uint40 rageQuitTimestamp;
61	        // Initial authorities to set on the party
62	        address[] authorities;
63	    }
64	
65	    struct BatchContributeArgs {
66	        // IDs of cards to credit the contributions to. When set to 0, it means
67	        uint256[] tokenIds;
68	        // The address to which voting power will be delegated for all contributions.
69	        address delegate;
70	        // The contribution amounts in wei. The length of this array must be
71	        // equal to the length of `tokenIds`.
72	        uint96[] values;
73	        // The data required to be validated by the `gatekeeper`, if set. If no
74	        // `gatekeeper` is set, this can be empty.
75	        bytes[] gateDatas;
76	    }
77	
78	    struct BatchContributeForArgs {
79	        // IDs of cards to credit the contributions to. When set to 0, it means
80	        // a new one should be minted.
81	        uint256[] tokenIds;
82	        // Addresses of to credit the contributions under. Each contribution
83	        // amount in `values` corresponds to a recipient in this array.
84	        address payable[] recipients;
85	        // The delegate to set for each recipient if they have not delegated
86	        // before.
87	        address[] initialDelegates;
88	        // The contribution amounts in wei. The length of this array must be
89	        // equal to the length of `recipients`.
90	        uint96[] values;
91	        // The data required to be validated by the `gatekeeper`, if set. If no
92	        // `gatekeeper` is set, this can be empty.
93	        bytes[] gateDatas;
94	    }
95	
96	    event Refunded(address indexed contributor, uint256 indexed tokenId, uint256 amount);
97	
98	    // Set the `Globals` contract.
99	    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}
100	
101	    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will
102	    ///         revert if called outside the constructor.
103	    /// @param crowdfundOpts Options to initialize the crowdfund with.
104	    /// @param partyOpts Options to initialize the party with.
105	    /// @param customMetadataProvider Optional provider to use for the party for
106	    ///                               rendering custom metadata.
107	    /// @param customMetadata Optional custom metadata to use for the party.
108	    function initialize(
109	        InitialETHCrowdfundOptions memory crowdfundOpts,
110	        ETHPartyOptions memory partyOpts,
111	        MetadataProvider customMetadataProvider,
112	        bytes memory customMetadata
113	    ) external payable onlyInitialize {
114	        // Create party the initial crowdfund will be for.
115	        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);
116	
117	        // Initialize the crowdfund.
118	        _initialize(
119	            ETHCrowdfundOptions({
120	                party: party_,
121	                initialContributor: crowdfundOpts.initialContributor,
122	                initialDelegate: crowdfundOpts.initialDelegate,
123	                minContribution: crowdfundOpts.minContribution,
124	                maxContribution: crowdfundOpts.maxContribution,
125	                disableContributingForExistingCard: crowdfundOpts
126	                    .disableContributingForExistingCard,
127	                minTotalContributions: crowdfundOpts.minTotalContributions,
128	                maxTotalContributions: crowdfundOpts.maxTotalContributions,
129	                exchangeRateBps: crowdfundOpts.exchangeRateBps,
130	                fundingSplitBps: crowdfundOpts.fundingSplitBps,
131	                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,
132	                duration: crowdfundOpts.duration,
133	                gateKeeper: crowdfundOpts.gateKeeper,
134	                gateKeeperId: crowdfundOpts.gateKeeperId
135	            })
136	        );
137	
138	        // If the deployer passed in some ETH during deployment, credit them
139	        // for the initial contribution.
140	        uint96 initialContribution = msg.value.safeCastUint256ToUint96();
141	        if (initialContribution > 0) {
142	            // If this contract has ETH, either passed in during deployment or
143	            // pre-existing, credit it to the `initialContributor`.
144	            _contribute(
145	                crowdfundOpts.initialContributor,
146	                crowdfundOpts.initialDelegate,
147	                initialContribution,
148	                0,
149	                ""
150	            );
151	        }
152	
153	        // Set up gatekeeper after initial contribution (initial always gets in).
154	        gateKeeper = crowdfundOpts.gateKeeper;
155	        gateKeeperId = crowdfundOpts.gateKeeperId;
156	    }
157	
158	    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.
159	    /// @param delegate The address to which voting power will be delegated to
160	    ///                 during the governance phase.
161	    /// @param gateData Data to pass to the gatekeeper to prove eligibility.
162	    /// @return votingPower The voting power the contributor receives for their
163	    ///                     contribution.
164	    function contribute(
165	        address delegate,
166	        bytes memory gateData
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
168	        return
169	            _contribute(
170	                payable(msg.sender),
171	                delegate,
172	                msg.value.safeCastUint256ToUint96(),
173	                0, // Mint a new party card for the contributor.
174	                gateData
175	            );
176	    }
177	
178	    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.
179	    /// @param tokenId The ID of the card the contribution is being made towards.
180	    /// @param delegate The address to which voting power will be delegated to
181	    ///                 during the governance phase.
182	    /// @param gateData Data to pass to the gatekeeper to prove eligibility.
183	    /// @return votingPower The voting power the contributor receives for their
184	    ///                     contribution.
185	    function contribute(
186	        uint256 tokenId,
187	        address delegate,
188	        bytes memory gateData
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
190	        return
191	            _contribute(
192	                payable(msg.sender),
193	                delegate,
194	                msg.value.safeCastUint256ToUint96(),
195	                tokenId,
196	                gateData
197	            );
198	    }
199	
200	    /// @notice `contribute()` in batch form.
201	    ///         May not revert if any individual contribution fails.
202	    /// @param args The arguments to pass to each `contribute()` call.
203	    /// @return votingPowers The voting power received for each contribution.
204	    function batchContribute(
205	        BatchContributeArgs calldata args
206	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
207	        uint256 numContributions = args.tokenIds.length;
208	        votingPowers = new uint96[](numContributions);
209	
210	        uint256 ethAvailable = msg.value;
211	        for (uint256 i; i < numContributions; ++i) {
212	            ethAvailable -= args.values[i];
213	
214	            votingPowers[i] = _contribute(
215	                payable(msg.sender),
216	                args.delegate,
217	                args.values[i],
218	                args.tokenIds[i],
219	                args.gateDatas[i]
220	            );
221	        }
222	
223	        // Refund any unused ETH.
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
225	    }
226	
227	    /// @notice Contribute to this crowdfund on behalf of another address.
228	    /// @param tokenId The ID of the token to credit the contribution to, or
229	    ///                zero to mint a new party card for the recipient
230	    /// @param recipient The address to record the contribution under
231	    /// @param initialDelegate The address to delegate to for the governance
232	    ///                        phase if recipient hasn't delegated
233	    /// @param gateData Data to pass to the gatekeeper to prove eligibility
234	    /// @return votingPower The voting power received for the contribution
235	    function contributeFor(
236	        uint256 tokenId,
237	        address payable recipient,
238	        address initialDelegate,
239	        bytes memory gateData
240	    ) external payable onlyDelegateCall returns (uint96 votingPower) {
241	        return
242	            _contribute(
243	                recipient,
244	                initialDelegate,
245	                msg.value.safeCastUint256ToUint96(),
246	                tokenId,
247	                gateData
248	            );
249	    }
250	
251	    /// @notice `contributeFor()` in batch form.
252	    ///         May not revert if any individual contribution fails.
253	    /// @param args The arguments for the batched `contributeFor()` calls.
254	    /// @return votingPowers The voting power received for each contribution.
255	    function batchContributeFor(
256	        BatchContributeForArgs calldata args
257	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
258	        votingPowers = new uint96[](args.recipients.length);
259	        uint256 valuesSum;
260	        for (uint256 i; i < args.recipients.length; ++i) {
261	            votingPowers[i] = _contribute(
262	                args.recipients[i],
263	                args.initialDelegates[i],
264	                args.values[i],
265	                args.tokenIds[i],
266	                args.gateDatas[i]
267	            );
268	            valuesSum += args.values[i];
269	        }
270	        if (msg.value != valuesSum) {
271	            revert InvalidMessageValue();
272	        }
273	    }
274	
275	    function _contribute(
276	        address payable contributor,
277	        address delegate,
278	        uint96 amount,
279	        uint256 tokenId,
280	        bytes memory gateData
281	    ) private returns (uint96 votingPower) {
282	        // Require a non-null delegate.
283	        if (delegate == address(0)) {
284	            revert InvalidDelegateError();
285	        }
286	
287	        // Must not be blocked by gatekeeper.
288	        IGateKeeper _gateKeeper = gateKeeper;
289	        if (_gateKeeper != IGateKeeper(address(0))) {
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
291	                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);
292	            }
293	        }
294	
295	        votingPower = _processContribution(contributor, delegate, amount);
296	
297	        // OK to contribute with zero just to update delegate.
298	        if (amount == 0) return 0;
299	
300	        if (tokenId == 0) {
301	            // Mint contributor a new party card.
302	            party.mint(contributor, votingPower, delegate);
303	        } else if (disableContributingForExistingCard) {
304	            revert ContributingForExistingCardDisabledError();
305	        } else if (party.ownerOf(tokenId) == contributor) {
306	            // Increase voting power of contributor's existing party card.
307	            party.increaseVotingPower(tokenId, votingPower);
308	        } else {
309	            revert NotOwnerError(tokenId);
310	        }
311	    }
312	
313	    /// @notice Refund the owner of a party card and burn it. Only available if
314	    ///         the crowdfund lost. Can be called to refund for self or on
315	    ///         another's behalf.
316	    /// @param tokenId The ID of the party card to refund the owner of then burn.
317	    /// @return amount The amount of ETH refunded to the contributor.
318	    function refund(uint256 tokenId) external returns (uint96 amount) {
319	        // Check crowdfund lifecycle.
320	        {
321	            CrowdfundLifecycle lc = getCrowdfundLifecycle();
322	            if (lc != CrowdfundLifecycle.Lost) {
323	                revert WrongLifecycleError(lc);
324	            }
325	        }
326	
327	        // Get amount to refund.
328	        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();
329	        amount = convertVotingPowerToContribution(votingPower);
330	
331	        if (amount > 0) {
332	            // Get contributor to refund.
333	            address payable contributor = payable(party.ownerOf(tokenId));
334	
335	            // Burn contributor's party card.
336	            party.burn(tokenId);
337	
338	            // Refund contributor.
339	            contributor.transferEth(amount);
340	
341	            emit Refunded(contributor, tokenId, amount);
342	        }
343	    }
344	
345	    /// @notice `refund()` in batch form.
346	    ///         May not revert if any individual refund fails.
347	    /// @param tokenIds The IDs of the party cards to burn and refund the owners of.
348	    /// @param revertOnFailure If true, revert if any refund fails.
349	    /// @return amounts The amounts of ETH refunded for each refund.
350	    function batchRefund(
351	        uint256[] calldata tokenIds,
352	        bool revertOnFailure
353	    ) external returns (uint96[] memory amounts) {
354	        uint256 numRefunds = tokenIds.length;
355	        amounts = new uint96[](numRefunds);
356	
357	        for (uint256 i; i < numRefunds; ++i) {
358	            (bool s, bytes memory r) = address(this).call(
359	                abi.encodeCall(this.refund, (tokenIds[i]))
360	            );
361	
362	            if (!s) {
363	                if (revertOnFailure) {
364	                    r.rawRevert();
365	                }
366	            } else {
367	                amounts[i] = abi.decode(r, (uint96));
368	            }
369	        }
370	    }
371	
372	    function _createParty(
373	        ETHPartyOptions memory opts,
374	        MetadataProvider customMetadataProvider,
375	        bytes memory customMetadata
376	    ) private returns (Party) {
377	        uint256 authoritiesLength = opts.authorities.length + 1;
378	        address[] memory authorities = new address[](authoritiesLength);
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
382	        authorities[authoritiesLength - 1] = address(this);
383	
384	        if (address(customMetadataProvider) == address(0)) {
385	            return
386	                opts.governanceOpts.partyFactory.createParty(
387	                    opts.governanceOpts.partyImpl,
388	                    authorities,
389	                    Party.PartyOptions({
390	                        name: opts.name,
391	                        symbol: opts.symbol,
392	                        customizationPresetId: opts.customizationPresetId,
393	                        governance: PartyGovernance.GovernanceOpts({
394	                            hosts: opts.governanceOpts.hosts,
395	                            voteDuration: opts.governanceOpts.voteDuration,
396	                            executionDelay: opts.governanceOpts.executionDelay,
397	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
398	                            totalVotingPower: 0,
399	                            feeBps: opts.governanceOpts.feeBps,
400	                            feeRecipient: opts.governanceOpts.feeRecipient
401	                        }),
402	                        proposalEngine: opts.proposalEngineOpts
403	                    }),
404	                    opts.preciousTokens,
405	                    opts.preciousTokenIds,
406	                    opts.rageQuitTimestamp
407	                );
408	        } else {
409	            return
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
411	                    opts.governanceOpts.partyImpl,
412	                    authorities,
413	                    Party.PartyOptions({
414	                        name: opts.name,
415	                        symbol: opts.symbol,
416	                        customizationPresetId: opts.customizationPresetId,
417	                        governance: PartyGovernance.GovernanceOpts({
418	                            hosts: opts.governanceOpts.hosts,
419	                            voteDuration: opts.governanceOpts.voteDuration,
420	                            executionDelay: opts.governanceOpts.executionDelay,
421	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
422	                            totalVotingPower: 0,
423	                            feeBps: opts.governanceOpts.feeBps,
424	                            feeRecipient: opts.governanceOpts.feeRecipient
425	                        }),
426	                        proposalEngine: opts.proposalEngineOpts
427	                    }),
428	                    opts.preciousTokens,
429	                    opts.preciousTokenIds,
430	                    opts.rageQuitTimestamp,
431	                    customMetadataProvider,
432	                    customMetadata
433	                );
434	        }
435	    }
436	}
```
[20..436](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L20-L436)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
9	contract ETHCrowdfundBase is Implementation {
10	    using LibRawResult for bytes;
11	    using LibSafeCast for uint256;
12	    using LibAddress for address payable;
13	
14	    enum CrowdfundLifecycle {
15	        // In practice, this state is never used. If the crowdfund is ever in
16	        // this stage, something is wrong (e.g. crowdfund was never initialized).
17	        Invalid,
18	        // Ready to accept contributions to reach contribution targets
19	        // until a deadline or the minimum contribution target is reached and
20	        // host finalizes.
21	        Active,
22	        // Expired and the minimum contribution target was not reached.
23	        Lost,
24	        // The crowdfund has expired and reached the minimum contribution
25	        // target. It is now ready to finalize.
26	        Won,
27	        // A won crowdfund has been finalized, with funds transferred to the
28	        // party and voting power successfully updated.
29	        Finalized
30	    }
31	
32	    // Options to be passed into `initialize()` when the crowdfund is created.
33	    struct ETHCrowdfundOptions {
34	        Party party;
35	        address payable initialContributor;
36	        address initialDelegate;
37	        uint96 minContribution;
38	        uint96 maxContribution;
39	        bool disableContributingForExistingCard;
40	        uint96 minTotalContributions;
41	        uint96 maxTotalContributions;
42	        uint16 exchangeRateBps;
43	        uint16 fundingSplitBps;
44	        address payable fundingSplitRecipient;
45	        uint40 duration;
46	        IGateKeeper gateKeeper;
47	        bytes12 gateKeeperId;
48	    }
49	
50	    error WrongLifecycleError(CrowdfundLifecycle lc);
51	    error NotAllowedByGateKeeperError(
52	        address contributor,
53	        IGateKeeper gateKeeper,
54	        bytes12 gateKeeperId,
55	        bytes gateData
56	    );
57	    error OnlyPartyHostError();
58	    error OnlyPartyDaoError(address notDao);
59	    error OnlyPartyDaoOrHostError(address notDao);
60	    error NotOwnerError(uint256 tokenId);
61	    error OnlyWhenEmergencyActionsAllowedError();
62	    error InvalidDelegateError();
63	    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);
64	    error MinGreaterThanMaxError(uint96 min, uint96 max);
65	    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);
66	    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);
67	    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);
68	    error InvalidExchangeRateError(uint16 exchangeRateBps);
69	    error ContributingForExistingCardDisabledError();
70	    error ZeroVotingPowerError();
71	    error FundingSplitAlreadyPaidError();
72	    error FundingSplitNotConfiguredError();
73	    error InvalidMessageValue();
74	
75	    event Contributed(
76	        address indexed sender,
77	        address indexed contributor,
78	        uint256 amount,
79	        address delegate
80	    );
81	    event Finalized();
82	    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);
83	    event EmergencyExecuteDisabled();
84	    event EmergencyExecute(address target, bytes data, uint256 amountEth);
85	
86	    // The `Globals` contract storing global configuration values. This contract
87	    // is immutable and it’s address will never change.
88	    IGlobals private immutable _GLOBALS;
89	
90	    /// @notice The address of the `Party` contract instance associated
91	    ///         with the crowdfund.
92	    Party public party;
93	    /// @notice The minimum amount of ETH that a contributor can send to
94	    ///         participate in the crowdfund.
95	    uint96 public minContribution;
96	    /// @notice The maximum amount of ETH that a contributor can send to
97	    ///         participate in the crowdfund per address.
98	    uint96 public maxContribution;
99	    /// @notice A boolean flag that determines whether contributors are allowed
100	    ///         to increase the voting power of their existing party cards.
101	    bool public disableContributingForExistingCard;
102	    /// @notice Whether the funding split has been claimed by the funding split
103	    ///         recipient.
104	    bool public fundingSplitPaid;
105	    /// @notice Whether the DAO has emergency powers for this crowdfund.
106	    bool public emergencyExecuteDisabled;
107	    /// @notice The minimum amount of total ETH contributions required for the
108	    ///         crowdfund to be considered successful.
109	    uint96 public minTotalContributions;
110	    /// @notice The maximum amount of total ETH contributions allowed for the
111	    ///         crowdfund.
112	    uint96 public maxTotalContributions;
113	    /// @notice The total amount of ETH contributed to the crowdfund so far.
114	    uint96 public totalContributions;
115	    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the
116	    ///         crowdfund has finalized.
117	    uint40 public expiry;
118	    /// @notice The exchange rate to use for converting ETH contributions to
119	    ///         voting power in basis points (e.g. 10000 = 1:1).
120	    uint16 public exchangeRateBps;
121	    /// @notice The portion of contributions to send to the funding recipient in
122	    ///         basis points (e.g. 100 = 1%).
123	    uint16 public fundingSplitBps;
124	    /// @notice The address to which a portion of the contributions is sent to.
125	    address payable public fundingSplitRecipient;
126	    /// @notice The gatekeeper contract used to restrict who can contribute to the party.
127	    IGateKeeper public gateKeeper;
128	    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.
129	    bytes12 public gateKeeperId;
130	    /// @notice The address a contributor is delegating their voting power to.
131	    mapping(address => address) public delegationsByContributor;
132	
133	    // Set the `Globals` contract.
134	    constructor(IGlobals globals) {
135	        _GLOBALS = globals;
136	    }
137	
138	    // Initialize storage for proxy contracts, credit initial contribution (if
139	    // any), and setup gatekeeper.
140	    function _initialize(ETHCrowdfundOptions memory opts) internal {
141	        // Set the minimum and maximum contribution amounts.
142	        if (opts.minContribution > opts.maxContribution) {
143	            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);
144	        }
145	        minContribution = opts.minContribution;
146	        maxContribution = opts.maxContribution;
147	        // Set the min total contributions.
148	        if (opts.minTotalContributions > opts.maxTotalContributions) {
149	            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);
150	        }
151	        minTotalContributions = opts.minTotalContributions;
152	        // Set the max total contributions.
153	        if (opts.maxTotalContributions == 0) {
154	            // Prevent this because when `maxTotalContributions` is 0 the
155	            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has
156	            // never been initialized.
157	            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);
158	        }
159	        maxTotalContributions = opts.maxTotalContributions;
160	        // Set the party crowdfund is for.
161	        party = opts.party;
162	        // Set the crowdfund start and end timestamps.
163	        expiry = uint40(block.timestamp + opts.duration);
164	        // Set the exchange rate.
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
166	        exchangeRateBps = opts.exchangeRateBps;
167	        // Set the funding split and its recipient.
168	        fundingSplitBps = opts.fundingSplitBps;
169	        fundingSplitRecipient = opts.fundingSplitRecipient;
170	        // Set whether to disable contributing for existing card.
171	        disableContributingForExistingCard = opts.disableContributingForExistingCard;
172	    }
173	
174	    /// @notice Get the current lifecycle of the crowdfund.
175	    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {
176	        if (maxTotalContributions == 0) {
177	            return CrowdfundLifecycle.Invalid;
178	        }
179	
180	        uint256 expiry_ = expiry;
181	        if (expiry_ == 0) {
182	            return CrowdfundLifecycle.Finalized;
183	        }
184	
185	        if (block.timestamp >= expiry_) {
186	            if (totalContributions >= minTotalContributions) {
187	                return CrowdfundLifecycle.Won;
188	            } else {
189	                return CrowdfundLifecycle.Lost;
190	            }
191	        }
192	
193	        return CrowdfundLifecycle.Active;
194	    }
195	
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
275	    /// @notice Calculate the contribution amount from the given voting power.
276	    /// @param votingPower The voting power to convert to a contribution amount.
277	    /// @return amount The contribution amount.
278	    function convertVotingPowerToContribution(
279	        uint96 votingPower
280	    ) public view returns (uint96 amount) {
281	        amount = (votingPower * 1e4) / exchangeRateBps;
282	
283	        // Add back funding split to contribution amount if applicable.
284	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
285	        uint16 fundingSplitBps_ = fundingSplitBps;
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
288	        }
289	    }
290	
291	    function finalize() external {
292	        uint96 totalContributions_ = totalContributions;
293	
294	        // Check that the crowdfund is not already finalized.
295	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
296	        if (lc == CrowdfundLifecycle.Active) {
297	            // Allow host to finalize crowdfund early if it has reached its minimum goal.
298	            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();
299	
300	            // Check that the crowdfund has reached its minimum goal.
301	            uint96 minTotalContributions_ = minTotalContributions;
302	            if (totalContributions_ < minTotalContributions_) {
303	                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);
304	            }
305	        } else {
306	            // Otherwise only allow finalization if the crowdfund has expired
307	            // and been won. Can be finalized by anyone.
308	            if (lc != CrowdfundLifecycle.Won) {
309	                revert WrongLifecycleError(lc);
310	            }
311	        }
312	
313	        // Finalize the crowdfund.
314	        _finalize(totalContributions_);
315	    }
316	
317	    function _finalize(uint96 totalContributions_) internal {
318	        // Finalize the crowdfund.
319	        delete expiry;
320	
321	        // Transfer funding split to recipient if applicable.
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
323	        uint16 fundingSplitBps_ = fundingSplitBps;
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
326	        }
327	
328	        // Update the party's total voting power.
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
330	        party.increaseTotalVotingPower(newVotingPower);
331	
332	        // Transfer ETH to the party.
333	        payable(address(party)).transferEth(totalContributions_);
334	
335	        emit Finalized();
336	    }
337	
338	    /// @notice Send the funding split to the recipient if applicable.
339	    function sendFundingSplit() external returns (uint96 splitAmount) {
340	        // Check that the crowdfund is finalized.
341	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
342	        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);
343	
344	        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();
345	
346	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
347	        uint16 fundingSplitBps_ = fundingSplitBps;
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
349	            revert FundingSplitNotConfiguredError();
350	        }
351	
352	        fundingSplitPaid = true;
353	
354	        // Transfer funding split to recipient.
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
356	        payable(fundingSplitRecipient_).transferEth(splitAmount);
357	
358	        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);
359	    }
360	
361	    /// @notice As the DAO, execute an arbitrary function call from this contract.
362	    /// @dev Emergency actions must not be revoked for this to work.
363	    /// @param targetAddress The contract to call.
364	    /// @param targetCallData The data to pass to the contract.
365	    /// @param amountEth The amount of ETH to send to the contract.
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
371	        // Must be called by the DAO.
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
384	    }
385	
386	    /// @notice Revoke the DAO's ability to call emergencyExecute().
387	    /// @dev Either the DAO or the party host can call this.
388	    function disableEmergencyExecute() external {
389	        // Only the DAO or a host can call this.
390	        if (
391	            !party.isHost(msg.sender) &&
392	            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender
393	        ) {
394	            revert OnlyPartyDaoOrHostError(msg.sender);
395	        }
396	        emergencyExecuteDisabled = true;
397	        emit EmergencyExecuteDisabled();
398	    }
399	}
```
[9..400](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L9-L400)

---

	 - contracts/party/PartyGovernance.sol

```solidity
23	abstract contract PartyGovernance is
24	    ProposalStorage,
25	    Implementation,
26	    IERC4906,
27	    ReadOnlyDelegateCall
28	{
29	    using LibERC20Compat for IERC20;
30	    using LibRawResult for bytes;
31	    using LibSafeCast for uint256;
32	    using LibSafeCast for int192;
33	    using LibSafeCast for uint96;
34	
35	    // States a proposal can be in.
36	    enum ProposalStatus {
37	        // The proposal does not exist.
38	        Invalid,
39	        // The proposal has been proposed (via `propose()`), has not been vetoed
40	        // by a party host, and is within the voting window. Members can vote on
41	        // the proposal and party hosts can veto the proposal.
42	        Voting,
43	        // The proposal has either exceeded its voting window without reaching
44	        // `passThresholdBps` of votes or was vetoed by a party host.
45	        Defeated,
46	        // The proposal reached at least `passThresholdBps` of votes but is still
47	        // waiting for `executionDelay` to pass before it can be executed. Members
48	        // can continue to vote on the proposal and party hosts can veto at this time.
49	        Passed,
50	        // Same as `Passed` but now `executionDelay` has been satisfied. Any member
51	        // may execute the proposal via `execute()`, unless `maxExecutableTime`
52	        // has arrived.
53	        Ready,
54	        // The proposal has been executed at least once but has further steps to
55	        // complete so it needs to be executed again. No other proposals may be
56	        // executed while a proposal is in the `InProgress` state. No voting or
57	        // vetoing of the proposal is allowed, however it may be forcibly cancelled
58	        // via `cancel()` if the `cancelDelay` has passed since being first executed.
59	        InProgress,
60	        // The proposal was executed and completed all its steps. No voting or
61	        // vetoing can occur and it cannot be cancelled nor executed again.
62	        Complete,
63	        // The proposal was executed at least once but did not complete before
64	        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.
65	        Cancelled
66	    }
67	
68	    struct GovernanceOpts {
69	        // Address of initial party hosts.
70	        address[] hosts;
71	        // How long people can vote on a proposal.
72	        uint40 voteDuration;
73	        // How long to wait after a proposal passes before it can be
74	        // executed.
75	        uint40 executionDelay;
76	        // Minimum ratio of accept votes to consider a proposal passed,
77	        // in bps, where 10,000 == 100%.
78	        uint16 passThresholdBps;
79	        // Total voting power of governance NFTs.
80	        uint96 totalVotingPower;
81	        // Fee bps for distributions.
82	        uint16 feeBps;
83	        // Fee recipeint for distributions.
84	        address payable feeRecipient;
85	    }
86	
87	    // A snapshot of voting power for a member.
88	    struct VotingPowerSnapshot {
89	        // The timestamp when the snapshot was taken.
90	        uint40 timestamp;
91	        // Voting power that was delegated to this user by others.
92	        uint96 delegatedVotingPower;
93	        // The intrinsic (not delegated from someone else) voting power of this user.
94	        uint96 intrinsicVotingPower;
95	        // Whether the user was delegated to another at this snapshot.
96	        bool isDelegated;
97	    }
98	
99	    // Proposal details chosen by proposer.
100	    struct Proposal {
101	        // Time beyond which the proposal can no longer be executed.
102	        // If the proposal has already been executed, and is still InProgress,
103	        // this value is ignored.
104	        uint40 maxExecutableTime;
105	        // The minimum seconds this proposal can remain in the InProgress status
106	        // before it can be cancelled.
107	        uint40 cancelDelay;
108	        // Encoded proposal data. The first 4 bytes are the proposal type, followed
109	        // by encoded proposal args specific to the proposal type. See
110	        // ProposalExecutionEngine for details.
111	        bytes proposalData;
112	    }
113	
114	    // Accounting and state tracking values for a proposal.
115	    struct ProposalStateValues {
116	        // When the proposal was proposed.
117	        uint40 proposedTime;
118	        // When the proposal passed the vote.
119	        uint40 passedTime;
120	        // When the proposal was first executed.
121	        uint40 executedTime;
122	        // When the proposal completed.
123	        uint40 completedTime;
124	        // Number of accept votes.
125	        uint96 votes; // -1 == vetoed
126	        // Number of total voting power at time proposal created.
127	        uint96 totalVotingPower;
128	        /// @notice Number of hosts at time proposal created
129	        uint8 numHosts;
130	        /// @notice Number of hosts that accepted proposal
131	        uint8 numHostsAccepted;
132	    }
133	
134	    // Storage states for a proposal.
135	    struct ProposalState {
136	        // Accounting and state tracking values.
137	        ProposalStateValues values;
138	        // Hash of the proposal.
139	        bytes32 hash;
140	        // Whether a member has voted for (accepted) this proposal already.
141	        mapping(address => bool) hasVoted;
142	    }
143	
144	    event Proposed(uint256 proposalId, address proposer, Proposal proposal);
145	    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);
146	    event EmergencyExecute(address target, bytes data, uint256 amountEth);
147	
148	    event ProposalPassed(uint256 indexed proposalId);
149	    event ProposalVetoed(uint256 indexed proposalId, address host);
150	    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);
151	    event ProposalCancelled(uint256 indexed proposalId);
152	    event DistributionCreated(
153	        ITokenDistributor.TokenType tokenType,
154	        address token,
155	        uint256 tokenId
156	    );
157	    event PartyDelegateUpdated(address indexed owner, address indexed delegate);
158	    event HostStatusTransferred(address oldHost, address newHost);
159	    event EmergencyExecuteDisabled();
160	    event PartyVotingSnapshotCreated(
161	        address indexed voter,
162	        uint40 timestamp,
163	        uint96 delegatedVotingPower,
164	        uint96 intrinsicVotingPower,
165	        bool isDelegated
166	    );
167	
168	    error MismatchedPreciousListLengths();
169	    error BadProposalStatusError(ProposalStatus status);
170	    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);
171	    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);
172	    error NotAuthorized();
173	    error InvalidDelegateError();
174	    error BadPreciousListError();
175	    error OnlyWhenEmergencyActionsAllowedError();
176	    error OnlyWhenEnabledError();
177	    error AlreadyVotedError(address voter);
178	    error InvalidNewHostError();
179	    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);
180	    error InvalidBpsError(uint16 bps);
181	    error DistributionsRequireVoteError();
182	    error PartyNotStartedError();
183	    error CannotRageQuitAndAcceptError();
184	    error TooManyHosts();
185	
186	    uint256 private constant UINT40_HIGH_BIT = 1 << 39;
187	    uint96 private constant VETO_VALUE = type(uint96).max;
188	
189	    // The `Globals` contract storing global configuration values. This contract
190	    // is immutable and it’s address will never change.
191	    IGlobals private immutable _GLOBALS;
192	
193	    /// @notice Whether the DAO has emergency powers for this party.
194	    bool public emergencyExecuteDisabled;
195	    /// @notice Distribution fee bps.
196	    uint16 public feeBps;
197	    /// @notice Distribution fee recipient.
198	    address payable public feeRecipient;
199	    /// @notice The timestamp of the last time `rageQuit()` was called.
200	    uint40 public lastRageQuitTimestamp;
201	    /// @notice The hash of the list of precious NFTs guarded by the party.
202	    bytes32 public preciousListHash;
203	    /// @notice The last proposal ID that was used. 0 means no proposals have been made.
204	    uint256 public lastProposalId;
205	    /// @notice Whether an address is a party host.
206	    mapping(address => bool) public isHost;
207	    /// @notice The last person a voter delegated its voting power to.
208	    mapping(address => address) public delegationsByVoter;
209	    /// @notice Number of hosts for this party
210	    uint8 public numHosts;
211	    /// @notice ProposalState by proposal ID.
212	    mapping(uint256 => ProposalState) private _proposalStateByProposalId;
213	    /// @notice Snapshots of voting power per user, each sorted by increasing time.
214	    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;
215	
216	    function _assertHost() internal view {
217	        if (!isHost[msg.sender]) {
218	            revert NotAuthorized();
219	        }
220	    }
221	
222	    function _assertActiveMember() internal view {
223	        VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
224	        // Must have either delegated voting power or intrinsic voting power.
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
226	            revert NotAuthorized();
227	        }
228	    }
229	
230	    // Only the party DAO multisig can call.
231	    modifier onlyPartyDao() {
232	        {
233	            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
234	            if (msg.sender != partyDao) {
235	                revert NotAuthorized();
236	            }
237	        }
238	        _;
239	    }
240	
241	    // Only the party DAO multisig or a party host can call.
242	    modifier onlyPartyDaoOrHost() {
243	        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
244	        if (msg.sender != partyDao && !isHost[msg.sender]) {
245	            revert NotAuthorized();
246	        }
247	        _;
248	    }
249	
250	    // Only if `emergencyExecuteDisabled` is not true.
251	    modifier onlyWhenEmergencyExecuteAllowed() {
252	        if (emergencyExecuteDisabled) {
253	            revert OnlyWhenEmergencyActionsAllowedError();
254	        }
255	        _;
256	    }
257	
258	    function _assertNotGloballyDisabled() internal view {
259	        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {
260	            revert OnlyWhenEnabledError();
261	        }
262	    }
263	
264	    // Set the `Globals` contract.
265	    constructor(IGlobals globals) {
266	        _GLOBALS = globals;
267	    }
268	
269	    // Initialize storage for proxy contracts and initialize the proposal execution engine.
270	    function _initialize(
271	        GovernanceOpts memory govOpts,
272	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
273	        IERC721[] memory preciousTokens,
274	        uint256[] memory preciousTokenIds
275	    ) internal virtual {
276	        // Check BPS are valid.
277	        if (govOpts.feeBps > 1e4) {
278	            revert InvalidBpsError(govOpts.feeBps);
279	        }
280	        if (govOpts.passThresholdBps > 1e4) {
281	            revert InvalidBpsError(govOpts.passThresholdBps);
282	        }
283	        // Initialize the proposal execution engine.
284	        _initProposalImpl(
285	            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),
286	            abi.encode(proposalEngineOpts)
287	        );
288	        // Set the governance parameters.
289	        _getSharedProposalStorage().governanceValues = GovernanceValues({
290	            voteDuration: govOpts.voteDuration,
291	            executionDelay: govOpts.executionDelay,
292	            passThresholdBps: govOpts.passThresholdBps,
293	            totalVotingPower: govOpts.totalVotingPower
294	        });
295	        numHosts = uint8(govOpts.hosts.length);
296	        // Set fees.
297	        feeBps = govOpts.feeBps;
298	        feeRecipient = govOpts.feeRecipient;
299	        // Set the precious list.
300	        _setPreciousList(preciousTokens, preciousTokenIds);
301	        // Set the party hosts.
302	        if (govOpts.hosts.length > type(uint8).max) {
303	            revert TooManyHosts();
304	        }
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
309	
310	    /// @dev Forward all unknown read-only calls to the proposal execution engine.
311	    ///      Initial use case is to facilitate eip-1271 signatures.
312	    fallback() external {
313	        bytes4 functionSelector = bytes4(msg.data[0:4]);
314	        if (
315	            functionSelector == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector ||
316	            functionSelector == ERC1155TokenReceiverBase.onERC1155Received.selector ||
317	            functionSelector == IERC721Receiver.onERC721Received.selector
318	        ) {
319	            assembly {
320	                let freeMem := mload(0x40)
321	                mstore(freeMem, functionSelector)
322	                mstore(0x40, add(freeMem, 0x20))
323	                return(freeMem, 0x20)
324	            }
325	        }
326	        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);
327	    }
328	
329	    /// @notice Query if a contract implements an interface.
330	    /// @param interfaceId The interface identifier, as specified in ERC-165
331	    /// @return `true` if the contract implements `interfaceId` and
332	    ///         `interfaceId` is not 0xffffffff, `false` otherwise
333	    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {
334	        return
335	            interfaceId == type(IERC721Receiver).interfaceId ||
336	            interfaceId == type(ERC1155TokenReceiverBase).interfaceId ||
337	            // ERC4906 interface ID
338	            interfaceId == 0x49064906;
339	    }
340	
341	    /// @notice Get the current `ProposalExecutionEngine` instance.
342	    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {
343	        return _getSharedProposalStorage().engineImpl;
344	    }
345	
346	    /// @notice Get the current `ProposalEngineOpts` options.
347	    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {
348	        return _getSharedProposalStorage().opts;
349	    }
350	
351	    /// @notice Get the total voting power of `voter` at a `timestamp`.
352	    /// @param voter The address of the voter.
353	    /// @param timestamp The timestamp to get the voting power at.
354	    /// @return votingPower The total voting power of `voter` at `timestamp`.
355	    function getVotingPowerAt(
356	        address voter,
357	        uint40 timestamp
358	    ) external view returns (uint96 votingPower) {
359	        return getVotingPowerAt(voter, timestamp, type(uint256).max);
360	    }
361	
362	    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to
363	    ///         make sure it is the latest voting snapshot =< `timestamp`.
364	    /// @param voter The address of the voter.
365	    /// @param timestamp The timestamp to get the voting power at.
366	    /// @param snapIndex The index of the snapshot to get the voting power at.
367	    /// @return votingPower The total voting power of `voter` at `timestamp`.
368	    function getVotingPowerAt(
369	        address voter,
370	        uint40 timestamp,
371	        uint256 snapIndex
372	    ) public view returns (uint96 votingPower) {
373	        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);
374	        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;
375	    }
376	
377	    /// @notice Get the state of a proposal.
378	    /// @param proposalId The ID of the proposal.
379	    /// @return status The status of the proposal.
380	    /// @return values The state of the proposal.
381	    function getProposalStateInfo(
382	        uint256 proposalId
383	    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {
384	        values = _proposalStateByProposalId[proposalId].values;
385	        status = _getProposalStatus(values);
386	    }
387	
388	    /// @notice Retrieve fixed governance parameters.
389	    /// @return gv The governance parameters of this party.
390	    function getGovernanceValues() external view returns (GovernanceValues memory) {
391	        return _getSharedProposalStorage().governanceValues;
392	    }
393	
394	    /// @notice Get the hash of a proposal.
395	    /// @dev Proposal details are not stored on-chain so the hash is used to enforce
396	    ///      consistency between calls.
397	    /// @param proposal The proposal to hash.
398	    /// @return proposalHash The hash of the proposal.
399	    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {
400	        // Hash the proposal in-place. Equivalent to:
401	        // keccak256(abi.encode(
402	        //   proposal.maxExecutableTime,
403	        //   proposal.cancelDelay,
404	        //   keccak256(proposal.proposalData)
405	        // ))
406	        bytes32 dataHash = keccak256(proposal.proposalData);
407	        assembly {
408	            // Overwrite the data field with the hash of its contents and then
409	            // hash the struct.
410	            let dataPos := add(proposal, 0x40)
411	            let t := mload(dataPos)
412	            mstore(dataPos, dataHash)
413	            proposalHash := keccak256(proposal, 0x60)
414	            // Restore the data field.
415	            mstore(dataPos, t)
416	        }
417	    }
418	
419	    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.
420	    /// @param voter The address of the voter.
421	    /// @param timestamp The timestamp to get the snapshot index at.
422	    /// @return index The index of the snapshot.
423	    function findVotingPowerSnapshotIndex(
424	        address voter,
425	        uint40 timestamp
426	    ) public view returns (uint256 index) {
427	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
428	
429	        // Derived from Open Zeppelin binary search
430	        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39
431	        uint256 high = snaps.length;
432	        uint256 low = 0;
433	        while (low < high) {
434	            uint256 mid = (low + high) / 2;
435	            if (snaps[mid].timestamp > timestamp) {
436	                // Entry is too recent.
437	                high = mid;
438	            } else {
439	                // Entry is older. This is our best guess for now.
440	                low = mid + 1;
441	            }
442	        }
443	
444	        // Return `type(uint256).max` if no valid voting snapshots found.
445	        return high == 0 ? type(uint256).max : high - 1;
446	    }
447	
448	    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from
449	    ///         the old one (if any).
450	    /// @param delegate The address to delegating voting power to.
451	    function delegateVotingPower(address delegate) external {
452	        _adjustVotingPower(msg.sender, 0, delegate);
453	    }
454	
455	    /// @notice Transfer party host status to another.
456	    /// @param newPartyHost The address of the new host.
457	    function abdicateHost(address newPartyHost) external {
458	        _assertHost();
459	        // 0 is a special case burn address.
460	        if (newPartyHost != address(0)) {
461	            // Cannot transfer host status to an existing host.
462	            if (isHost[newPartyHost]) {
463	                revert InvalidNewHostError();
464	            }
465	            isHost[newPartyHost] = true;
466	        } else {
467	            // Burned the host status
468	            --numHosts;
469	        }
470	        isHost[msg.sender] = false;
471	        emit HostStatusTransferred(msg.sender, newPartyHost);
472	    }
473	
474	    /// @notice Create a token distribution by moving the party's entire balance
475	    ///         to the `TokenDistributor` contract and immediately creating a
476	    ///         distribution governed by this party.
477	    /// @dev The `feeBps` and `feeRecipient` this party was created with will be
478	    ///      propagated to the distribution. Party members are entitled to a
479	    ///      share of the distribution's tokens proportionate to their relative
480	    ///      voting power in this party (less the fee).
481	    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.
482	    /// @param tokenType The type of token to distribute.
483	    /// @param token The address of the token to distribute.
484	    /// @param tokenId The ID of the token to distribute. Currently unused but
485	    ///                may be used in the future to support other distribution types.
486	    /// @return distInfo The information about the created distribution.
487	    function distribute(
488	        uint256 amount,
489	        ITokenDistributor.TokenType tokenType,
490	        address token,
491	        uint256 tokenId
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
493	        _assertNotGloballyDisabled();
494	        // Ignore if the party is calling functions on itself, like with
495	        // `FractionalizeProposal` and `DistributionProposal`.
496	        if (msg.sender != address(this)) {
497	            // Must not require a vote to create a distribution, otherwise
498	            // distributions can only be created through a distribution
499	            // proposal.
500	            if (_getSharedProposalStorage().opts.distributionsRequireVote) {
501	                revert DistributionsRequireVoteError();
502	            }
503	            // Must be an active member.
504	            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
509	        // Prevent creating a distribution if the party has not started.
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
511	            revert PartyNotStartedError();
512	        }
513	        // Get the address of the token distributor.
514	        ITokenDistributor distributor = ITokenDistributor(
515	            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)
516	        );
517	        emit DistributionCreated(tokenType, token, tokenId);
518	        // Notify third-party platforms that the governance NFT metadata has
519	        // updated for all tokens.
520	        emit BatchMetadataUpdate(0, type(uint256).max);
521	        // Create a native token distribution.
522	        address payable feeRecipient_ = feeRecipient;
523	        uint16 feeBps_ = feeBps;
524	        if (tokenType == ITokenDistributor.TokenType.Native) {
525	            return
526	                distributor.createNativeDistribution{ value: amount }(
527	                    Party(payable(address(this))),
528	                    feeRecipient_,
529	                    feeBps_
530	                );
531	        }
532	        // Otherwise must be an ERC20 token distribution.
533	        assert(tokenType == ITokenDistributor.TokenType.Erc20);
534	        IERC20(token).compatTransfer(address(distributor), amount);
535	        return
536	            distributor.createErc20Distribution(
537	                IERC20(token),
538	                Party(payable(address(this))),
539	                feeRecipient_,
540	                feeBps_
541	            );
542	    }
543	
544	    /// @notice Make a proposal for members to vote on and cast a vote to accept it
545	    ///         as well.
546	    /// @dev Only an active member (has voting power) can call this.
547	    ///      Afterwards, members can vote to support it with `accept()` or a party
548	    ///      host can unilaterally reject the proposal with `veto()`.
549	    /// @param proposal The details of the proposal.
550	    /// @param latestSnapIndex The index of the caller's most recent voting power
551	    ///                        snapshot before the proposal was created. Should
552	    ///                        be retrieved off-chain and passed in.
553	    function propose(
554	        Proposal memory proposal,
555	        uint256 latestSnapIndex
556	    ) external returns (uint256 proposalId) {
557	        _assertActiveMember();
558	        proposalId = ++lastProposalId;
559	        // Store the time the proposal was created and the proposal hash.
560	        (
561	            _proposalStateByProposalId[proposalId].values,
562	            _proposalStateByProposalId[proposalId].hash
563	        ) = (
564	            ProposalStateValues({
565	                proposedTime: uint40(block.timestamp),
566	                passedTime: 0,
567	                executedTime: 0,
568	                completedTime: 0,
569	                votes: 0,
570	                totalVotingPower: _getSharedProposalStorage().governanceValues.totalVotingPower,
571	                numHosts: numHosts,
572	                numHostsAccepted: 0
573	            }),
574	            getProposalHash(proposal)
575	        );
576	        emit Proposed(proposalId, msg.sender, proposal);
577	        accept(proposalId, latestSnapIndex);
578	
579	        // Notify third-party platforms that the governance NFT metadata has
580	        // updated for all tokens.
581	        emit BatchMetadataUpdate(0, type(uint256).max);
582	    }
583	
584	    /// @notice Vote to support a proposed proposal.
585	    /// @dev The voting power cast will be the effective voting power of the caller
586	    ///      just before `propose()` was called (see `getVotingPowerAt()`).
587	    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the
588	    ///      proposal will be in the `Passed` state and will be executable after
589	    ///      the `executionDelay` has passed, putting it in the `Ready` state.
590	    /// @param proposalId The ID of the proposal to accept.
591	    /// @param snapIndex The index of the caller's last voting power snapshot
592	    ///                  before the proposal was created. Should be retrieved
593	    ///                  off-chain and passed in.
594	    /// @return totalVotes The total votes cast on the proposal.
595	    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {
596	        // Get the information about the proposal.
597	        ProposalState storage info = _proposalStateByProposalId[proposalId];
598	        ProposalStateValues memory values = info.values;
599	
600	        // Can only vote in certain proposal statuses.
601	        {
602	            ProposalStatus status = _getProposalStatus(values);
603	            // Allow voting even if the proposal is passed/ready so it can
604	            // potentially reach 100% consensus, which unlocks special
605	            // behaviors for certain proposal types.
606	            if (
607	                status != ProposalStatus.Voting &&
608	                status != ProposalStatus.Passed &&
609	                status != ProposalStatus.Ready
610	            ) {
611	                revert BadProposalStatusError(status);
612	            }
613	        }
614	
615	        // Prevent voting in the same block as the last rage quit timestamp.
616	        // This is to prevent an exploit where a member can rage quit to reduce
617	        // the total voting power of the party, then propose and vote in the
618	        // same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.
619	        // This would allow them to use the voting power snapshot just before
620	        // their card was burned to vote, potentially passing a proposal that
621	        // would have otherwise not passed.
622	        if (lastRageQuitTimestamp == block.timestamp) {
623	            revert CannotRageQuitAndAcceptError();
624	        }
625	
626	        // Cannot vote twice.
627	        if (info.hasVoted[msg.sender]) {
628	            revert AlreadyVotedError(msg.sender);
629	        }
630	        // Mark the caller as having voted.
631	        info.hasVoted[msg.sender] = true;
632	
633	        // Increase the total votes that have been cast on this proposal.
634	        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);
635	        values.votes += votingPower;
636	        if (isHost[msg.sender]) {
637	            ++values.numHostsAccepted;
638	        }
639	        info.values = values;
640	        emit ProposalAccepted(proposalId, msg.sender, votingPower);
641	
642	        // Update the proposal status if it has reached the pass threshold.
643	        if (
644	            values.passedTime == 0 &&
645	            _areVotesPassing(
646	                values.votes,
647	                values.totalVotingPower,
648	                _getSharedProposalStorage().governanceValues.passThresholdBps
649	            )
650	        ) {
651	            info.values.passedTime = uint40(block.timestamp);
652	            emit ProposalPassed(proposalId);
653	            // Notify third-party platforms that the governance NFT metadata has
654	            // updated for all tokens.
655	            emit BatchMetadataUpdate(0, type(uint256).max);
656	        }
657	        return values.votes;
658	    }
659	
660	    /// @notice As a party host, veto a proposal, unilaterally rejecting it.
661	    /// @dev The proposal will never be executable and cannot be voted on anymore.
662	    ///      A proposal that has been already executed at least once (in the `InProgress` status)
663	    ///      cannot be vetoed.
664	    /// @param proposalId The ID of the proposal to veto.
665	    function veto(uint256 proposalId) external {
666	        _assertHost();
667	        // Setting `votes` to -1 indicates a veto.
668	        ProposalState storage info = _proposalStateByProposalId[proposalId];
669	        ProposalStateValues memory values = info.values;
670	
671	        {
672	            ProposalStatus status = _getProposalStatus(values);
673	            // Proposal must be in one of the following states.
674	            if (
675	                status != ProposalStatus.Voting &&
676	                status != ProposalStatus.Passed &&
677	                status != ProposalStatus.Ready
678	            ) {
679	                revert BadProposalStatusError(status);
680	            }
681	        }
682	
683	        // -1 indicates veto.
684	        info.values.votes = VETO_VALUE;
685	        emit ProposalVetoed(proposalId, msg.sender);
686	        // Notify third-party platforms that the governance NFT metadata has
687	        // updated for all tokens.
688	        emit BatchMetadataUpdate(0, type(uint256).max);
689	    }
690	
691	    /// @notice Executes a proposal that has passed governance.
692	    /// @dev The proposal must be in the `Ready` or `InProgress` status.
693	    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`
694	    ///      if the proposal has extra steps (must be executed again) to carry out,
695	    ///      in which case `nextProgressData` should be passed into the next `execute()` call.
696	    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal
697	    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`
698	    ///      in order to execute a different proposal.
699	    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.
700	    /// @param proposalId The ID of the proposal to execute.
701	    /// @param proposal The details of the proposal.
702	    /// @param preciousTokens The tokens that the party considers precious.
703	    /// @param preciousTokenIds The token IDs associated with each precious token.
704	    /// @param progressData The data returned from the last `execute()` call, if any.
705	    /// @param extraData Off-chain data a proposal might need to execute a step.
706	    function execute(
707	        uint256 proposalId,
708	        Proposal memory proposal,
709	        IERC721[] memory preciousTokens,
710	        uint256[] memory preciousTokenIds,
711	        bytes calldata progressData,
712	        bytes calldata extraData
713	    ) external payable {
714	        _assertNotGloballyDisabled();
715	        _assertActiveMember();
716	        // Get information about the proposal.
717	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
718	        // Proposal details must remain the same from `propose()`.
719	        _validateProposalHash(proposal, proposalState.hash);
720	        ProposalStateValues memory values = proposalState.values;
721	        ProposalStatus status = _getProposalStatus(values);
722	        // The proposal must be executable or have already been executed but still
723	        // has more steps to go.
724	        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {
725	            revert BadProposalStatusError(status);
726	        }
727	        if (status == ProposalStatus.Ready) {
728	            // If the proposal has not been executed yet, make sure it hasn't
729	            // expired. Note that proposals that have been executed
730	            // (but still have more steps) ignore `maxExecutableTime`.
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
738	        }
739	        // Check that the precious list is valid.
740	        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {
741	            revert BadPreciousListError();
742	        }
743	        // Preemptively set the proposal to completed to avoid it being executed
744	        // again in a deeper call.
745	        proposalState.values.completedTime = uint40(block.timestamp);
746	        // Execute the proposal.
747	        bool completed = _executeProposal(
748	            proposalId,
749	            proposal,
750	            preciousTokens,
751	            preciousTokenIds,
752	            _getProposalFlags(values),
753	            progressData,
754	            extraData
755	        );
756	        if (!completed) {
757	            // Proposal did not complete.
758	            proposalState.values.completedTime = 0;
759	        }
760	    }
761	
762	    /// @notice Cancel a (probably stuck) InProgress proposal.
763	    /// @dev `proposal.cancelDelay` seconds must have passed since it was first
764	    ///      executed for this to be valid. The currently active proposal will
765	    ///      simply be yeeted out of existence so another proposal can execute.
766	    ///      This is intended to be a last resort and can leave the party in a
767	    ///      broken state. Whenever possible, active proposals should be
768	    ///      allowed to complete their lifecycle.
769	    /// @param proposalId The ID of the proposal to cancel.
770	    /// @param proposal The details of the proposal to cancel.
771	    function cancel(uint256 proposalId, Proposal calldata proposal) external {
772	        _assertActiveMember();
773	        // Get information about the proposal.
774	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
775	        // Proposal details must remain the same from `propose()`.
776	        _validateProposalHash(proposal, proposalState.hash);
777	        ProposalStateValues memory values = proposalState.values;
778	        {
779	            // Must be `InProgress`.
780	            ProposalStatus status = _getProposalStatus(values);
781	            if (status != ProposalStatus.InProgress) {
782	                revert BadProposalStatusError(status);
783	            }
784	        }
785	        {
786	            // Limit the `cancelDelay` to the global max and min cancel delay
787	            // to mitigate parties accidentally getting stuck forever by setting an
788	            // unrealistic `cancelDelay` or being reckless with too low a
789	            // cancel delay.
790	            uint256 cancelDelay = proposal.cancelDelay;
791	            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(
792	                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION
793	            );
794	            uint256 globalMinCancelDelay = _GLOBALS.getUint256(
795	                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION
796	            );
797	            if (globalMaxCancelDelay != 0) {
798	                // Only if we have one set.
799	                if (cancelDelay > globalMaxCancelDelay) {
800	                    cancelDelay = globalMaxCancelDelay;
801	                }
802	            }
803	            if (globalMinCancelDelay != 0) {
804	                // Only if we have one set.
805	                if (cancelDelay < globalMinCancelDelay) {
806	                    cancelDelay = globalMinCancelDelay;
807	                }
808	            }
809	            uint256 cancelTime = values.executedTime + cancelDelay;
810	            // Must not be too early.
811	            if (block.timestamp < cancelTime) {
812	                revert ProposalCannotBeCancelledYetError(
813	                    uint40(block.timestamp),
814	                    uint40(cancelTime)
815	                );
816	            }
817	        }
818	        // Mark the proposal as cancelled by setting the completed time to the current
819	        // time with the high bit set.
820	        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);
821	        {
822	            // Delegatecall into the proposal engine impl to perform the cancel.
823	            (bool success, bytes memory resultData) = (
824	                address(_getSharedProposalStorage().engineImpl)
825	            ).delegatecall(abi.encodeCall(IProposalExecutionEngine.cancelProposal, (proposalId)));
826	            if (!success) {
827	                resultData.rawRevert();
828	            }
829	        }
830	        emit ProposalCancelled(proposalId);
831	        // Notify third-party platforms that the governance NFT metadata has
832	        // updated for all tokens.
833	        emit BatchMetadataUpdate(0, type(uint256).max);
834	    }
835	
836	    /// @notice As the DAO, execute an arbitrary function call from this contract.
837	    /// @dev Emergency actions must not be revoked for this to work.
838	    /// @param targetAddress The contract to call.
839	    /// @param targetCallData The data to pass to the contract.
840	    /// @param amountEth The amount of ETH to send to the contract.
841	    function emergencyExecute(
842	        address targetAddress,
843	        bytes calldata targetCallData,
844	        uint256 amountEth
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
846	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
847	        if (!success) {
848	            res.rawRevert();
849	        }
850	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
851	    }
852	
853	    /// @notice Revoke the DAO's ability to call emergencyExecute().
854	    /// @dev Either the DAO or the party host can call this.
855	    function disableEmergencyExecute() external onlyPartyDaoOrHost {
856	        emergencyExecuteDisabled = true;
857	        emit EmergencyExecuteDisabled();
858	    }
859	
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
903	    // Get the most recent voting power snapshot <= timestamp using `hintindex` as a "hint".
904	    function _getVotingPowerSnapshotAt(
905	        address voter,
906	        uint40 timestamp,
907	        uint256 hintIndex
908	    ) internal view returns (VotingPowerSnapshot memory snap) {
909	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
910	        uint256 snapsLength = snaps.length;
911	        if (snapsLength != 0) {
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
923	            // Hint was wrong, fallback to binary search to find snapshot.
924	            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);
925	            // Check that snapshot was found.
926	            if (hintIndex != type(uint256).max) {
927	                return snaps[hintIndex];
928	            }
929	        }
930	
931	        // No snapshot found.
932	        return snap;
933	    }
934	
935	    // Transfers some voting power of `from` to `to`. The total voting power of
936	    // their respective delegates will be updated as well.
937	    function _transferVotingPower(address from, address to, uint256 power) internal {
938	        int192 powerI192 = power.safeCastUint256ToInt192();
939	        _adjustVotingPower(from, -powerI192, address(0));
940	        _adjustVotingPower(to, powerI192, address(0));
941	    }
942	
943	    // Increase `voter`'s intrinsic voting power and update their delegate if delegate is nonzero.
944	    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {
945	        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);
946	        address oldDelegate = delegationsByVoter[voter];
947	        // If `oldDelegate` is zero and `voter` never delegated, then have
948	        // `voter` delegate to themself.
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
950	        // If the new `delegate` is zero, use the current (old) delegate.
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
952	
953	        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({
954	            timestamp: uint40(block.timestamp),
955	            delegatedVotingPower: oldSnap.delegatedVotingPower,
956	            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +
957	                votingPower).safeCastInt192ToUint96(),
958	            isDelegated: delegate != voter
959	        });
960	        _insertVotingPowerSnapshot(voter, newSnap);
961	        delegationsByVoter[voter] = delegate;
962	
963	        // This event is emitted even if the delegate did not change.
964	        emit PartyDelegateUpdated(voter, delegate);
965	
966	        // Handle rebalancing delegates.
967	        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);
968	    }
969	
970	    // Update the delegated voting power of the old and new delegates delegated to
971	    // by `voter` based on the snapshot change.
972	    function _rebalanceDelegates(
973	        address voter,
974	        address oldDelegate,
975	        address newDelegate,
976	        VotingPowerSnapshot memory oldSnap,
977	        VotingPowerSnapshot memory newSnap
978	    ) private {
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
980	            revert InvalidDelegateError();
981	        }
982	        if (oldDelegate != voter && oldDelegate != newDelegate) {
983	            // Remove past voting power from old delegate.
984	            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(
985	                oldDelegate
986	            );
987	            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({
988	                timestamp: uint40(block.timestamp),
989	                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -
990	                    oldSnap.intrinsicVotingPower,
991	                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,
992	                isDelegated: oldDelegateSnap.isDelegated
993	            });
994	            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);
995	        }
996	        if (newDelegate != voter) {
997	            // Not delegating to self.
998	            // Add new voting power to new delegate.
999	            VotingPowerSnapshot memory newDelegateSnap = _getLastVotingPowerSnapshotForVoter(
1000	                newDelegate
1001	            );
1002	            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +
1003	                newSnap.intrinsicVotingPower;
1004	            if (newDelegate == oldDelegate) {
1005	                // If the old and new delegate are the same, subtract the old
1006	                // intrinsic voting power of the voter, or else we will double
1007	                // count a portion of it.
1008	                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;
1009	            }
1010	            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({
1011	                timestamp: uint40(block.timestamp),
1012	                delegatedVotingPower: newDelegateDelegatedVotingPower,
1013	                intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,
1014	                isDelegated: newDelegateSnap.isDelegated
1015	            });
1016	            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);
1017	        }
1018	    }
1019	
1020	    // Append a new voting power snapshot, overwriting the last one if possible.
1021	    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap) private {
1022	        emit PartyVotingSnapshotCreated(
1023	            voter,
1024	            snap.timestamp,
1025	            snap.delegatedVotingPower,
1026	            snap.intrinsicVotingPower,
1027	            snap.isDelegated
1028	        );
1029	
1030	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1031	        uint256 n = voterSnaps.length;
1032	        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.
1033	        if (n != 0) {
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
1035	            if (lastSnap.timestamp == snap.timestamp) {
1036	                voterSnaps[n - 1] = snap;
1037	                return;
1038	            }
1039	        }
1040	        voterSnaps.push(snap);
1041	    }
1042	
1043	    function _getLastVotingPowerSnapshotForVoter(
1044	        address voter
1045	    ) private view returns (VotingPowerSnapshot memory snap) {
1046	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1047	        uint256 n = voterSnaps.length;
1048	        if (n != 0) {
1049	            snap = voterSnaps[n - 1];
1050	        }
1051	    }
1052	
1053	    function _getProposalFlags(ProposalStateValues memory pv) private pure returns (uint256) {
1054	        uint256 flags = 0;
1055	        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1056	            flags = flags | LibProposal.PROPOSAL_FLAG_UNANIMOUS;
1057	        }
1058	        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1059	            flags = flags | LibProposal.PROPOSAL_FLAG_HOSTS_ACCEPT;
1060	        }
1061	        return flags;
1062	    }
1063	
1064	    function _getProposalStatus(
1065	        ProposalStateValues memory pv
1066	    ) private view returns (ProposalStatus status) {
1067	        // Never proposed.
1068	        if (pv.proposedTime == 0) {
1069	            return ProposalStatus.Invalid;
1070	        }
1071	        // Executed at least once.
1072	        if (pv.executedTime != 0) {
1073	            if (pv.completedTime == 0) {
1074	                return ProposalStatus.InProgress;
1075	            }
1076	            // completedTime high bit will be set if cancelled.
1077	            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {
1078	                return ProposalStatus.Cancelled;
1079	            }
1080	            return ProposalStatus.Complete;
1081	        }
1082	        // Vetoed.
1083	        if (pv.votes == type(uint96).max) {
1084	            return ProposalStatus.Defeated;
1085	        }
1086	        uint40 t = uint40(block.timestamp);
1087	        GovernanceValues memory gv = _getSharedProposalStorage().governanceValues;
1088	        if (pv.passedTime != 0) {
1089	            // Ready.
1090	            if (pv.passedTime + gv.executionDelay <= t) {
1091	                return ProposalStatus.Ready;
1092	            }
1093	            // If unanimous, we skip the execution delay.
1094	            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1095	                return ProposalStatus.Ready;
1096	            }
1097	            // If all hosts voted, skip execution delay
1098	            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1099	                return ProposalStatus.Ready;
1100	            }
1101	            // Passed.
1102	            return ProposalStatus.Passed;
1103	        }
1104	        // Voting window expired.
1105	        if (pv.proposedTime + gv.voteDuration <= t) {
1106	            return ProposalStatus.Defeated;
1107	        }
1108	        return ProposalStatus.Voting;
1109	    }
1110	
1111	    function _isUnanimousVotes(
1112	        uint96 totalVotes,
1113	        uint96 totalVotingPower
1114	    ) private pure returns (bool) {
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
1116	        // If >= 99.99% acceptance, consider it unanimous.
1117	        // The minting formula for voting power is a bit lossy, so we check
1118	        // for slightly less than 100%.
1119	        return acceptanceRatio >= 0.9999e4;
1120	    }
1121	
1122	    function _hostsAccepted(
1123	        uint8 snapshotNumHosts,
1124	        uint8 numHostsAccepted
1125	    ) private pure returns (bool) {
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
1127	    }
1128	
1129	    function _areVotesPassing(
1130	        uint96 voteCount,
1131	        uint96 totalVotingPower,
1132	        uint16 passThresholdBps
1133	    ) private pure returns (bool) {
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
1135	    }
1136	
1137	    function _setPreciousList(
1138	        IERC721[] memory preciousTokens,
1139	        uint256[] memory preciousTokenIds
1140	    ) private {
1141	        if (preciousTokens.length != preciousTokenIds.length) {
1142	            revert MismatchedPreciousListLengths();
1143	        }
1144	        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);
1145	    }
1146	
1147	    function _isPreciousListCorrect(
1148	        IERC721[] memory preciousTokens,
1149	        uint256[] memory preciousTokenIds
1150	    ) private view returns (bool) {
1151	        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);
1152	    }
1153	
1154	    function _hashPreciousList(
1155	        IERC721[] memory preciousTokens,
1156	        uint256[] memory preciousTokenIds
1157	    ) internal pure returns (bytes32 h) {
1158	        assembly {
1159	            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))
1160	            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))
1161	            h := keccak256(0x00, 0x40)
1162	        }
1163	    }
1164	
1165	    // Assert that the hash of a proposal matches expectedHash.
1166	    function _validateProposalHash(Proposal memory proposal, bytes32 expectedHash) private pure {
1167	        bytes32 actualHash = getProposalHash(proposal);
1168	        if (expectedHash != actualHash) {
1169	            revert BadProposalHashError(actualHash, expectedHash);
1170	        }
1171	    }
1172	}
```
[23..1173](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L23-L1173)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
14	contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {
15	    using LibSafeCast for uint256;
16	    using LibSafeCast for uint96;
17	    using LibERC20Compat for IERC20;
18	    using LibAddress for address payable;
19	
20	    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);
21	    error CannotRageQuitError(uint40 rageQuitTimestamp);
22	    error CannotDisableRageQuitAfterInitializationError();
23	    error InvalidTokenOrderError();
24	    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);
25	    error NothingToBurnError();
26	
27	    event AuthorityAdded(address indexed authority);
28	    event AuthorityRemoved(address indexed authority);
29	    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);
30	    event Burn(address caller, uint256 tokenId, uint256 votingPower);
31	    event RageQuit(address caller, uint256[] tokenIds, IERC20[] withdrawTokens, address receiver);
32	    event PartyCardIntrinsicVotingPowerSet(uint256 indexed tokenId, uint256 intrinsicVotingPower);
33	
34	    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256("ENABLE_RAGEQUIT_PERMANENTLY")))
35	    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256("DISABLE_RAGEQUIT_PERMANENTLY")))
36	
37	    // Token address used to indicate ETH.
38	    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
39	
40	    // The `Globals` contract storing global configuration values. This contract
41	    // is immutable and its address will never change.
42	    IGlobals private immutable _GLOBALS;
43	
44	    /// @notice The number of tokens that have been minted.
45	    uint96 public tokenCount;
46	    /// @notice The total minted voting power.
47	    ///         Capped to `_governanceValues.totalVotingPower` unless minting
48	    ///         party cards for initial crowdfund.
49	    uint96 public mintedVotingPower;
50	    /// @notice The timestamp until which ragequit is enabled. Can be set to the
51	    ///         `ENABLE_RAGEQUIT_PERMANENTLY`/`DISABLE_RAGEQUIT_PERMANENTLY`
52	    ///         values to enable/disable ragequit permanently.
53	    ///         `DISABLE_RAGEQUIT_PERMANENTLY` can only be set during
54	    ///         initialization.
55	    uint40 public rageQuitTimestamp;
56	    /// @notice The voting power of `tokenId`.
57	    mapping(uint256 => uint256) public votingPowerByTokenId;
58	    /// @notice Address with authority to mint cards and update voting power for the party.
59	    mapping(address => bool) public isAuthority;
60	
61	    function _assertAuthority() internal view {
62	        if (!isAuthority[msg.sender]) {
63	            revert NotAuthorized();
64	        }
65	    }
66	
67	    modifier onlySelf() {
68	        if (msg.sender != address(this)) {
69	            revert NotAuthorized();
70	        }
71	        _;
72	    }
73	
74	    // Set the `Globals` contract. The name or symbol of ERC721 does not matter;
75	    // it will be set in `_initialize()`.
76	    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721("", "") {
77	        _GLOBALS = globals;
78	    }
79	
80	    // Initialize storage for proxy contracts.
81	    function _initialize(
82	        string memory name_,
83	        string memory symbol_,
84	        uint256 customizationPresetId,
85	        PartyGovernance.GovernanceOpts memory governanceOpts,
86	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
87	        IERC721[] memory preciousTokens,
88	        uint256[] memory preciousTokenIds,
89	        address[] memory authorities,
90	        uint40 rageQuitTimestamp_
91	    ) internal {
92	        PartyGovernance._initialize(
93	            governanceOpts,
94	            proposalEngineOpts,
95	            preciousTokens,
96	            preciousTokenIds
97	        );
98	        name = name_;
99	        symbol = symbol_;
100	        rageQuitTimestamp = rageQuitTimestamp_;
101	        unchecked {
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
105	        }
106	        if (customizationPresetId != 0) {
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
109	        }
110	    }
111	
112	    /// @inheritdoc EIP165
113	    function supportsInterface(
114	        bytes4 interfaceId
115	    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {
116	        return
117	            PartyGovernance.supportsInterface(interfaceId) ||
118	            ERC721.supportsInterface(interfaceId) ||
119	            interfaceId == type(IERC2981).interfaceId;
120	    }
121	
122	    /// @inheritdoc ERC721
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
127	
128	    /// @notice Returns a URI for the storefront-level metadata for your contract.
129	    function contractURI() external view returns (string memory) {
130	        _delegateToRenderer();
131	        return ""; // Just to make the compiler happy.
132	    }
133	
134	    /// @notice Called with the sale price to determine how much royalty
135	    //          is owed and to whom.
136	    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {
137	        _delegateToRenderer();
138	        return (address(0), 0); // Just to make the compiler happy.
139	    }
140	
141	    /// @notice Return the distribution share amount of a token. Included as an alias
142	    ///         for `votePowerByTokenId` for backwards compatibility with old
143	    ///         `TokenDistributor` implementations.
144	    /// @param tokenId The token ID to query.
145	    /// @return share The distribution shares of `tokenId`.
146	    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {
147	        return votingPowerByTokenId[tokenId];
148	    }
149	
150	    /// @notice Return the voting power share of a token. Denominated
151	    ///         fractions of 1e18. I.e., 1e18 = 100%.
152	    /// @param tokenId The token ID to query.
153	    /// @return share The voting power percentage of `tokenId`.
154	    function getVotingPowerShareOf(uint256 tokenId) public view returns (uint256) {
155	        uint256 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
156	        return
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
158	    }
159	
160	    /// @notice Mint a governance NFT for `owner` with `votingPower` and
161	    ///         immediately delegate voting power to `delegate.` Only callable
162	    ///         by an authority.
163	    /// @param owner The owner of the NFT.
164	    /// @param votingPower The voting power of the NFT.
165	    /// @param delegate The address to delegate voting power to.
166	    function mint(
167	        address owner,
168	        uint256 votingPower,
169	        address delegate
170	    ) external returns (uint256 tokenId) {
171	        _assertAuthority();
172	        uint96 mintedVotingPower_ = mintedVotingPower;
173	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
174	
175	        // Cap voting power to remaining unminted voting power supply.
176	        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();
177	        // Allow minting past total voting power if minting party cards for
178	        // initial crowdfund when there is no total voting power.
179	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {
180	            unchecked {
181	                votingPower_ = totalVotingPower - mintedVotingPower_;
182	            }
183	        }
184	
185	        // Update state.
186	        unchecked {
187	            tokenId = ++tokenCount;
188	        }
189	        mintedVotingPower += votingPower_;
190	        votingPowerByTokenId[tokenId] = votingPower_;
191	
192	        emit PartyCardIntrinsicVotingPowerSet(tokenId, votingPower_);
193	
194	        // Use delegate from party over the one set during crowdfund.
195	        address delegate_ = delegationsByVoter[owner];
196	        if (delegate_ != address(0)) {
197	            delegate = delegate_;
198	        }
199	
200	        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);
201	        _safeMint(owner, tokenId);
202	    }
203	
204	    /// @notice Add voting power to an existing NFT. Only callable by an
205	    ///         authority.
206	    /// @param tokenId The ID of the NFT to add voting power to.
207	    /// @param votingPower The amount of voting power to add.
208	    function increaseVotingPower(uint256 tokenId, uint96 votingPower) external {
209	        _assertAuthority();
210	        uint96 mintedVotingPower_ = mintedVotingPower;
211	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
212	
213	        // Cap voting power to remaining unminted voting power supply. Allow
214	        // minting past total voting power if minting party cards for initial
215	        // crowdfund when there is no total voting power.
216	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {
217	            unchecked {
218	                votingPower = totalVotingPower - mintedVotingPower_;
219	            }
220	        }
221	
222	        // Update state.
223	        mintedVotingPower += votingPower;
224	        uint256 newIntrinsicVotingPower = votingPowerByTokenId[tokenId] + votingPower;
225	        votingPowerByTokenId[tokenId] = newIntrinsicVotingPower;
226	
227	        emit PartyCardIntrinsicVotingPowerSet(tokenId, newIntrinsicVotingPower);
228	
229	        _adjustVotingPower(ownerOf(tokenId), votingPower.safeCastUint96ToInt192(), address(0));
230	    }
231	
232	    /// @notice Remove voting power from an existing NFT. Only callable by an
233	    ///         authority.
234	    /// @param tokenId The ID of the NFT to remove voting power from.
235	    /// @param votingPower The amount of voting power to remove.
236	    function decreaseVotingPower(uint256 tokenId, uint96 votingPower) external {
237	        _assertAuthority();
238	        mintedVotingPower -= votingPower;
239	        votingPowerByTokenId[tokenId] -= votingPower;
240	
241	        _adjustVotingPower(ownerOf(tokenId), -votingPower.safeCastUint96ToInt192(), address(0));
242	    }
243	
244	    /// @notice Increase the total voting power of the party. Only callable by
245	    ///         an authority.
246	    /// @param votingPower The new total voting power to add.
247	    function increaseTotalVotingPower(uint96 votingPower) external {
248	        _assertAuthority();
249	        _getSharedProposalStorage().governanceValues.totalVotingPower += votingPower;
250	    }
251	
252	    /// @notice Decrease the total voting power of the party. Only callable by
253	    ///         an authority.
254	    /// @param votingPower The new total voting power to add.
255	    function decreaseTotalVotingPower(uint96 votingPower) external {
256	        _assertAuthority();
257	        _getSharedProposalStorage().governanceValues.totalVotingPower -= votingPower;
258	    }
259	
260	    /// @notice Burn governance NFTs and remove their voting power. Can only
261	    ///         be called by an authority before the party has started.
262	    /// @param tokenIds The IDs of the governance NFTs to burn.
263	    function burn(uint256[] memory tokenIds) public {
264	        _assertAuthority();
265	        _burnAndUpdateVotingPower(tokenIds, false);
266	    }
267	
268	    function _burnAndUpdateVotingPower(
269	        uint256[] memory tokenIds,
270	        bool checkIfAuthorizedToBurn
271	    ) private returns (uint96 totalVotingPowerBurned) {
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
302	
303	        // Update minted voting power.
304	        mintedVotingPower -= totalVotingPowerBurned;
305	    }
306	
307	    /// @notice Burn governance NFT and remove its voting power. Can only be
308	    ///         called by an authority before the party has started.
309	    /// @param tokenId The ID of the governance NFTs to burn.
310	    function burn(uint256 tokenId) external {
311	        uint256[] memory tokenIds = new uint256[](1);
312	        tokenIds[0] = tokenId;
313	        burn(tokenIds);
314	    }
315	
316	    /// @notice Set the timestamp until which ragequit is enabled.
317	    /// @param newRageQuitTimestamp The new ragequit timestamp.
318	    function setRageQuit(uint40 newRageQuitTimestamp) external {
319	        _assertHost();
320	        // Prevent disabling ragequit after initialization.
321	        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {
322	            revert CannotDisableRageQuitAfterInitializationError();
323	        }
324	
325	        uint40 oldRageQuitTimestamp = rageQuitTimestamp;
326	
327	        // Prevent setting timestamp if it is permanently enabled/disabled.
328	        if (
329	            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||
330	            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY
331	        ) {
332	            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);
333	        }
334	
335	        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);
336	    }
337	
338	    /// @notice Burn a governance NFT and withdraw a fair share of fungible tokens from the party.
339	    /// @param tokenIds The IDs of the governance NFTs to burn.
340	    /// @param withdrawTokens The fungible tokens to withdraw. Specify the
341	    ///                       `ETH_ADDRESS` value to withdraw ETH.
342	    /// @param minWithdrawAmounts The minimum amount of to withdraw for each token.
343	    /// @param receiver The address to receive the withdrawn tokens.
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
449	
450	    /// @inheritdoc ERC721
451	    function transferFrom(address owner, address to, uint256 tokenId) public override {
452	        // Transfer voting along with token.
453	        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);
454	        super.transferFrom(owner, to, tokenId);
455	    }
456	
457	    /// @inheritdoc ERC721
458	    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {
459	        // super.safeTransferFrom() will call transferFrom() first which will
460	        // transfer voting power.
461	        super.safeTransferFrom(owner, to, tokenId);
462	    }
463	
464	    /// @inheritdoc ERC721
465	    function safeTransferFrom(
466	        address owner,
467	        address to,
468	        uint256 tokenId,
469	        bytes calldata data
470	    ) public override {
471	        // super.safeTransferFrom() will call transferFrom() first which will
472	        // transfer voting power.
473	        super.safeTransferFrom(owner, to, tokenId, data);
474	    }
475	
476	    /// @notice Add a new authority.
477	    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add
478	    ///      authorities to prevent it from being used anywhere else.
479	    function addAuthority(address authority) external onlySelf {
480	        isAuthority[authority] = true;
481	
482	        emit AuthorityAdded(authority);
483	    }
484	
485	    /// @notice Relinquish the authority role.
486	    function abdicateAuthority() external {
487	        _assertAuthority();
488	        delete isAuthority[msg.sender];
489	
490	        emit AuthorityRemoved(msg.sender);
491	    }
492	
493	    function _delegateToRenderer() private view {
494	        _readOnlyDelegateCall(
495	            // Instance of IERC721Renderer.
496	            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),
497	            msg.data
498	        );
499	        assert(false); // Will not be reached.
500	    }
501	}
```
[14..501](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L14-L501)


</details>

-------
### [N-39] Events should use parameters to convey information
<a name="N-39"></a>
[To the top](#TOP)

For example, rather than using `event Paused()` and `event Unpaused()`, use `event PauseState(address indexed whoChangedIt, bool wasPaused, bool isNowPaused)`

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 4 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
81	    event Finalized();
...
83	    event EmergencyExecuteDisabled();
```
[81](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L81)
[83](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L83)

---

	 - contracts/party/PartyGovernance.sol

```solidity
159	    event EmergencyExecuteDisabled();
```
[159](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L159)

---

	 - contracts/utils/Implementation.sol

```solidity
6	    event Initialized();
```
[6](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L6)


</details>

-------
### [N-40] Keccak state variables should be immutable not constant
<a name="N-40"></a>
[To the top](#TOP)

Constant keccak variables should be replaced with immutable variables in Solidity contracts to optimize gas usage and enhance efficiency. While constant variables are evaluated and computed at runtime, immutable variables are assigned during contract deployment and stored directly in the contract bytecode. By using immutable for keccak variables, their hash values are computed only once during deployment, reducing the gas cost associated with repeated computations at runtime. This approach leads to more efficient execution, conserving resources for users, and allowing for smoother contract interactions, ultimately benefiting the overall performance and user experience.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 3 instances</summary>


---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
104	    uint256 private constant _STORAGE_SLOT = uint256(keccak256("ProposalExecutionEngine.Storage"));
```
[104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L104)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
40	    uint256 private constant SHARED_STORAGE_SLOT =
41	        uint256(keccak256("ProposalStorage.SharedProposalStorage"));
```
[40..41](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L40-L41)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
13	    uint256 private constant _SET_SIGNATURE_VALIDATOR_PROPOSAL_STORAGE_SLOT =
14	        uint256(keccak256("SetSignatureValidatorProposal.Storage"));
```
[13..14](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L13-L14)


</details>

-------
### [N-41] Events that mark critical parameter changes should contain both the old and the new value
<a name="N-41"></a>
[To the top](#TOP)

This should especially be done if the new value is not required to be different from the old value

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 3 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
157	    event PartyDelegateUpdated(address indexed owner, address indexed delegate);
```
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L157)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
32	    event PartyCardIntrinsicVotingPowerSet(uint256 indexed tokenId, uint256 intrinsicVotingPower);
```
[32](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L32)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
25	    event SignatureValidatorSet(bytes32 indexed hash, IERC1271 indexed signatureValidator);
```
[25](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L25)


</details>

-------
### [N-42] Long functions should be refactored into multiple, smaller, functions
<a name="N-42"></a>
[To the top](#TOP)

META: Emited functions have more than 40 unique statements

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 3 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
```
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
```
[344..448](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L344-L448)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
248	    function _execute(
249	        ProposalType pt,
250	        ExecuteProposalParams memory params
251	    ) internal virtual returns (bytes memory nextProgressData) {
252	        if (pt == ProposalType.ListOnOpensea) {
253	            nextProgressData = _executeListOnOpensea(params);
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
293	
```
[248..293](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L248-L293)


</details>

-------
### [N-43] Named imports of parent contracts are missing
<a name="N-43"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 3 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
9	contract ETHCrowdfundBase is Implementation {
10	    using LibRawResult for bytes;
11	    using LibSafeCast for uint256;
12	    using LibAddress for address payable;
13	
14	    enum CrowdfundLifecycle {
15	        // In practice, this state is never used. If the crowdfund is ever in
16	        // this stage, something is wrong (e.g. crowdfund was never initialized).
17	        Invalid,
18	        // Ready to accept contributions to reach contribution targets
19	        // until a deadline or the minimum contribution target is reached and
20	        // host finalizes.
21	        Active,
22	        // Expired and the minimum contribution target was not reached.
23	        Lost,
24	        // The crowdfund has expired and reached the minimum contribution
25	        // target. It is now ready to finalize.
26	        Won,
27	        // A won crowdfund has been finalized, with funds transferred to the
28	        // party and voting power successfully updated.
29	        Finalized
30	    }
31	
32	    // Options to be passed into `initialize()` when the crowdfund is created.
33	    struct ETHCrowdfundOptions {
34	        Party party;
35	        address payable initialContributor;
36	        address initialDelegate;
37	        uint96 minContribution;
38	        uint96 maxContribution;
39	        bool disableContributingForExistingCard;
40	        uint96 minTotalContributions;
41	        uint96 maxTotalContributions;
42	        uint16 exchangeRateBps;
43	        uint16 fundingSplitBps;
44	        address payable fundingSplitRecipient;
45	        uint40 duration;
46	        IGateKeeper gateKeeper;
47	        bytes12 gateKeeperId;
48	    }
49	
50	    error WrongLifecycleError(CrowdfundLifecycle lc);
51	    error NotAllowedByGateKeeperError(
52	        address contributor,
53	        IGateKeeper gateKeeper,
54	        bytes12 gateKeeperId,
55	        bytes gateData
56	    );
57	    error OnlyPartyHostError();
58	    error OnlyPartyDaoError(address notDao);
59	    error OnlyPartyDaoOrHostError(address notDao);
60	    error NotOwnerError(uint256 tokenId);
61	    error OnlyWhenEmergencyActionsAllowedError();
62	    error InvalidDelegateError();
63	    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);
64	    error MinGreaterThanMaxError(uint96 min, uint96 max);
65	    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);
66	    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);
67	    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);
68	    error InvalidExchangeRateError(uint16 exchangeRateBps);
69	    error ContributingForExistingCardDisabledError();
70	    error ZeroVotingPowerError();
71	    error FundingSplitAlreadyPaidError();
72	    error FundingSplitNotConfiguredError();
73	    error InvalidMessageValue();
74	
75	    event Contributed(
76	        address indexed sender,
77	        address indexed contributor,
78	        uint256 amount,
79	        address delegate
80	    );
81	    event Finalized();
82	    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);
83	    event EmergencyExecuteDisabled();
84	    event EmergencyExecute(address target, bytes data, uint256 amountEth);
85	
86	    // The `Globals` contract storing global configuration values. This contract
87	    // is immutable and it’s address will never change.
88	    IGlobals private immutable _GLOBALS;
89	
90	    /// @notice The address of the `Party` contract instance associated
91	    ///         with the crowdfund.
92	    Party public party;
93	    /// @notice The minimum amount of ETH that a contributor can send to
94	    ///         participate in the crowdfund.
95	    uint96 public minContribution;
96	    /// @notice The maximum amount of ETH that a contributor can send to
97	    ///         participate in the crowdfund per address.
98	    uint96 public maxContribution;
99	    /// @notice A boolean flag that determines whether contributors are allowed
100	    ///         to increase the voting power of their existing party cards.
101	    bool public disableContributingForExistingCard;
102	    /// @notice Whether the funding split has been claimed by the funding split
103	    ///         recipient.
104	    bool public fundingSplitPaid;
105	    /// @notice Whether the DAO has emergency powers for this crowdfund.
106	    bool public emergencyExecuteDisabled;
107	    /// @notice The minimum amount of total ETH contributions required for the
108	    ///         crowdfund to be considered successful.
109	    uint96 public minTotalContributions;
110	    /// @notice The maximum amount of total ETH contributions allowed for the
111	    ///         crowdfund.
112	    uint96 public maxTotalContributions;
113	    /// @notice The total amount of ETH contributed to the crowdfund so far.
114	    uint96 public totalContributions;
115	    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the
116	    ///         crowdfund has finalized.
117	    uint40 public expiry;
118	    /// @notice The exchange rate to use for converting ETH contributions to
119	    ///         voting power in basis points (e.g. 10000 = 1:1).
120	    uint16 public exchangeRateBps;
121	    /// @notice The portion of contributions to send to the funding recipient in
122	    ///         basis points (e.g. 100 = 1%).
123	    uint16 public fundingSplitBps;
124	    /// @notice The address to which a portion of the contributions is sent to.
125	    address payable public fundingSplitRecipient;
126	    /// @notice The gatekeeper contract used to restrict who can contribute to the party.
127	    IGateKeeper public gateKeeper;
128	    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.
129	    bytes12 public gateKeeperId;
130	    /// @notice The address a contributor is delegating their voting power to.
131	    mapping(address => address) public delegationsByContributor;
132	
133	    // Set the `Globals` contract.
134	    constructor(IGlobals globals) {
135	        _GLOBALS = globals;
136	    }
137	
138	    // Initialize storage for proxy contracts, credit initial contribution (if
139	    // any), and setup gatekeeper.
140	    function _initialize(ETHCrowdfundOptions memory opts) internal {
141	        // Set the minimum and maximum contribution amounts.
142	        if (opts.minContribution > opts.maxContribution) {
143	            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);
144	        }
145	        minContribution = opts.minContribution;
146	        maxContribution = opts.maxContribution;
147	        // Set the min total contributions.
148	        if (opts.minTotalContributions > opts.maxTotalContributions) {
149	            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);
150	        }
151	        minTotalContributions = opts.minTotalContributions;
152	        // Set the max total contributions.
153	        if (opts.maxTotalContributions == 0) {
154	            // Prevent this because when `maxTotalContributions` is 0 the
155	            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has
156	            // never been initialized.
157	            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);
158	        }
159	        maxTotalContributions = opts.maxTotalContributions;
160	        // Set the party crowdfund is for.
161	        party = opts.party;
162	        // Set the crowdfund start and end timestamps.
163	        expiry = uint40(block.timestamp + opts.duration);
164	        // Set the exchange rate.
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
166	        exchangeRateBps = opts.exchangeRateBps;
167	        // Set the funding split and its recipient.
168	        fundingSplitBps = opts.fundingSplitBps;
169	        fundingSplitRecipient = opts.fundingSplitRecipient;
170	        // Set whether to disable contributing for existing card.
171	        disableContributingForExistingCard = opts.disableContributingForExistingCard;
172	    }
173	
174	    /// @notice Get the current lifecycle of the crowdfund.
175	    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {
176	        if (maxTotalContributions == 0) {
177	            return CrowdfundLifecycle.Invalid;
178	        }
179	
180	        uint256 expiry_ = expiry;
181	        if (expiry_ == 0) {
182	            return CrowdfundLifecycle.Finalized;
183	        }
184	
185	        if (block.timestamp >= expiry_) {
186	            if (totalContributions >= minTotalContributions) {
187	                return CrowdfundLifecycle.Won;
188	            } else {
189	                return CrowdfundLifecycle.Lost;
190	            }
191	        }
192	
193	        return CrowdfundLifecycle.Active;
194	    }
195	
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
275	    /// @notice Calculate the contribution amount from the given voting power.
276	    /// @param votingPower The voting power to convert to a contribution amount.
277	    /// @return amount The contribution amount.
278	    function convertVotingPowerToContribution(
279	        uint96 votingPower
280	    ) public view returns (uint96 amount) {
281	        amount = (votingPower * 1e4) / exchangeRateBps;
282	
283	        // Add back funding split to contribution amount if applicable.
284	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
285	        uint16 fundingSplitBps_ = fundingSplitBps;
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
288	        }
289	    }
290	
291	    function finalize() external {
292	        uint96 totalContributions_ = totalContributions;
293	
294	        // Check that the crowdfund is not already finalized.
295	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
296	        if (lc == CrowdfundLifecycle.Active) {
297	            // Allow host to finalize crowdfund early if it has reached its minimum goal.
298	            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();
299	
300	            // Check that the crowdfund has reached its minimum goal.
301	            uint96 minTotalContributions_ = minTotalContributions;
302	            if (totalContributions_ < minTotalContributions_) {
303	                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);
304	            }
305	        } else {
306	            // Otherwise only allow finalization if the crowdfund has expired
307	            // and been won. Can be finalized by anyone.
308	            if (lc != CrowdfundLifecycle.Won) {
309	                revert WrongLifecycleError(lc);
310	            }
311	        }
312	
313	        // Finalize the crowdfund.
314	        _finalize(totalContributions_);
315	    }
316	
317	    function _finalize(uint96 totalContributions_) internal {
318	        // Finalize the crowdfund.
319	        delete expiry;
320	
321	        // Transfer funding split to recipient if applicable.
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
323	        uint16 fundingSplitBps_ = fundingSplitBps;
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
326	        }
327	
328	        // Update the party's total voting power.
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
330	        party.increaseTotalVotingPower(newVotingPower);
331	
332	        // Transfer ETH to the party.
333	        payable(address(party)).transferEth(totalContributions_);
334	
335	        emit Finalized();
336	    }
337	
338	    /// @notice Send the funding split to the recipient if applicable.
339	    function sendFundingSplit() external returns (uint96 splitAmount) {
340	        // Check that the crowdfund is finalized.
341	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
342	        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);
343	
344	        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();
345	
346	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
347	        uint16 fundingSplitBps_ = fundingSplitBps;
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
349	            revert FundingSplitNotConfiguredError();
350	        }
351	
352	        fundingSplitPaid = true;
353	
354	        // Transfer funding split to recipient.
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
356	        payable(fundingSplitRecipient_).transferEth(splitAmount);
357	
358	        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);
359	    }
360	
361	    /// @notice As the DAO, execute an arbitrary function call from this contract.
362	    /// @dev Emergency actions must not be revoked for this to work.
363	    /// @param targetAddress The contract to call.
364	    /// @param targetCallData The data to pass to the contract.
365	    /// @param amountEth The amount of ETH to send to the contract.
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
371	        // Must be called by the DAO.
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
384	    }
385	
386	    /// @notice Revoke the DAO's ability to call emergencyExecute().
387	    /// @dev Either the DAO or the party host can call this.
388	    function disableEmergencyExecute() external {
389	        // Only the DAO or a host can call this.
390	        if (
391	            !party.isHost(msg.sender) &&
392	            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender
393	        ) {
394	            revert OnlyPartyDaoOrHostError(msg.sender);
395	        }
396	        emergencyExecuteDisabled = true;
397	        emit EmergencyExecuteDisabled();
398	    }
399	}
```
[9..400](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L9-L400)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
14	contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {
15	    using LibSafeCast for uint256;
16	    using LibSafeCast for uint96;
17	    using LibERC20Compat for IERC20;
18	    using LibAddress for address payable;
19	
20	    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);
21	    error CannotRageQuitError(uint40 rageQuitTimestamp);
22	    error CannotDisableRageQuitAfterInitializationError();
23	    error InvalidTokenOrderError();
24	    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);
25	    error NothingToBurnError();
26	
27	    event AuthorityAdded(address indexed authority);
28	    event AuthorityRemoved(address indexed authority);
29	    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);
30	    event Burn(address caller, uint256 tokenId, uint256 votingPower);
31	    event RageQuit(address caller, uint256[] tokenIds, IERC20[] withdrawTokens, address receiver);
32	    event PartyCardIntrinsicVotingPowerSet(uint256 indexed tokenId, uint256 intrinsicVotingPower);
33	
34	    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256("ENABLE_RAGEQUIT_PERMANENTLY")))
35	    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256("DISABLE_RAGEQUIT_PERMANENTLY")))
36	
37	    // Token address used to indicate ETH.
38	    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
39	
40	    // The `Globals` contract storing global configuration values. This contract
41	    // is immutable and its address will never change.
42	    IGlobals private immutable _GLOBALS;
43	
44	    /// @notice The number of tokens that have been minted.
45	    uint96 public tokenCount;
46	    /// @notice The total minted voting power.
47	    ///         Capped to `_governanceValues.totalVotingPower` unless minting
48	    ///         party cards for initial crowdfund.
49	    uint96 public mintedVotingPower;
50	    /// @notice The timestamp until which ragequit is enabled. Can be set to the
51	    ///         `ENABLE_RAGEQUIT_PERMANENTLY`/`DISABLE_RAGEQUIT_PERMANENTLY`
52	    ///         values to enable/disable ragequit permanently.
53	    ///         `DISABLE_RAGEQUIT_PERMANENTLY` can only be set during
54	    ///         initialization.
55	    uint40 public rageQuitTimestamp;
56	    /// @notice The voting power of `tokenId`.
57	    mapping(uint256 => uint256) public votingPowerByTokenId;
58	    /// @notice Address with authority to mint cards and update voting power for the party.
59	    mapping(address => bool) public isAuthority;
60	
61	    function _assertAuthority() internal view {
62	        if (!isAuthority[msg.sender]) {
63	            revert NotAuthorized();
64	        }
65	    }
66	
67	    modifier onlySelf() {
68	        if (msg.sender != address(this)) {
69	            revert NotAuthorized();
70	        }
71	        _;
72	    }
73	
74	    // Set the `Globals` contract. The name or symbol of ERC721 does not matter;
75	    // it will be set in `_initialize()`.
76	    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721("", "") {
77	        _GLOBALS = globals;
78	    }
79	
80	    // Initialize storage for proxy contracts.
81	    function _initialize(
82	        string memory name_,
83	        string memory symbol_,
84	        uint256 customizationPresetId,
85	        PartyGovernance.GovernanceOpts memory governanceOpts,
86	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
87	        IERC721[] memory preciousTokens,
88	        uint256[] memory preciousTokenIds,
89	        address[] memory authorities,
90	        uint40 rageQuitTimestamp_
91	    ) internal {
92	        PartyGovernance._initialize(
93	            governanceOpts,
94	            proposalEngineOpts,
95	            preciousTokens,
96	            preciousTokenIds
97	        );
98	        name = name_;
99	        symbol = symbol_;
100	        rageQuitTimestamp = rageQuitTimestamp_;
101	        unchecked {
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
105	        }
106	        if (customizationPresetId != 0) {
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
109	        }
110	    }
111	
112	    /// @inheritdoc EIP165
113	    function supportsInterface(
114	        bytes4 interfaceId
115	    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {
116	        return
117	            PartyGovernance.supportsInterface(interfaceId) ||
118	            ERC721.supportsInterface(interfaceId) ||
119	            interfaceId == type(IERC2981).interfaceId;
120	    }
121	
122	    /// @inheritdoc ERC721
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
127	
128	    /// @notice Returns a URI for the storefront-level metadata for your contract.
129	    function contractURI() external view returns (string memory) {
130	        _delegateToRenderer();
131	        return ""; // Just to make the compiler happy.
132	    }
133	
134	    /// @notice Called with the sale price to determine how much royalty
135	    //          is owed and to whom.
136	    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {
137	        _delegateToRenderer();
138	        return (address(0), 0); // Just to make the compiler happy.
139	    }
140	
141	    /// @notice Return the distribution share amount of a token. Included as an alias
142	    ///         for `votePowerByTokenId` for backwards compatibility with old
143	    ///         `TokenDistributor` implementations.
144	    /// @param tokenId The token ID to query.
145	    /// @return share The distribution shares of `tokenId`.
146	    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {
147	        return votingPowerByTokenId[tokenId];
148	    }
149	
150	    /// @notice Return the voting power share of a token. Denominated
151	    ///         fractions of 1e18. I.e., 1e18 = 100%.
152	    /// @param tokenId The token ID to query.
153	    /// @return share The voting power percentage of `tokenId`.
154	    function getVotingPowerShareOf(uint256 tokenId) public view returns (uint256) {
155	        uint256 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
156	        return
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
158	    }
159	
160	    /// @notice Mint a governance NFT for `owner` with `votingPower` and
161	    ///         immediately delegate voting power to `delegate.` Only callable
162	    ///         by an authority.
163	    /// @param owner The owner of the NFT.
164	    /// @param votingPower The voting power of the NFT.
165	    /// @param delegate The address to delegate voting power to.
166	    function mint(
167	        address owner,
168	        uint256 votingPower,
169	        address delegate
170	    ) external returns (uint256 tokenId) {
171	        _assertAuthority();
172	        uint96 mintedVotingPower_ = mintedVotingPower;
173	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
174	
175	        // Cap voting power to remaining unminted voting power supply.
176	        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();
177	        // Allow minting past total voting power if minting party cards for
178	        // initial crowdfund when there is no total voting power.
179	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {
180	            unchecked {
181	                votingPower_ = totalVotingPower - mintedVotingPower_;
182	            }
183	        }
184	
185	        // Update state.
186	        unchecked {
187	            tokenId = ++tokenCount;
188	        }
189	        mintedVotingPower += votingPower_;
190	        votingPowerByTokenId[tokenId] = votingPower_;
191	
192	        emit PartyCardIntrinsicVotingPowerSet(tokenId, votingPower_);
193	
194	        // Use delegate from party over the one set during crowdfund.
195	        address delegate_ = delegationsByVoter[owner];
196	        if (delegate_ != address(0)) {
197	            delegate = delegate_;
198	        }
199	
200	        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);
201	        _safeMint(owner, tokenId);
202	    }
203	
204	    /// @notice Add voting power to an existing NFT. Only callable by an
205	    ///         authority.
206	    /// @param tokenId The ID of the NFT to add voting power to.
207	    /// @param votingPower The amount of voting power to add.
208	    function increaseVotingPower(uint256 tokenId, uint96 votingPower) external {
209	        _assertAuthority();
210	        uint96 mintedVotingPower_ = mintedVotingPower;
211	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
212	
213	        // Cap voting power to remaining unminted voting power supply. Allow
214	        // minting past total voting power if minting party cards for initial
215	        // crowdfund when there is no total voting power.
216	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {
217	            unchecked {
218	                votingPower = totalVotingPower - mintedVotingPower_;
219	            }
220	        }
221	
222	        // Update state.
223	        mintedVotingPower += votingPower;
224	        uint256 newIntrinsicVotingPower = votingPowerByTokenId[tokenId] + votingPower;
225	        votingPowerByTokenId[tokenId] = newIntrinsicVotingPower;
226	
227	        emit PartyCardIntrinsicVotingPowerSet(tokenId, newIntrinsicVotingPower);
228	
229	        _adjustVotingPower(ownerOf(tokenId), votingPower.safeCastUint96ToInt192(), address(0));
230	    }
231	
232	    /// @notice Remove voting power from an existing NFT. Only callable by an
233	    ///         authority.
234	    /// @param tokenId The ID of the NFT to remove voting power from.
235	    /// @param votingPower The amount of voting power to remove.
236	    function decreaseVotingPower(uint256 tokenId, uint96 votingPower) external {
237	        _assertAuthority();
238	        mintedVotingPower -= votingPower;
239	        votingPowerByTokenId[tokenId] -= votingPower;
240	
241	        _adjustVotingPower(ownerOf(tokenId), -votingPower.safeCastUint96ToInt192(), address(0));
242	    }
243	
244	    /// @notice Increase the total voting power of the party. Only callable by
245	    ///         an authority.
246	    /// @param votingPower The new total voting power to add.
247	    function increaseTotalVotingPower(uint96 votingPower) external {
248	        _assertAuthority();
249	        _getSharedProposalStorage().governanceValues.totalVotingPower += votingPower;
250	    }
251	
252	    /// @notice Decrease the total voting power of the party. Only callable by
253	    ///         an authority.
254	    /// @param votingPower The new total voting power to add.
255	    function decreaseTotalVotingPower(uint96 votingPower) external {
256	        _assertAuthority();
257	        _getSharedProposalStorage().governanceValues.totalVotingPower -= votingPower;
258	    }
259	
260	    /// @notice Burn governance NFTs and remove their voting power. Can only
261	    ///         be called by an authority before the party has started.
262	    /// @param tokenIds The IDs of the governance NFTs to burn.
263	    function burn(uint256[] memory tokenIds) public {
264	        _assertAuthority();
265	        _burnAndUpdateVotingPower(tokenIds, false);
266	    }
267	
268	    function _burnAndUpdateVotingPower(
269	        uint256[] memory tokenIds,
270	        bool checkIfAuthorizedToBurn
271	    ) private returns (uint96 totalVotingPowerBurned) {
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
302	
303	        // Update minted voting power.
304	        mintedVotingPower -= totalVotingPowerBurned;
305	    }
306	
307	    /// @notice Burn governance NFT and remove its voting power. Can only be
308	    ///         called by an authority before the party has started.
309	    /// @param tokenId The ID of the governance NFTs to burn.
310	    function burn(uint256 tokenId) external {
311	        uint256[] memory tokenIds = new uint256[](1);
312	        tokenIds[0] = tokenId;
313	        burn(tokenIds);
314	    }
315	
316	    /// @notice Set the timestamp until which ragequit is enabled.
317	    /// @param newRageQuitTimestamp The new ragequit timestamp.
318	    function setRageQuit(uint40 newRageQuitTimestamp) external {
319	        _assertHost();
320	        // Prevent disabling ragequit after initialization.
321	        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {
322	            revert CannotDisableRageQuitAfterInitializationError();
323	        }
324	
325	        uint40 oldRageQuitTimestamp = rageQuitTimestamp;
326	
327	        // Prevent setting timestamp if it is permanently enabled/disabled.
328	        if (
329	            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||
330	            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY
331	        ) {
332	            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);
333	        }
334	
335	        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);
336	    }
337	
338	    /// @notice Burn a governance NFT and withdraw a fair share of fungible tokens from the party.
339	    /// @param tokenIds The IDs of the governance NFTs to burn.
340	    /// @param withdrawTokens The fungible tokens to withdraw. Specify the
341	    ///                       `ETH_ADDRESS` value to withdraw ETH.
342	    /// @param minWithdrawAmounts The minimum amount of to withdraw for each token.
343	    /// @param receiver The address to receive the withdrawn tokens.
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
449	
450	    /// @inheritdoc ERC721
451	    function transferFrom(address owner, address to, uint256 tokenId) public override {
452	        // Transfer voting along with token.
453	        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);
454	        super.transferFrom(owner, to, tokenId);
455	    }
456	
457	    /// @inheritdoc ERC721
458	    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {
459	        // super.safeTransferFrom() will call transferFrom() first which will
460	        // transfer voting power.
461	        super.safeTransferFrom(owner, to, tokenId);
462	    }
463	
464	    /// @inheritdoc ERC721
465	    function safeTransferFrom(
466	        address owner,
467	        address to,
468	        uint256 tokenId,
469	        bytes calldata data
470	    ) public override {
471	        // super.safeTransferFrom() will call transferFrom() first which will
472	        // transfer voting power.
473	        super.safeTransferFrom(owner, to, tokenId, data);
474	    }
475	
476	    /// @notice Add a new authority.
477	    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add
478	    ///      authorities to prevent it from being used anywhere else.
479	    function addAuthority(address authority) external onlySelf {
480	        isAuthority[authority] = true;
481	
482	        emit AuthorityAdded(authority);
483	    }
484	
485	    /// @notice Relinquish the authority role.
486	    function abdicateAuthority() external {
487	        _assertAuthority();
488	        delete isAuthority[msg.sender];
489	
490	        emit AuthorityRemoved(msg.sender);
491	    }
492	
493	    function _delegateToRenderer() private view {
494	        _readOnlyDelegateCall(
495	            // Instance of IERC721Renderer.
496	            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),
497	            msg.data
498	        );
499	        assert(false); // Will not be reached.
500	    }
501	}
```
[14..501](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L14-L501)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
24	contract ProposalExecutionEngine is
25	    IProposalExecutionEngine,
26	    Implementation,
27	    ProposalStorage,
28	    ListOnOpenseaProposal,
29	    ListOnOpenseaAdvancedProposal,
30	    ListOnZoraProposal,
31	    FractionalizeProposal,
32	    ArbitraryCallsProposal,
33	    DistributeProposal,
34	    AddAuthorityProposal,
35	    OperatorProposal,
36	    SetSignatureValidatorProposal,
37	    SetGovernanceParameterProposal,
38	    IERC1271
39	{
40	    using LibRawResult for bytes;
41	
42	    error UnsupportedProposalTypeError(uint32 proposalType);
43	
44	    // The types of proposals supported.
45	    // The first 4 bytes of a proposal's `proposalData` determine the proposal
46	    // type.
47	    // WARNING: This should be append-only.
48	    enum ProposalType {
49	        Invalid,
50	        ListOnOpensea,
51	        ListOnZora,
52	        Fractionalize,
53	        ArbitraryCalls,
54	        UpgradeProposalEngineImpl,
55	        ListOnOpenseaAdvanced,
56	        Distribute,
57	        AddAuthority,
58	        Operator,
59	        SetSignatureValidatorProposal,
60	        SetGovernanceParameterProposal
61	    }
62	
63	    // Explicit storage bucket for "private" state owned by the `ProposalExecutionEngine`.
64	    // See `_getStorage()` for how this is addressed.
65	    //
66	    // Read this for more context on the pattern motivating this:
67	    // https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/explicit-storage-buckets
68	    struct Storage {
69	        // The hash of the next `progressData` for the current `InProgress`
70	        // proposal. This is updated to the hash of the next `progressData` every
71	        // time a proposal is executed. This enforces that the next call to
72	        // `executeProposal()` receives the correct `progressData`.
73	        // If there is no current `InProgress` proposal, this will be 0x0.
74	        bytes32 nextProgressDataHash;
75	        // The proposal ID of the current, in progress proposal being executed.
76	        // `InProgress` proposals need to have `executeProposal()` called on them
77	        // multiple times until they complete. Only one proposal may be
78	        // in progress at a time, meaning no other proposals can be executed
79	        // if this value is nonzero.
80	        uint256 currentInProgressProposalId;
81	    }
82	
83	    event ProposalEngineImplementationUpgraded(address oldImpl, address newImpl);
84	
85	    error ProposalDisabled(ProposalType proposalType);
86	    error ZeroProposalIdError();
87	    error MalformedProposalDataError();
88	    error ProposalExecutionBlockedError(uint256 proposalId, uint256 currentInProgressProposalId);
89	    error ProposalProgressDataInvalidError(
90	        bytes32 actualProgressDataHash,
91	        bytes32 expectedProgressDataHash
92	    );
93	    error ProposalNotInProgressError(uint256 proposalId);
94	    error UnexpectedProposalEngineImplementationError(
95	        IProposalExecutionEngine actualImpl,
96	        IProposalExecutionEngine expectedImpl
97	    );
98	
99	    // The `Globals` contract storing global configuration values. This contract
100	    // is immutable and it’s address will never change.
101	    IGlobals private immutable _GLOBALS;
102	    // Storage slot for `Storage`.
103	    // Use a constant, non-overlapping slot offset for the storage bucket.
104	    uint256 private constant _STORAGE_SLOT = uint256(keccak256("ProposalExecutionEngine.Storage"));
105	
106	    // Set immutables.
107	    constructor(
108	        IGlobals globals,
109	        IReserveAuctionCoreEth zora,
110	        IFractionalV1VaultFactory fractionalVaultFactory
111	    )
112	        ListOnOpenseaAdvancedProposal(globals)
113	        ListOnZoraProposal(globals, zora)
114	        FractionalizeProposal(fractionalVaultFactory)
115	        ArbitraryCallsProposal(zora)
116	    {
117	        _GLOBALS = globals;
118	    }
119	
120	    /// @notice Used by `Party` to setup the execution engine.
121	    /// @param oldImpl The previous implementation address.
122	    /// @param initializeData The data to use to initialize the execution engine.
123	    function initialize(
124	        address oldImpl,
125	        bytes calldata initializeData
126	    ) external override onlyDelegateCall {
127	        // Prevent old parties from configuring new options to maintain security guarantees.
128	        if (oldImpl != address(0)) return;
129	
130	        // If there is no initialize data, there is nothing to do.
131	        if (initializeData.length == 0) return;
132	
133	        ProposalEngineOpts memory opts = abi.decode(initializeData, (ProposalEngineOpts));
134	
135	        // Set proposal engine opts
136	        _getSharedProposalStorage().opts = opts;
137	    }
138	
139	    /// @notice Get the current `InProgress` proposal ID.
140	    /// @dev With this version, only one proposal may be in progress at a time.
141	    function getCurrentInProgressProposalId() external view returns (uint256 id) {
142	        return _getStorage().currentInProgressProposalId;
143	    }
144	
145	    /// @inheritdoc IProposalExecutionEngine
146	    function executeProposal(
147	        ExecuteProposalParams memory params
148	    ) external onlyDelegateCall returns (bytes memory nextProgressData) {
149	        // Must have a valid proposal ID.
150	        if (params.proposalId == 0) {
151	            revert ZeroProposalIdError();
152	        }
153	        Storage storage stor = _getStorage();
154	        uint256 currentInProgressProposalId = stor.currentInProgressProposalId;
155	        if (currentInProgressProposalId == 0) {
156	            // No proposal is currently in progress.
157	            // Mark this proposal as the one in progress.
158	            stor.currentInProgressProposalId = params.proposalId;
159	        } else if (currentInProgressProposalId != params.proposalId) {
160	            // Only one proposal can be in progress at a time.
161	            revert ProposalExecutionBlockedError(params.proposalId, currentInProgressProposalId);
162	        }
163	        {
164	            bytes32 nextProgressDataHash = stor.nextProgressDataHash;
165	            if (nextProgressDataHash == 0) {
166	                // Expecting no progress data.
167	                // This is the state if there is no current `InProgress` proposal.
168	                assert(currentInProgressProposalId == 0);
169	                if (params.progressData.length != 0) {
170	                    revert ProposalProgressDataInvalidError(
171	                        keccak256(params.progressData),
172	                        nextProgressDataHash
173	                    );
174	                }
175	            } else {
176	                // Expecting progress data.
177	                bytes32 progressDataHash = keccak256(params.progressData);
178	                // Progress data must match the one stored.
179	                if (nextProgressDataHash != progressDataHash) {
180	                    revert ProposalProgressDataInvalidError(progressDataHash, nextProgressDataHash);
181	                }
182	            }
183	            // Temporarily set the expected next progress data hash to an
184	            // unachievable constant to act as a reentrancy guard.
185	            stor.nextProgressDataHash = bytes32(type(uint256).max);
186	        }
187	
188	        // Note that we do not enforce that the proposal has not been executed
189	        // (and completed) before in this contract. That is enforced by PartyGovernance.
190	
191	        // Execute the proposal.
192	        ProposalType pt;
193	        (pt, params.proposalData) = _extractProposalType(params.proposalData);
194	        nextProgressData = _execute(pt, params);
195	
196	        // If progress data is empty, the proposal is complete.
197	        if (nextProgressData.length == 0) {
198	            stor.currentInProgressProposalId = 0;
199	            stor.nextProgressDataHash = 0;
200	        } else {
201	            // Remember the next progress data.
202	            stor.nextProgressDataHash = keccak256(nextProgressData);
203	        }
204	    }
205	
206	    /// @inheritdoc IProposalExecutionEngine
207	    function cancelProposal(uint256 proposalId) external onlyDelegateCall {
208	        // Must be a valid proposal ID.
209	        if (proposalId == 0) {
210	            revert ZeroProposalIdError();
211	        }
212	        Storage storage stor = _getStorage();
213	        {
214	            // Must be the current InProgress proposal.
215	            uint256 currentInProgressProposalId = stor.currentInProgressProposalId;
216	            if (currentInProgressProposalId != proposalId) {
217	                revert ProposalNotInProgressError(proposalId);
218	            }
219	        }
220	        // Clear the current InProgress proposal ID and next progress data.
221	        stor.currentInProgressProposalId = 0;
222	        stor.nextProgressDataHash = 0;
223	    }
224	
225	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
226	        IERC1271 validator = getSignatureValidatorForHash(hash);
227	        if (address(validator) == address(1)) {
228	            // Signature set by party to be always valid
229	            return IERC1271.isValidSignature.selector;
230	        }
231	        if (address(validator) != address(0)) {
232	            return validator.isValidSignature(hash, signature);
233	        }
234	        if (tx.origin == address(0)) {
235	            validator = getSignatureValidatorForHash(0);
236	            if (address(validator) == address(0)) {
237	                // Use global off-chain signature validator
238	                validator = IERC1271(
239	                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)
240	                );
241	            }
242	            return validator.isValidSignature(hash, signature);
243	        }
244	        return 0;
245	    }
246	
247	    // Switch statement used to execute the right proposal.
248	    function _execute(
249	        ProposalType pt,
250	        ExecuteProposalParams memory params
251	    ) internal virtual returns (bytes memory nextProgressData) {
252	        if (pt == ProposalType.ListOnOpensea) {
253	            nextProgressData = _executeListOnOpensea(params);
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
293	
294	    // Destructively pops off the first 4 bytes of `proposalData` to determine
295	    // the type. This modifies `proposalData` and returns the updated
296	    // pointer to it.
297	    function _extractProposalType(
298	        bytes memory proposalData
299	    ) private pure returns (ProposalType proposalType, bytes memory offsetProposalData) {
300	        // First 4 bytes is proposal type. While the proposal type could be
301	        // stored in just 1 byte, this makes it easier to encode with
302	        // `abi.encodeWithSelector`.
303	        if (proposalData.length < 4) {
304	            revert MalformedProposalDataError();
305	        }
306	        assembly {
307	            // By reading 4 bytes into the length prefix, the leading 4 bytes
308	            // of the data will be in the lower bits of the read word.
309	            proposalType := and(mload(add(proposalData, 4)), 0xffffffff)
310	            mstore(add(proposalData, 4), sub(mload(proposalData), 4))
311	            offsetProposalData := add(proposalData, 4)
312	        }
313	        require(proposalType != ProposalType.Invalid);
314	        require(uint8(proposalType) <= uint8(type(ProposalType).max));
315	    }
316	
317	    // Upgrade implementation to the latest version.
318	    function _executeUpgradeProposalsImplementation(bytes memory proposalData) private {
319	        (address expectedImpl, bytes memory initData) = abi.decode(proposalData, (address, bytes));
320	        // Always upgrade to latest implementation stored in `_GLOBALS`.
321	        IProposalExecutionEngine newImpl = IProposalExecutionEngine(
322	            _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)
323	        );
324	        if (expectedImpl != address(newImpl)) {
325	            revert UnexpectedProposalEngineImplementationError(
326	                newImpl,
327	                IProposalExecutionEngine(expectedImpl)
328	            );
329	        }
330	        _initProposalImpl(newImpl, initData);
331	        emit ProposalEngineImplementationUpgraded(address(implementation), expectedImpl);
332	    }
333	
334	    // Retrieve the explicit storage bucket for the ProposalExecutionEngine logic.
335	    function _getStorage() internal pure returns (Storage storage stor) {
336	        uint256 slot = _STORAGE_SLOT;
337	        assembly {
338	            stor.slot := slot
339	        }
340	    }
341	}
```
[24..342](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L24-L342)


</details>

-------
### [N-44] `else`-block not required
<a name="N-44"></a>
[To the top](#TOP)

One level of nesting can be removed by not having an `else` block when the `if`-block returns, and `if (foo) { return 1; } else { return 2; }` becomes `if (foo) { return 1; } return 2;`

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
384	        if (address(customMetadataProvider) == address(0)) {
385	            return
386	                opts.governanceOpts.partyFactory.createParty(
387	                    opts.governanceOpts.partyImpl,
388	                    authorities,
389	                    Party.PartyOptions({
390	                        name: opts.name,
391	                        symbol: opts.symbol,
392	                        customizationPresetId: opts.customizationPresetId,
393	                        governance: PartyGovernance.GovernanceOpts({
394	                            hosts: opts.governanceOpts.hosts,
395	                            voteDuration: opts.governanceOpts.voteDuration,
396	                            executionDelay: opts.governanceOpts.executionDelay,
397	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
398	                            totalVotingPower: 0,
399	                            feeBps: opts.governanceOpts.feeBps,
400	                            feeRecipient: opts.governanceOpts.feeRecipient
401	                        }),
402	                        proposalEngine: opts.proposalEngineOpts
403	                    }),
404	                    opts.preciousTokens,
405	                    opts.preciousTokenIds,
406	                    opts.rageQuitTimestamp
407	                );
408	        } else {
409	            return
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
411	                    opts.governanceOpts.partyImpl,
412	                    authorities,
413	                    Party.PartyOptions({
414	                        name: opts.name,
415	                        symbol: opts.symbol,
416	                        customizationPresetId: opts.customizationPresetId,
417	                        governance: PartyGovernance.GovernanceOpts({
418	                            hosts: opts.governanceOpts.hosts,
419	                            voteDuration: opts.governanceOpts.voteDuration,
420	                            executionDelay: opts.governanceOpts.executionDelay,
421	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
422	                            totalVotingPower: 0,
423	                            feeBps: opts.governanceOpts.feeBps,
424	                            feeRecipient: opts.governanceOpts.feeRecipient
425	                        }),
426	                        proposalEngine: opts.proposalEngineOpts
427	                    }),
428	                    opts.preciousTokens,
429	                    opts.preciousTokenIds,
430	                    opts.rageQuitTimestamp,
431	                    customMetadataProvider,
432	                    customMetadata
433	                );
434	        }
```
[384..434](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L384-L434)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
186	            if (totalContributions >= minTotalContributions) {
187	                return CrowdfundLifecycle.Won;
188	            } else {
189	                return CrowdfundLifecycle.Lost;
190	            }
191	        }
```
[186..191](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L186-L191)


</details>

-------
### [N-45] Condition will not revert when `block.timestamp` is `==` to the compared variable
<a name="N-45"></a>
[To the top](#TOP)

The condition remains unaltered even if `block.timestamp` is equal to the compared `>` or `<` variable. For example, if there is a condition `block.timestamp > proposerSignature.expirationTimestamp`, it is necessary to also account for cases where `block.timestamp` is `==` to `proposerSignature.expirationTimestamp`.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
...
811	            if (block.timestamp < cancelTime) {
812	                revert ProposalCannotBeCancelledYetError(
813	                    uint40(block.timestamp),
814	                    uint40(cancelTime)
815	                );
816	            }
817	        }
```
[731..737](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L731-L737)
[811..817](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L811-L817)


</details>

-------
### [N-46] Large multiples of ten should use scientific notation
<a name="N-46"></a>
[To the top](#TOP)

Use a scientific notation rather than decimal literals (e.g. `1e6` instead of `1000000`), for better code readability. The same for exponentiation  (e.g. `1e18` instead of `10**18`): although the compiler is capable of optimizing it, it is considered good coding practice to utilize idioms that don't rely on compiler optimization, whenever possible.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
54	            if (proposalData.passThresholdBps > 10000) {
```
[54](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L54)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
60	            10000;
```
[60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L60)


</details>

-------
### [N-47] Custom `error` should be used rather than `require`/`assert`
<a name="N-47"></a>
[To the top](#TOP)

Custom errors are available from solidity version 0.8.4. Custom errors are more easily processed in try-catch blocks, and are easier to re-use and maintain.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
313	        require(proposalType != ProposalType.Invalid);
...
314	        require(uint8(proposalType) <= uint8(type(ProposalType).max));
```
[313](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L313)
[314](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L314)


</details>

-------
### [N-48] `require`/`revert` without any message
<a name="N-48"></a>
[To the top](#TOP)

If a transaction reverts, it can be confusing to debug if there aren't any messages. Add a descriptive message to all require/revert statements.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
313	        require(proposalType != ProposalType.Invalid);
...
314	        require(uint8(proposalType) <= uint8(type(ProposalType).max));
```
[313](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L313)
[314](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L314)


</details>

-------
### [N-49] Array indicies should be referenced via `enum`s rather than via numeric literals
<a name="N-49"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
313	        bytes4 functionSelector = bytes4(msg.data[0:4]);
```
[313](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L313)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
312	        tokenIds[0] = tokenId;
```
[312](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L312)


</details>

-------
### [N-50] Unused function parameter
<a name="N-50"></a>
[To the top](#TOP)

Comment out the variable name to suppress compiler warnings

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
1154	    function _hashPreciousList(
1155	        IERC721[] memory preciousTokens,
1156	        uint256[] memory preciousTokenIds
1157	    ) internal pure returns (bytes32 h) {
1158	        assembly {
1159	            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))
1160	            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))
1161	            h := keccak256(0x00, 0x40)
1162	        }
1163	    }
1164	
```
[1154..1164](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1154-L1164)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
28	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
29	        uint8 v;
30	        bytes32 r;
31	        bytes32 s;
32	        assembly {
33	            // First word of signature after size contains r
34	            r := mload(add(signature, 0x20))
35	            s := mload(add(signature, 0x40))
36	            // v is one byte which starts after s. type is uint8 so extra data will be ignored
37	            v := mload(add(signature, 0x41))
38	        }
39	
40	        bytes memory message;
41	        assembly {
42	            // Raw message data begins after v. Overwriting part of s and v with size of `message`
43	            message := add(signature, 0x41)
44	            mstore(message, sub(mload(signature), 0x41))
45	        }
46	
47	        // Recreate the message pre-hash from the raw data
48	        bytes memory encodedPacket = abi.encodePacked(
49	            "\x19Ethereum Signed Message:\n",
50	            Strings.toString(message.length),
51	            message
52	        );
53	        if (keccak256(encodedPacket) != hash) {
54	            revert MessageHashMismatch();
55	        }
56	
57	        Party party = Party(payable(msg.sender));
58	        address signer = ecrecover(hash, v, r, s);
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
60	            10000;
61	
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
63	            // Must own a party card or be delegatated voting power
64	            revert NotMemberOfParty();
65	        }
66	
67	        uint96 totalVotingPower = party.getGovernanceValues().totalVotingPower;
68	        uint96 thresholdBps = signingThersholdBps[party];
69	
70	        // Either threshold is 0 or signer votes above threshold
71	        if (
72	            thresholdBps == 0 ||
73	            (signerVotingPowerBps > totalVotingPower &&
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
75	        ) {
76	            return IERC1271.isValidSignature.selector;
77	        }
78	
79	        revert InsufficientVotingPower();
80	    }
```
[28..80](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L28-L80)


</details>

-------
### [N-51] Overflows in unchecked blocks
<a name="N-51"></a>
[To the top](#TOP)

While integers with a large number of bits are unlikely to overflow on human time scales, it is not strictly correct to use an `unchecked` block around them, because _eventually_ they will overflow, and `unchecked` blocks are meant for cases where it's mathematically impossible for an operation to trigger an overflow (e.g. a prior `require()` statement prevents the overflow case)

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
101	        unchecked {
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
105	        }
...
186	        unchecked {
187	            tokenId = ++tokenCount;
188	        }
```
[101..105](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L101-L105)
[186..188](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L186-L188)


</details>

-------
### [N-52] Empty function blocks
<a name="N-52"></a>
[To the top](#TOP)

Empty code blocks (i.e., {}) in a Solidity contract can be harmful as they can lead to ambiguity, misinterpretation, and unintended behavior. When developers encounter empty code blocks, it may be unclear whether the absence of code is intentional or the result of an oversight. This uncertainty can cause confusion during development, testing, and debugging, increasing the likelihood of introducing errors or vulnerabilities. Moreover, empty code blocks may give a false impression of implemented functionality or security measures, creating a misleading sense of assurance. To ensure clarity and maintainability, it is essential to avoid empty code blocks and explicitly document the intended behavior or any intentional omissions.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
99	    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}
```
[99](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L99)


</details>

-------
### [N-53] `Constant` name must be in capitalized `SNAKE_CASE`
<a name="N-53"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
186	    uint256 private constant UINT40_HIGH_BIT = 1 << 39;
```
[186](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L186)


</details>

-------
### [N-54] Array is `push()`ed but not `pop()`ed
<a name="N-54"></a>
[To the top](#TOP)

Array entries are added but are never removed. Consider whether this should be the case, or whether there should be a maximum, or whether old entries should be removed. Cases where there are specific potential problems will be flagged separately under a different issue.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
1040	        voterSnaps.push(snap);
```
[1040](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1040)


</details>

-------
### [N-55] Assembly block creates dirty bits
<a name="N-55"></a>
[To the top](#TOP)

Writing data to the free memory pointer without later updating the free memory pointer will cause there to be dirty bits at that memory location. Not updating the free memory pointer will make it [harder](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#cleanup) for the optimizer to reason about whether the memory needs to be cleaned before use, which will lead to worse optimizations. Update the free memory pointer and annotate the block (`assembly (\"memory-safe\") { ... }`) to avoid this issue.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
319	            assembly {
320	                let freeMem := mload(0x40)
321	                mstore(freeMem, functionSelector)
322	                mstore(0x40, add(freeMem, 0x20))
323	                return(freeMem, 0x20)
324	            }
325	        }
```
[319..325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L319-L325)


</details>

-------
### [N-56] Complex math should be split into multiple steps
<a name="N-56"></a>
[To the top](#TOP)

Consider splitting long arithmetic calculations into multiple steps to improve the code readability.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
```
[266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L266)


</details>

-------
### [N-57] Function names should use lowerCamelCase
<a name="N-57"></a>
[To the top](#TOP)

According to the Solidity [style guide](https://docs.soliditylang.org/en/latest/style-guide.html#function-names) function names should be in `mixedCase` (lowerCamelCase)

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/utils/Implementation.sol

```solidity
40	    function IMPL() external view returns (address) {
41	        return implementation;
42	    }
```
[40..42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L40-L42)


</details>

-------
### [N-58] Contracts should have full test coverage
<a name="N-58"></a>
[To the top](#TOP)

A 100% test coverage is not foolproof, but it helps immensely in reducing the amount of bugs that may occur.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>

Placeholder, for non-solidity issues.


[project\2023-10-party](https://github.com/code-423n4/2023-10-party/blob/main/)


</details>

-------
### [N-59] Large or complicated code bases should implement invariant tests
<a name="N-59"></a>
[To the top](#TOP)

This includes: large code bases, or code with lots of inline-assembly, complicated math, or complicated interactions between multiple contracts.

Invariant fuzzers such as Echidna require the test writer to come up with invariants which should not be violated under any circumstances, and the fuzzer tests various inputs and function calls to ensure that the invariants always hold.

Even code with 100% code coverage can still have bugs due to the order of the operations a user performs, and invariant fuzzers may help significantly.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>

Placeholder, for non-solidity issues.


[project\2023-10-party](https://github.com/code-423n4/2023-10-party/blob/main/)


</details>

-------
### [N-60] Codebase should implement formal verification testing
<a name="N-60"></a>
[To the top](#TOP)

Formal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification/property/invariant, using formal methods of mathematics.

Some tools that are currently available to perform these tests on smart contracts are [SMTChecker](https://docs.soliditylang.org/en/latest/smtchecker.html) and [Certora Prover](https://www.certora.com/).

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>

Placeholder, for non-solidity issues.


[project\2023-10-party](https://github.com/code-423n4/2023-10-party/blob/main/)


</details>


## Gas Risk Issues

### [G-01] Usage of `uint`/`int` smaller than 32 bytes (256 bits) incurs overhead
<a name="G-01"></a>
[To the top](#TOP)

When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.

Each operation involving a uint8 costs an extra 22-28 gas (depending on whether the other operand is also a variable of type uint8) as compared to ones involving uint256, due to the compiler having to clear the higher bits of the memory word before operating on the uint8, as well as the associated stack operations of doing so. Use a larger size then downcast where needed.

https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html

Use a larger size then downcast where needed.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 146 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
29	        uint96 minContribution;
...
30	        uint96 maxContribution;
...
32	        uint96 minTotalContributions;
...
33	        uint96 maxTotalContributions;
...
34	        uint16 exchangeRateBps;
...
35	        uint16 fundingSplitBps;
...
37	        uint40 duration;
...
60	        uint40 rageQuitTimestamp;
...
140	        uint96 initialContribution = msg.value.safeCastUint256ToUint96();
...
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
...
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
...
240	    ) external payable onlyDelegateCall returns (uint96 votingPower) {
...
278	        uint96 amount,
...
281	    ) private returns (uint96 votingPower) {
...
328	        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();
...
318	    function refund(uint256 tokenId) external returns (uint96 amount) {
```
[29](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L29)
[30](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L30)
[32](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L32)
[33](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L33)
[34](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L34)
[35](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L35)
[37](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L37)
[60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L60)
[140](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L140)
[167](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L167)
[189](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L189)
[240](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L240)
[278](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L278)
[281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L281)
[328](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L328)
[318](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L318)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
37	        uint96 minContribution;
...
38	        uint96 maxContribution;
...
40	        uint96 minTotalContributions;
...
41	        uint96 maxTotalContributions;
...
42	        uint16 exchangeRateBps;
...
43	        uint16 fundingSplitBps;
...
45	        uint40 duration;
...
63	    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);
...
63	    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);
...
64	    error MinGreaterThanMaxError(uint96 min, uint96 max);
...
64	    error MinGreaterThanMaxError(uint96 min, uint96 max);
...
65	    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);
...
66	    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);
...
66	    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);
...
67	    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);
...
67	    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);
...
68	    error InvalidExchangeRateError(uint16 exchangeRateBps);
...
95	    uint96 public minContribution;
...
98	    uint96 public maxContribution;
...
109	    uint96 public minTotalContributions;
...
112	    uint96 public maxTotalContributions;
...
114	    uint96 public totalContributions;
...
117	    uint40 public expiry;
...
120	    uint16 public exchangeRateBps;
...
123	    uint16 public fundingSplitBps;
...
222	        uint96 maxContribution_ = maxContribution;
...
227	        uint96 newTotalContributions = totalContributions + amount;
...
228	        uint96 maxTotalContributions_ = maxTotalContributions;
...
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
...
255	        uint96 minContribution_ = minContribution;
...
262	        uint16 fundingSplitBps_ = fundingSplitBps;
...
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
...
200	    ) internal returns (uint96 votingPower) {
...
285	        uint16 fundingSplitBps_ = fundingSplitBps;
...
279	        uint96 votingPower
280	    ) public view returns (uint96 amount) {
...
280	    ) public view returns (uint96 amount) {
...
292	        uint96 totalContributions_ = totalContributions;
...
301	            uint96 minTotalContributions_ = minTotalContributions;
...
323	        uint16 fundingSplitBps_ = fundingSplitBps;
...
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
...
317	    function _finalize(uint96 totalContributions_) internal {
...
347	        uint16 fundingSplitBps_ = fundingSplitBps;
...
339	    function sendFundingSplit() external returns (uint96 splitAmount) {
```
[37](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L37)
[38](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L38)
[40](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L40)
[41](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L41)
[42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L42)
[43](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L43)
[45](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L45)
[63](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L63)
[63](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L63)
[64](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L64)
[64](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L64)
[65](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L65)
[66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L66)
[66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L66)
[67](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L67)
[67](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L67)
[68](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L68)
[95](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L95)
[98](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L98)
[109](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L109)
[112](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L112)
[114](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L114)
[117](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L117)
[120](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L120)
[123](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L123)
[222](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L222)
[227](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L227)
[228](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L228)
[238](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L238)
[255](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L255)
[262](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L262)
[199..200](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L199-L200)
[200](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L200)
[285](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L285)
[279..280](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L279-L280)
[280](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L280)
[292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L292)
[301](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L301)
[323](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L323)
[329](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L329)
[317](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L317)
[347](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L347)
[339](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L339)

---

	 - contracts/party/PartyGovernance.sol

```solidity
72	        uint40 voteDuration;
...
75	        uint40 executionDelay;
...
78	        uint16 passThresholdBps;
...
80	        uint96 totalVotingPower;
...
82	        uint16 feeBps;
...
90	        uint40 timestamp;
...
92	        uint96 delegatedVotingPower;
...
94	        uint96 intrinsicVotingPower;
...
104	        uint40 maxExecutableTime;
...
107	        uint40 cancelDelay;
...
117	        uint40 proposedTime;
...
119	        uint40 passedTime;
...
121	        uint40 executedTime;
...
123	        uint40 completedTime;
...
125	        uint96 votes; // -1 == vetoed
...
127	        uint96 totalVotingPower;
...
129	        uint8 numHosts;
...
131	        uint8 numHostsAccepted;
...
162	        uint40 timestamp,
...
163	        uint96 delegatedVotingPower,
...
164	        uint96 intrinsicVotingPower,
...
171	    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);
...
171	    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);
...
179	    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);
...
179	    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);
...
180	    error InvalidBpsError(uint16 bps);
...
196	    uint16 public feeBps;
...
200	    uint40 public lastRageQuitTimestamp;
...
210	    uint8 public numHosts;
...
357	        uint40 timestamp
358	    ) external view returns (uint96 votingPower) {
...
358	    ) external view returns (uint96 votingPower) {
...
370	        uint40 timestamp,
...
372	    ) public view returns (uint96 votingPower) {
...
425	        uint40 timestamp
426	    ) public view returns (uint256 index) {
...
523	        uint16 feeBps_ = feeBps;
...
634	        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);
...
906	        uint40 timestamp,
...
938	        int192 powerI192 = power.safeCastUint256ToInt192();
...
944	    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {
...
1002	            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +
...
1086	        uint40 t = uint40(block.timestamp);
...
1112	        uint96 totalVotes,
...
1113	        uint96 totalVotingPower
1114	    ) private pure returns (bool) {
...
1123	        uint8 snapshotNumHosts,
...
1124	        uint8 numHostsAccepted
1125	    ) private pure returns (bool) {
...
1130	        uint96 voteCount,
...
1131	        uint96 totalVotingPower,
...
1132	        uint16 passThresholdBps
1133	    ) private pure returns (bool) {
```
[72](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L72)
[75](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L75)
[78](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L78)
[80](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L80)
[82](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L82)
[90](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L90)
[92](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L92)
[94](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L94)
[104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L104)
[107](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L107)
[117](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L117)
[119](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L119)
[121](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L121)
[123](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L123)
[125](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L125)
[127](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L127)
[129](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L129)
[131](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L131)
[162](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L162)
[163](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L163)
[164](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L164)
[171](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L171)
[171](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L171)
[179](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L179)
[179](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L179)
[180](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L180)
[196](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L196)
[200](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L200)
[210](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L210)
[357..358](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L357-L358)
[358](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L358)
[370](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L370)
[372](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L372)
[425..426](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L425-L426)
[523](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L523)
[634](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L634)
[906](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L906)
[938](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L938)
[944](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L944)
[1002](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1002)
[1086](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1086)
[1112](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1112)
[1113..1114](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1113-L1114)
[1123](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1123)
[1124..1125](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1124-L1125)
[1130](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1130)
[1131](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1131)
[1132..1133](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1132-L1133)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
20	    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);
...
21	    error CannotRageQuitError(uint40 rageQuitTimestamp);
...
29	    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);
...
29	    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);
...
45	    uint96 public tokenCount;
...
49	    uint96 public mintedVotingPower;
...
55	    uint40 public rageQuitTimestamp;
...
90	        uint40 rageQuitTimestamp_
...
172	        uint96 mintedVotingPower_ = mintedVotingPower;
...
173	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
...
176	        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();
...
210	        uint96 mintedVotingPower_ = mintedVotingPower;
...
211	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
...
208	    function increaseVotingPower(uint256 tokenId, uint96 votingPower) external {
...
236	    function decreaseVotingPower(uint256 tokenId, uint96 votingPower) external {
...
247	    function increaseTotalVotingPower(uint96 votingPower) external {
...
255	    function decreaseTotalVotingPower(uint96 votingPower) external {
...
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
...
271	    ) private returns (uint96 totalVotingPowerBurned) {
...
325	        uint40 oldRageQuitTimestamp = rageQuitTimestamp;
...
318	    function setRageQuit(uint40 newRageQuitTimestamp) external {
...
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
...
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
...
407	            uint16 feeBps_ = feeBps;
```
[20](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L20)
[21](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L21)
[29](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L29)
[29](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L29)
[45](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L45)
[49](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L49)
[55](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L55)
[90](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L90)
[172](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L172)
[173](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L173)
[176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L176)
[210](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L210)
[211](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L211)
[208](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L208)
[236](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L236)
[247](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L247)
[255](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L255)
[288](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L288)
[271](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L271)
[325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L325)
[318](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L318)
[356](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L356)
[401](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L401)
[407](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L407)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
42	    error UnsupportedProposalTypeError(uint32 proposalType);
```
[42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L42)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
21	        uint40 voteDuration;
...
22	        uint40 executionDelay;
...
23	        uint16 passThresholdBps;
...
24	        uint96 totalVotingPower;
```
[21](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L21)
[22](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L22)
[23](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L23)
[24](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L24)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
19	        uint40 voteDuration;
...
20	        uint40 executionDelay;
...
21	        uint16 passThresholdBps;
```
[19](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L19)
[20](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L20)
[21](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L21)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
17	        uint96 oldThresholdBps,
...
18	        uint96 newThresholdBps
...
29	        uint8 v;
...
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
...
67	        uint96 totalVotingPower = party.getGovernanceValues().totalVotingPower;
...
68	        uint96 thresholdBps = signingThersholdBps[party];
...
84	    function setSigningThresholdBps(uint96 thresholdBps) external {
```
[17](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L17)
[18](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L18)
[29](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L29)
[59](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L59)
[67](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L67)
[68](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L68)
[84](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L84)


</details>

-------
### [G-02] Delete Unused State Variables
<a name="G-02"></a>
[To the top](#TOP)

State variables that aren't used in the contract not only clutter the codebase but also consume unnecessary gas during deployment.
Specifically, setting non-zero initial values for state variables costs significant gas.
By removing these unused state variables, you can save on both deployment gas and potential future storage gas costs.
This optimization not only reduces gas expenditures but also enhances code clarity and maintainability.
Always ensure a thorough review to confirm that these variables are indeed redundant before removal.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 83 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
...
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
...
240	    ) external payable onlyDelegateCall returns (uint96 votingPower) {
```
[167](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L167)
[189](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L189)
[240](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L240)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
35	        address payable initialContributor;
...
36	        address initialDelegate;
...
46	        IGateKeeper gateKeeper;
...
47	        bytes12 gateKeeperId;
...
50	    error WrongLifecycleError(CrowdfundLifecycle lc);
...
52	        address contributor,
...
53	        IGateKeeper gateKeeper,
...
54	        bytes12 gateKeeperId,
...
55	        bytes gateData
...
58	    error OnlyPartyDaoError(address notDao);
...
59	    error OnlyPartyDaoOrHostError(address notDao);
...
60	    error NotOwnerError(uint256 tokenId);
...
63	    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);
...
63	    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);
...
64	    error MinGreaterThanMaxError(uint96 min, uint96 max);
...
64	    error MinGreaterThanMaxError(uint96 min, uint96 max);
...
65	    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);
...
66	    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);
...
66	    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);
...
67	    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);
...
67	    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);
...
68	    error InvalidExchangeRateError(uint16 exchangeRateBps);
...
127	    IGateKeeper public gateKeeper;
...
129	    bytes12 public gateKeeperId;
...
175	    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {
```
[35](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L35)
[36](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L36)
[46](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L46)
[47](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L47)
[50](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L50)
[52](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L52)
[53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L53)
[54](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L54)
[55](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L55)
[58](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L58)
[59](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L59)
[60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L60)
[63](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L63)
[63](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L63)
[64](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L64)
[64](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L64)
[65](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L65)
[66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L66)
[66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L66)
[67](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L67)
[67](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L67)
[68](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L68)
[127](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L127)
[129](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L129)
[175](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L175)

---

	 - contracts/party/PartyGovernance.sol

```solidity
169	    error BadProposalStatusError(ProposalStatus status);
...
170	    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);
...
170	    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);
...
171	    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);
...
171	    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);
...
177	    error AlreadyVotedError(address voter);
...
179	    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);
...
179	    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);
...
180	    error InvalidBpsError(uint16 bps);
...
358	    ) external view returns (uint96 votingPower) {
...
372	    ) public view returns (uint96 votingPower) {
...
406	        bytes32 dataHash = keccak256(proposal.proposalData);
...
399	    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {
...
426	    ) public view returns (uint256 index) {
...
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
...
595	    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {
...
868	    ) private returns (bool completed) {
...
1066	    ) private view returns (ProposalStatus status) {
...
1155	        IERC721[] memory preciousTokens,
...
1156	        uint256[] memory preciousTokenIds
1157	    ) internal pure returns (bytes32 h) {
...
1157	    ) internal pure returns (bytes32 h) {
```
[169](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L169)
[170](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L170)
[170](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L170)
[171](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L171)
[171](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L171)
[177](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L177)
[179](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L179)
[179](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L179)
[180](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L180)
[358](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L358)
[372](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L372)
[406](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L406)
[399](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L399)
[426](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L426)
[492](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L492)
[595](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L595)
[868](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L868)
[1066](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1066)
[1155](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1155)
[1156..1157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1156-L1157)
[1157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1157)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
20	    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);
...
21	    error CannotRageQuitError(uint40 rageQuitTimestamp);
...
24	    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);
...
24	    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);
```
[20](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L20)
[21](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L21)
[24](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L24)
[24](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L24)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
42	    error UnsupportedProposalTypeError(uint32 proposalType);
...
85	    error ProposalDisabled(ProposalType proposalType);
...
88	    error ProposalExecutionBlockedError(uint256 proposalId, uint256 currentInProgressProposalId);
...
88	    error ProposalExecutionBlockedError(uint256 proposalId, uint256 currentInProgressProposalId);
...
90	        bytes32 actualProgressDataHash,
...
91	        bytes32 expectedProgressDataHash
...
93	    error ProposalNotInProgressError(uint256 proposalId);
...
95	        IProposalExecutionEngine actualImpl,
...
96	        IProposalExecutionEngine expectedImpl
...
141	    function getCurrentInProgressProposalId() external view returns (uint256 id) {
...
299	    ) private pure returns (ProposalType proposalType, bytes memory offsetProposalData) {
...
336	        uint256 slot = _STORAGE_SLOT;
...
335	    function _getStorage() internal pure returns (Storage storage stor) {
```
[42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L42)
[85](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L85)
[88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L88)
[88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L88)
[90](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L90)
[91](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L91)
[93](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L93)
[95](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L95)
[96](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L96)
[141](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L141)
[299](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L299)
[336](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L336)
[335](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L335)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
15	        ProposalEngineOpts opts;
...
16	        GovernanceValues governanceValues;
...
21	        uint40 voteDuration;
...
22	        uint40 executionDelay;
...
23	        uint16 passThresholdBps;
...
24	        uint96 totalVotingPower;
...
29	        bool enableAddAuthorityProposal;
...
32	        bool allowArbCallsToSpendPartyEth;
...
34	        bool allowOperators;
...
36	        bool distributionsRequireVote;
...
39	    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;
...
60	        uint256 s = SHARED_STORAGE_SLOT;
...
58	        returns (SharedProposalStorage storage stor)
```
[15](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L15)
[16](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L16)
[21](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L21)
[22](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L22)
[23](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L23)
[24](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L24)
[29](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L29)
[32](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L32)
[34](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L34)
[36](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L36)
[39](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L39)
[60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L60)
[58](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L58)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
9	    error InvalidGovernanceParameter(uint256 value);
```
[9](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L9)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
52	        uint256 slot = _SET_SIGNATURE_VALIDATOR_PROPOSAL_STORAGE_SLOT;
...
50	        returns (SetSignatureValidatorProposalStorage storage stor)
```
[52](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L52)
[50](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L50)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
28	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
```
[28](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L28)


</details>

-------
### [G-03] Optimize Zero Checks Using Assembly
<a name="G-03"></a>
[To the top](#TOP)

The usage of inline assembly to check if variable is the zero can save gas compared to traditional `require` or `if` statement checks. 

The assembly check uses the `extcodesize` operation which is generally cheaper in terms of gas.

[More information can be found here.](https://medium.com/@kalexotsu/solidity-assembly-checking-if-an-address-is-0-efficiently-d2bfe071331)

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 73 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
141	        if (initialContribution > 0) {
...
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
...
283	        if (delegate == address(0)) {
...
289	        if (_gateKeeper != IGateKeeper(address(0))) {
...
298	        if (amount == 0) return 0;
...
300	        if (tokenId == 0) {
...
331	        if (amount > 0) {
...
384	        if (address(customMetadataProvider) == address(0)) {
```
[141](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L141)
[224](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L224)
[283](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L283)
[289](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L289)
[298](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L298)
[300](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L300)
[331](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L331)
[384](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L384)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
153	        if (opts.maxTotalContributions == 0) {
...
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
...
176	        if (maxTotalContributions == 0) {
...
181	        if (expiry_ == 0) {
...
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
...
213	        if (amount == 0) return 0;
...
239	            if (refundAmount > 0) {
...
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
272	        if (votingPower == 0) revert ZeroVotingPowerError();
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
...
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
```
[153](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L153)
[165](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L165)
[176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L176)
[181](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L181)
[202](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L202)
[213](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L213)
[239](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L239)
[263](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263)
[263](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263)
[272](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L272)
[286](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286)
[286](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286)
[324](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324)
[324](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324)
[348](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L348)
[348](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L348)

---

	 - contracts/party/PartyGovernance.sol

```solidity
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
445	        return high == 0 ? type(uint256).max : high - 1;
...
460	        if (newPartyHost != address(0)) {
...
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
...
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
...
644	            values.passedTime == 0 &&
...
797	            if (globalMaxCancelDelay != 0) {
...
803	            if (globalMinCancelDelay != 0) {
...
900	        return nextProgressData.length == 0;
...
911	        if (snapsLength != 0) {
...
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
...
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
...
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
...
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
...
1033	        if (n != 0) {
...
1048	        if (n != 0) {
...
1068	        if (pv.proposedTime == 0) {
...
1072	        if (pv.executedTime != 0) {
...
1073	            if (pv.completedTime == 0) {
...
1088	        if (pv.passedTime != 0) {
...
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
```
[225](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L225)
[225](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L225)
[445](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L445)
[460](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L460)
[505](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L505)
[505](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L505)
[510](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L510)
[644](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L644)
[797](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L797)
[803](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L803)
[900](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L900)
[911](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L911)
[949](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L949)
[951](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L951)
[979](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L979)
[979](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L979)
[1033](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1033)
[1048](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1048)
[1068](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1068)
[1072](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1072)
[1073](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1073)
[1088](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1088)
[1126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1126)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
106	        if (customizationPresetId != 0) {
...
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
...
179	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {
...
196	        if (delegate_ != address(0)) {
...
216	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {
...
350	        if (tokenIds.length == 0) revert NothingToBurnError();
...
415	                if (fee > 0) {
...
426	                if (amount > 0) {
```
[106](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L106)
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)
[179](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L179)
[196](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L196)
[216](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L216)
[350](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L350)
[415](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L415)
[426](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L426)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
128	        if (oldImpl != address(0)) return;
...
131	        if (initializeData.length == 0) return;
...
150	        if (params.proposalId == 0) {
...
155	        if (currentInProgressProposalId == 0) {
...
165	            if (nextProgressDataHash == 0) {
...
168	                assert(currentInProgressProposalId == 0);
...
169	                if (params.progressData.length != 0) {
...
197	        if (nextProgressData.length == 0) {
...
209	        if (proposalId == 0) {
...
231	        if (address(validator) != address(0)) {
...
234	        if (tx.origin == address(0)) {
...
236	            if (address(validator) == address(0)) {
```
[128](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L128)
[131](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L131)
[150](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L150)
[155](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L155)
[165](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L165)
[168](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L168)
[169](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L169)
[197](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L197)
[209](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L209)
[231](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L231)
[234](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L234)
[236](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L236)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
32	        if (proposalData.voteDuration != 0) {
...
42	        if (proposalData.executionDelay != 0) {
...
53	        if (proposalData.passThresholdBps != 0) {
```
[32](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L32)
[42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L42)
[53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L53)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
...
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
...
72	            thresholdBps == 0 ||
```
[62](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L62)
[62](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L62)
[72](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L72)


</details>

-------
### [G-04] State variables should be cached in stack variables rather than re-reading them from storage
<a name="G-04"></a>
[To the top](#TOP)

The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 67 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
305	        } else if (party.ownerOf(tokenId) == contributor) {
...
307	            party.increaseVotingPower(tokenId, votingPower);
...
302	            party.mint(contributor, votingPower, delegate);
...
328	        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();
...
333	            address payable contributor = payable(party.ownerOf(tokenId));
...
336	            party.burn(tokenId);
...
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
...
291	                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);
```
[305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L305)
[307](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L307)
[302](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L302)
[328](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L328)
[333](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L333)
[336](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L336)
[290](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L290)
[291](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L291)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
298	            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();
...
330	        party.increaseTotalVotingPower(newVotingPower);
...
333	        payable(address(party)).transferEth(totalContributions_);
...
391	            !party.isHost(msg.sender) &&
...
186	            if (totalContributions >= minTotalContributions) {
...
301	            uint96 minTotalContributions_ = minTotalContributions;
...
176	        if (maxTotalContributions == 0) {
...
228	        uint96 maxTotalContributions_ = maxTotalContributions;
...
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
...
186	            if (totalContributions >= minTotalContributions) {
...
227	        uint96 newTotalContributions = totalContributions + amount;
...
292	        uint96 totalContributions_ = totalContributions;
...
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
...
180	        uint256 expiry_ = expiry;
...
319	        delete expiry;
...
270	        votingPower = (amount * exchangeRateBps) / 1e4;
...
281	        amount = (votingPower * 1e4) / exchangeRateBps;
...
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
...
262	        uint16 fundingSplitBps_ = fundingSplitBps;
...
285	        uint16 fundingSplitBps_ = fundingSplitBps;
...
323	        uint16 fundingSplitBps_ = fundingSplitBps;
...
347	        uint16 fundingSplitBps_ = fundingSplitBps;
...
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
284	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
346	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
...
298	            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();
...
391	            !party.isHost(msg.sender) &&
```
[298](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L298)
[330](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L330)
[333](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L333)
[391](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L391)
[186](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L186)
[301](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L301)
[176](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L176)
[228](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L228)
[238](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L238)
[186](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L186)
[227](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L227)
[292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L292)
[355](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L355)
[180](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L180)
[319](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L319)
[270](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L270)
[281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L281)
[329](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L329)
[262](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L262)
[285](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L285)
[323](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L323)
[347](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L347)
[261](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L261)
[284](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L284)
[322](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L322)
[346](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L346)
[298](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L298)
[391](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L391)

---

	 - contracts/party/PartyGovernance.sol

```solidity
217	        if (!isHost[msg.sender]) {
...
462	            if (isHost[newPartyHost]) {
...
636	        if (isHost[msg.sender]) {
...
468	            --numHosts;
...
571	                numHosts: numHosts,
...
384	        values = _proposalStateByProposalId[proposalId].values;
...
597	        ProposalState storage info = _proposalStateByProposalId[proposalId];
...
668	        ProposalState storage info = _proposalStateByProposalId[proposalId];
...
717	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
...
774	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
...
427	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
...
909	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
...
1030	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
...
1046	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
```
[217](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L217)
[462](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L462)
[636](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L636)
[468](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L468)
[571](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L571)
[384](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L384)
[597](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L597)
[668](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L668)
[717](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L717)
[774](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L774)
[427](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L427)
[909](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L909)
[1030](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1030)
[1046](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1046)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
422	                        token.compatTransfer(feeRecipient, fee);
...
420	                        payable(feeRecipient).transferEth(fee);
...
172	        uint96 mintedVotingPower_ = mintedVotingPower;
...
210	        uint96 mintedVotingPower_ = mintedVotingPower;
...
325	        uint40 oldRageQuitTimestamp = rageQuitTimestamp;
...
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
...
147	        return votingPowerByTokenId[tokenId];
...
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
...
224	        uint256 newIntrinsicVotingPower = votingPowerByTokenId[tokenId] + votingPower;
...
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
...
293	            delete votingPowerByTokenId[tokenId];
...
453	        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);
...
62	        if (!isAuthority[msg.sender]) {
...
353	        bool isAuthority_ = isAuthority[msg.sender];
...
488	        delete isAuthority[msg.sender];
```
[422](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L422)
[420](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L420)
[172](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L172)
[210](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L210)
[325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L325)
[356](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L356)
[147](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L147)
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)
[224](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L224)
[288](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L288)
[293](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L293)
[453](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L453)
[62](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L62)
[353](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L353)
[488](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L488)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
68	        uint96 thresholdBps = signingThersholdBps[party];
...
86	        emit SigningThresholdBpsSet(party, signingThersholdBps[party], thresholdBps);
```
[68](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L68)
[86](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L86)


</details>

-------
### [G-05] Use Assembly for Efficient Event Emission
<a name="G-05"></a>
[To the top](#TOP)

To efficiently emit events, consider utilizing assembly by making use of scratch space and the free memory pointer.
This approach can potentially avoid the costs associated with memory expansion.

However, it's crucial to cache and restore the free memory pointer for safe optimization.
Good examples of such practices can be found in well-optimized [Solady's codebases](https://github.com/Vectorized/solady/blob/main/src/tokens/ERC1155.sol#L167).
Please review your code and consider the potential gas savings of this approach.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 39 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
341	            emit Refunded(contributor, tokenId, amount);
```
[341](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L341)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
210	        emit Contributed(msg.sender, contributor, amount, delegate);
...
335	        emit Finalized();
...
358	        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);
...
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
...
397	        emit EmergencyExecuteDisabled();
```
[210](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L210)
[335](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L335)
[358](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L358)
[383](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L383)
[397](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L397)

---

	 - contracts/party/PartyGovernance.sol

```solidity
471	        emit HostStatusTransferred(msg.sender, newPartyHost);
...
517	        emit DistributionCreated(tokenType, token, tokenId);
...
520	        emit BatchMetadataUpdate(0, type(uint256).max);
...
576	        emit Proposed(proposalId, msg.sender, proposal);
...
581	        emit BatchMetadataUpdate(0, type(uint256).max);
...
640	        emit ProposalAccepted(proposalId, msg.sender, votingPower);
...
652	            emit ProposalPassed(proposalId);
...
655	            emit BatchMetadataUpdate(0, type(uint256).max);
...
685	        emit ProposalVetoed(proposalId, msg.sender);
...
688	        emit BatchMetadataUpdate(0, type(uint256).max);
...
830	        emit ProposalCancelled(proposalId);
...
833	        emit BatchMetadataUpdate(0, type(uint256).max);
...
850	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
...
857	        emit EmergencyExecuteDisabled();
...
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
...
897	        emit BatchMetadataUpdate(0, type(uint256).max);
...
964	        emit PartyDelegateUpdated(voter, delegate);
...
1022	        emit PartyVotingSnapshotCreated(
1023	            voter,
1024	            snap.timestamp,
1025	            snap.delegatedVotingPower,
1026	            snap.intrinsicVotingPower,
1027	            snap.isDelegated
1028	        );
```
[471](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L471)
[517](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L517)
[520](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L520)
[576](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L576)
[581](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L581)
[640](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L640)
[652](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L652)
[655](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L655)
[685](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L685)
[688](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L688)
[830](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L830)
[833](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L833)
[850](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L850)
[857](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L857)
[894](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L894)
[897](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L897)
[964](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L964)
[1022..1028](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1022-L1028)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
192	        emit PartyCardIntrinsicVotingPowerSet(tokenId, votingPower_);
...
227	        emit PartyCardIntrinsicVotingPowerSet(tokenId, newIntrinsicVotingPower);
...
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
...
300	            emit Burn(msg.sender, tokenId, votingPower);
...
335	        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);
...
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
...
482	        emit AuthorityAdded(authority);
...
490	        emit AuthorityRemoved(msg.sender);
```
[192](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L192)
[227](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L227)
[294](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L294)
[300](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L300)
[335](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L335)
[447](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L447)
[482](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L482)
[490](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L490)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
331	        emit ProposalEngineImplementationUpgraded(address(implementation), expectedImpl);
```
[331](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L331)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
36	            emit VoteDurationSet(
37	                _getSharedProposalStorage().governanceValues.voteDuration,
38	                proposalData.voteDuration
39	            );
...
46	            emit ExecutionDelaySet(
47	                _getSharedProposalStorage().governanceValues.executionDelay,
48	                proposalData.executionDelay
49	            );
...
57	            emit PassThresholdBpsSet(
58	                _getSharedProposalStorage().governanceValues.passThresholdBps,
59	                proposalData.passThresholdBps
60	            );
```
[36..39](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L36-L39)
[46..49](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L46-L49)
[57..60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L57-L60)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
39	        emit SignatureValidatorSet(data.signatureHash, data.signatureValidator);
```
[39](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L39)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
86	        emit SigningThresholdBpsSet(party, signingThersholdBps[party], thresholdBps);
```
[86](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L86)

---

	 - contracts/utils/Implementation.sol

```solidity
33	        emit Initialized();
```
[33](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L33)


</details>

-------
### [G-06] Optimize External Calls with Assembly for Memory Efficiency
<a name="G-06"></a>
[To the top](#TOP)

Using interfaces to make external contract calls in Solidity is convenient but can be inefficient in terms of memory utilization.
Each such call involves creating a new memory location to store the data being passed, thus incurring memory expansion costs. 

Inline assembly allows for optimized memory usage by re-using already allocated memory spaces or using the scratch space for smaller datasets.
This can result in notable gas savings, especially for contracts that make frequent external calls.

Additionally, using inline assembly enables important safety checks like verifying if the target address has code deployed to it using `extcodesize(addr)` before making the call, mitigating risks associated with contract interactions.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 36 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
...
305	        } else if (party.ownerOf(tokenId) == contributor) {
...
307	            party.increaseVotingPower(tokenId, votingPower);
...
302	            party.mint(contributor, votingPower, delegate);
...
328	        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();
...
333	            address payable contributor = payable(party.ownerOf(tokenId));
...
336	            party.burn(tokenId);
...
359	                abi.encodeCall(this.refund, (tokenIds[i]))
...
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
...
386	                opts.governanceOpts.partyFactory.createParty(
```
[290](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L290)
[305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L305)
[307](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L307)
[302](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L302)
[328](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L328)
[333](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L333)
[336](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L336)
[359](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L359)
[410](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L410)
[386](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L386)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
298	            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();
...
330	        party.increaseTotalVotingPower(newVotingPower);
...
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
...
391	            !party.isHost(msg.sender) &&
...
392	            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender
```
[298](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L298)
[330](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L330)
[372](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L372)
[391](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L391)
[392](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L392)

---

	 - contracts/party/PartyGovernance.sol

```solidity
233	            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
...
243	        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
...
259	        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {
...
285	            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),
...
515	            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)
...
526	                distributor.createNativeDistribution{ value: amount }(
...
526	                distributor.createNativeDistribution{ value: amount }(
...
536	            distributor.createErc20Distribution(
...
791	            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(
...
794	            uint256 globalMinCancelDelay = _GLOBALS.getUint256(
```
[233](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L233)
[243](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L243)
[259](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L259)
[285](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L285)
[515](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L515)
[526](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L526)
[526](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L526)
[536](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L536)
[791](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L791)
[794](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L794)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
...
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
...
388	                    : withdrawTokens[i].balanceOf(address(this));
...
496	            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),
```
[107..108](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L107-L108)
[107](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L107)
[388](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L388)
[496](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L496)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
232	            return validator.isValidSignature(hash, signature);
...
239	                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)
...
242	            return validator.isValidSignature(hash, signature);
...
322	            _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)
```
[232](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L232)
[239](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L239)
[242](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L242)
[322](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L322)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
...
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
...
67	        uint96 totalVotingPower = party.getGovernanceValues().totalVotingPower;
```
[59](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L59)
[62](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L62)
[67](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L67)


</details>

-------
### [G-07] Avoid Unnecessary Public Variables
<a name="G-07"></a>
[To the top](#TOP)

Public storage variables increase the contract's size due to the implicit generation of public getter functions. 
This makes the contract larger and could increase deployment and interaction costs.

If you do not require other contracts to read these variables, consider making them `private` or `internal`. 

Example:
```solidity
/// 145426 gas to deploy
contract PublicState {
  address public first;
  address public second;
}
/// 77126 gas to deploy
contract PrivateState {
  address private first;
  address private second;
}
```

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 33 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
92	    Party public party;
...
95	    uint96 public minContribution;
...
98	    uint96 public maxContribution;
...
101	    bool public disableContributingForExistingCard;
...
104	    bool public fundingSplitPaid;
...
106	    bool public emergencyExecuteDisabled;
...
109	    uint96 public minTotalContributions;
...
112	    uint96 public maxTotalContributions;
...
114	    uint96 public totalContributions;
...
117	    uint40 public expiry;
...
120	    uint16 public exchangeRateBps;
...
123	    uint16 public fundingSplitBps;
...
125	    address payable public fundingSplitRecipient;
...
127	    IGateKeeper public gateKeeper;
...
129	    bytes12 public gateKeeperId;
...
131	    mapping(address => address) public delegationsByContributor;
```
[92](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L92)
[95](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L95)
[98](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L98)
[101](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L101)
[104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L104)
[106](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L106)
[109](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L109)
[112](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L112)
[114](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L114)
[117](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L117)
[120](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L120)
[123](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L123)
[125](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L125)
[127](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L127)
[129](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L129)
[131](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L131)

---

	 - contracts/party/PartyGovernance.sol

```solidity
194	    bool public emergencyExecuteDisabled;
...
196	    uint16 public feeBps;
...
198	    address payable public feeRecipient;
...
200	    uint40 public lastRageQuitTimestamp;
...
202	    bytes32 public preciousListHash;
...
204	    uint256 public lastProposalId;
...
206	    mapping(address => bool) public isHost;
...
208	    mapping(address => address) public delegationsByVoter;
...
210	    uint8 public numHosts;
```
[194](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L194)
[196](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L196)
[198](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L198)
[200](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L200)
[202](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L202)
[204](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L204)
[206](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L206)
[208](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L208)
[210](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L210)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
45	    uint96 public tokenCount;
...
49	    uint96 public mintedVotingPower;
...
55	    uint40 public rageQuitTimestamp;
...
57	    mapping(uint256 => uint256) public votingPowerByTokenId;
...
59	    mapping(address => bool) public isAuthority;
```
[45](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L45)
[49](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L49)
[55](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L55)
[57](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L57)
[59](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L59)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
22	    mapping(Party party => uint96 thresholdBps) public signingThersholdBps;
```
[22](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L22)

---

	 - contracts/utils/Implementation.sol

```solidity
12	    address public immutable implementation;
...
15	    bool public initialized;
```
[12](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L12)
[15](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L15)


</details>

-------
### [G-08] Consider Using Solady's Gas Optimized Lib for Math
<a name="G-08"></a>
[To the top](#TOP)

Utilizing gas-optimized math functions from libraries like [Solady](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol) can lead to more efficient smart contracts.
This is particularly beneficial in contracts where these operations are frequently used.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 27 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
...
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
...
270	        votingPower = (amount * exchangeRateBps) / 1e4;
...
270	        votingPower = (amount * exchangeRateBps) / 1e4;
...
281	        amount = (votingPower * 1e4) / exchangeRateBps;
...
281	        amount = (votingPower * 1e4) / exchangeRateBps;
...
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
...
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
...
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
...
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
...
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
...
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
...
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
...
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
```
[266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L266)
[266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L266)
[270](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L270)
[270](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L270)
[281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L281)
[281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L281)
[287](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L287)
[287](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L287)
[325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L325)
[325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L325)
[329](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L329)
[329](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L329)
[355](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L355)
[355](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L355)

---

	 - contracts/party/PartyGovernance.sol

```solidity
434	            uint256 mid = (low + high) / 2;
...
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
...
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
...
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
...
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
```
[434](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L434)
[1115](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1115)
[1115](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1115)
[1134](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1134)
[1134](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1134)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
...
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
...
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
...
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
...
413	                uint256 fee = (amount * feeBps_) / 1e4;
...
413	                uint256 fee = (amount * feeBps_) / 1e4;
```
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)
[393](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L393)
[393](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L393)
[413](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L413)
[413](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L413)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
60	            10000;
...
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
```
[59..60](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L59-L60)
[74](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L74)


</details>

-------
### [G-09] Stack variable used as a cheaper cache for a state variable is only used once
<a name="G-09"></a>
[To the top](#TOP)

If the variable is only accessed once, it's cheaper to use the state variable directly that one time, and save the 3 gas the extra stack assignment would spend

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 21 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
108	    function initialize(
109	        InitialETHCrowdfundOptions memory crowdfundOpts,
110	        ETHPartyOptions memory partyOpts,
111	        MetadataProvider customMetadataProvider,
112	        bytes memory customMetadata
113	    ) external payable onlyInitialize {
114	        // Create party the initial crowdfund will be for.
115	        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);
116	
117	        // Initialize the crowdfund.
118	        _initialize(
119	            ETHCrowdfundOptions({
120	                party: party_,
121	                initialContributor: crowdfundOpts.initialContributor,
122	                initialDelegate: crowdfundOpts.initialDelegate,
123	                minContribution: crowdfundOpts.minContribution,
124	                maxContribution: crowdfundOpts.maxContribution,
125	                disableContributingForExistingCard: crowdfundOpts
126	                    .disableContributingForExistingCard,
127	                minTotalContributions: crowdfundOpts.minTotalContributions,
128	                maxTotalContributions: crowdfundOpts.maxTotalContributions,
129	                exchangeRateBps: crowdfundOpts.exchangeRateBps,
130	                fundingSplitBps: crowdfundOpts.fundingSplitBps,
131	                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,
132	                duration: crowdfundOpts.duration,
133	                gateKeeper: crowdfundOpts.gateKeeper,
134	                gateKeeperId: crowdfundOpts.gateKeeperId
135	            })
136	        );
137	
138	        // If the deployer passed in some ETH during deployment, credit them
139	        // for the initial contribution.
140	        uint96 initialContribution = msg.value.safeCastUint256ToUint96();
141	        if (initialContribution > 0) {
142	            // If this contract has ETH, either passed in during deployment or
143	            // pre-existing, credit it to the `initialContributor`.
144	            _contribute(
145	                crowdfundOpts.initialContributor,
146	                crowdfundOpts.initialDelegate,
147	                initialContribution,
148	                0,
149	                ""
150	            );
151	        }
152	
153	        // Set up gatekeeper after initial contribution (initial always gets in).
154	        gateKeeper = crowdfundOpts.gateKeeper;
155	        gateKeeperId = crowdfundOpts.gateKeeperId;
156	    }
...
318	    function refund(uint256 tokenId) external returns (uint96 amount) {
319	        // Check crowdfund lifecycle.
320	        {
321	            CrowdfundLifecycle lc = getCrowdfundLifecycle();
322	            if (lc != CrowdfundLifecycle.Lost) {
323	                revert WrongLifecycleError(lc);
324	            }
325	        }
326	
327	        // Get amount to refund.
328	        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();
329	        amount = convertVotingPowerToContribution(votingPower);
330	
331	        if (amount > 0) {
332	            // Get contributor to refund.
333	            address payable contributor = payable(party.ownerOf(tokenId));
334	
335	            // Burn contributor's party card.
336	            party.burn(tokenId);
337	
338	            // Refund contributor.
339	            contributor.transferEth(amount);
340	
341	            emit Refunded(contributor, tokenId, amount);
342	        }
343	    }
...
350	    function batchRefund(
351	        uint256[] calldata tokenIds,
352	        bool revertOnFailure
353	    ) external returns (uint96[] memory amounts) {
354	        uint256 numRefunds = tokenIds.length;
355	        amounts = new uint96[](numRefunds);
356	
357	        for (uint256 i; i < numRefunds; ++i) {
358	            (bool s, bytes memory r) = address(this).call(
359	                abi.encodeCall(this.refund, (tokenIds[i]))
360	            );
361	
362	            if (!s) {
363	                if (revertOnFailure) {
364	                    r.rawRevert();
365	                }
366	            } else {
367	                amounts[i] = abi.decode(r, (uint96));
368	            }
369	        }
370	    }
```
[108..156](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L108-L156)
[318..343](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L318-L343)
[350..370](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L350-L370)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
...
278	    function convertVotingPowerToContribution(
279	        uint96 votingPower
280	    ) public view returns (uint96 amount) {
281	        amount = (votingPower * 1e4) / exchangeRateBps;
282	
283	        // Add back funding split to contribution amount if applicable.
284	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
285	        uint16 fundingSplitBps_ = fundingSplitBps;
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
288	        }
289	    }
290	
...
317	    function _finalize(uint96 totalContributions_) internal {
318	        // Finalize the crowdfund.
319	        delete expiry;
320	
321	        // Transfer funding split to recipient if applicable.
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
323	        uint16 fundingSplitBps_ = fundingSplitBps;
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
326	        }
327	
328	        // Update the party's total voting power.
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
330	        party.increaseTotalVotingPower(newVotingPower);
331	
332	        // Transfer ETH to the party.
333	        payable(address(party)).transferEth(totalContributions_);
334	
335	        emit Finalized();
336	    }
337	
...
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
371	        // Must be called by the DAO.
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
384	    }
385	
```
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)
[278..290](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L278-L290)
[317..337](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L317-L337)
[366..385](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L366-L385)

---

	 - contracts/party/PartyGovernance.sol

```solidity
665	    function veto(uint256 proposalId) external {
666	        _assertHost();
667	        // Setting `votes` to -1 indicates a veto.
668	        ProposalState storage info = _proposalStateByProposalId[proposalId];
669	        ProposalStateValues memory values = info.values;
670	
671	        {
672	            ProposalStatus status = _getProposalStatus(values);
673	            // Proposal must be in one of the following states.
674	            if (
675	                status != ProposalStatus.Voting &&
676	                status != ProposalStatus.Passed &&
677	                status != ProposalStatus.Ready
678	            ) {
679	                revert BadProposalStatusError(status);
680	            }
681	        }
682	
683	        // -1 indicates veto.
684	        info.values.votes = VETO_VALUE;
685	        emit ProposalVetoed(proposalId, msg.sender);
686	        // Notify third-party platforms that the governance NFT metadata has
687	        // updated for all tokens.
688	        emit BatchMetadataUpdate(0, type(uint256).max);
689	    }
690	
...
706	    function execute(
707	        uint256 proposalId,
708	        Proposal memory proposal,
709	        IERC721[] memory preciousTokens,
710	        uint256[] memory preciousTokenIds,
711	        bytes calldata progressData,
712	        bytes calldata extraData
713	    ) external payable {
714	        _assertNotGloballyDisabled();
715	        _assertActiveMember();
716	        // Get information about the proposal.
717	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
718	        // Proposal details must remain the same from `propose()`.
719	        _validateProposalHash(proposal, proposalState.hash);
720	        ProposalStateValues memory values = proposalState.values;
721	        ProposalStatus status = _getProposalStatus(values);
722	        // The proposal must be executable or have already been executed but still
723	        // has more steps to go.
724	        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {
725	            revert BadProposalStatusError(status);
726	        }
727	        if (status == ProposalStatus.Ready) {
728	            // If the proposal has not been executed yet, make sure it hasn't
729	            // expired. Note that proposals that have been executed
730	            // (but still have more steps) ignore `maxExecutableTime`.
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
738	        }
739	        // Check that the precious list is valid.
740	        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {
741	            revert BadPreciousListError();
742	        }
743	        // Preemptively set the proposal to completed to avoid it being executed
744	        // again in a deeper call.
745	        proposalState.values.completedTime = uint40(block.timestamp);
746	        // Execute the proposal.
747	        bool completed = _executeProposal(
748	            proposalId,
749	            proposal,
750	            preciousTokens,
751	            preciousTokenIds,
752	            _getProposalFlags(values),
753	            progressData,
754	            extraData
755	        );
756	        if (!completed) {
757	            // Proposal did not complete.
758	            proposalState.values.completedTime = 0;
759	        }
760	    }
761	
...
771	    function cancel(uint256 proposalId, Proposal calldata proposal) external {
772	        _assertActiveMember();
773	        // Get information about the proposal.
774	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
775	        // Proposal details must remain the same from `propose()`.
776	        _validateProposalHash(proposal, proposalState.hash);
777	        ProposalStateValues memory values = proposalState.values;
778	        {
779	            // Must be `InProgress`.
780	            ProposalStatus status = _getProposalStatus(values);
781	            if (status != ProposalStatus.InProgress) {
782	                revert BadProposalStatusError(status);
783	            }
784	        }
785	        {
786	            // Limit the `cancelDelay` to the global max and min cancel delay
787	            // to mitigate parties accidentally getting stuck forever by setting an
788	            // unrealistic `cancelDelay` or being reckless with too low a
789	            // cancel delay.
790	            uint256 cancelDelay = proposal.cancelDelay;
791	            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(
792	                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION
793	            );
794	            uint256 globalMinCancelDelay = _GLOBALS.getUint256(
795	                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION
796	            );
797	            if (globalMaxCancelDelay != 0) {
798	                // Only if we have one set.
799	                if (cancelDelay > globalMaxCancelDelay) {
800	                    cancelDelay = globalMaxCancelDelay;
801	                }
802	            }
803	            if (globalMinCancelDelay != 0) {
804	                // Only if we have one set.
805	                if (cancelDelay < globalMinCancelDelay) {
806	                    cancelDelay = globalMinCancelDelay;
807	                }
808	            }
809	            uint256 cancelTime = values.executedTime + cancelDelay;
810	            // Must not be too early.
811	            if (block.timestamp < cancelTime) {
812	                revert ProposalCannotBeCancelledYetError(
813	                    uint40(block.timestamp),
814	                    uint40(cancelTime)
815	                );
816	            }
817	        }
818	        // Mark the proposal as cancelled by setting the completed time to the current
819	        // time with the high bit set.
820	        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);
821	        {
822	            // Delegatecall into the proposal engine impl to perform the cancel.
823	            (bool success, bytes memory resultData) = (
824	                address(_getSharedProposalStorage().engineImpl)
825	            ).delegatecall(abi.encodeCall(IProposalExecutionEngine.cancelProposal, (proposalId)));
826	            if (!success) {
827	                resultData.rawRevert();
828	            }
829	        }
830	        emit ProposalCancelled(proposalId);
831	        // Notify third-party platforms that the governance NFT metadata has
832	        // updated for all tokens.
833	        emit BatchMetadataUpdate(0, type(uint256).max);
834	    }
835	
...
841	    function emergencyExecute(
842	        address targetAddress,
843	        bytes calldata targetCallData,
844	        uint256 amountEth
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
846	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
847	        if (!success) {
848	            res.rawRevert();
849	        }
850	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
851	    }
852	
...
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
...
972	    function _rebalanceDelegates(
973	        address voter,
974	        address oldDelegate,
975	        address newDelegate,
976	        VotingPowerSnapshot memory oldSnap,
977	        VotingPowerSnapshot memory newSnap
978	    ) private {
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
980	            revert InvalidDelegateError();
981	        }
982	        if (oldDelegate != voter && oldDelegate != newDelegate) {
983	            // Remove past voting power from old delegate.
984	            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(
985	                oldDelegate
986	            );
987	            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({
988	                timestamp: uint40(block.timestamp),
989	                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -
990	                    oldSnap.intrinsicVotingPower,
991	                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,
992	                isDelegated: oldDelegateSnap.isDelegated
993	            });
994	            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);
995	        }
996	        if (newDelegate != voter) {
997	            // Not delegating to self.
998	            // Add new voting power to new delegate.
999	            VotingPowerSnapshot memory newDelegateSnap = _getLastVotingPowerSnapshotForVoter(
1000	                newDelegate
1001	            );
1002	            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +
1003	                newSnap.intrinsicVotingPower;
1004	            if (newDelegate == oldDelegate) {
1005	                // If the old and new delegate are the same, subtract the old
1006	                // intrinsic voting power of the voter, or else we will double
1007	                // count a portion of it.
1008	                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;
1009	            }
1010	            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({
1011	                timestamp: uint40(block.timestamp),
1012	                delegatedVotingPower: newDelegateDelegatedVotingPower,
1013	                intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,
1014	                isDelegated: newDelegateSnap.isDelegated
1015	            });
1016	            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);
1017	        }
1018	    }
1019	
...
1021	    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap) private {
1022	        emit PartyVotingSnapshotCreated(
1023	            voter,
1024	            snap.timestamp,
1025	            snap.delegatedVotingPower,
1026	            snap.intrinsicVotingPower,
1027	            snap.isDelegated
1028	        );
1029	
1030	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1031	        uint256 n = voterSnaps.length;
1032	        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.
1033	        if (n != 0) {
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
1035	            if (lastSnap.timestamp == snap.timestamp) {
1036	                voterSnaps[n - 1] = snap;
1037	                return;
1038	            }
1039	        }
1040	        voterSnaps.push(snap);
1041	    }
1042	
...
1111	    function _isUnanimousVotes(
1112	        uint96 totalVotes,
1113	        uint96 totalVotingPower
1114	    ) private pure returns (bool) {
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
1116	        // If >= 99.99% acceptance, consider it unanimous.
1117	        // The minting formula for voting power is a bit lossy, so we check
1118	        // for slightly less than 100%.
1119	        return acceptanceRatio >= 0.9999e4;
1120	    }
1121	
```
[665..690](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L665-L690)
[706..761](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L706-L761)
[771..835](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L771-L835)
[841..852](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L841-L852)
[860..902](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L860-L902)
[972..1019](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L972-L1019)
[1021..1042](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1021-L1042)
[1111..1121](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1111-L1121)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
```
[344..448](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L344-L448)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
123	    function initialize(
124	        address oldImpl,
125	        bytes calldata initializeData
126	    ) external override onlyDelegateCall {
127	        // Prevent old parties from configuring new options to maintain security guarantees.
128	        if (oldImpl != address(0)) return;
129	
130	        // If there is no initialize data, there is nothing to do.
131	        if (initializeData.length == 0) return;
132	
133	        ProposalEngineOpts memory opts = abi.decode(initializeData, (ProposalEngineOpts));
134	
135	        // Set proposal engine opts
136	        _getSharedProposalStorage().opts = opts;
137	    }
138	
...
207	    function cancelProposal(uint256 proposalId) external onlyDelegateCall {
208	        // Must be a valid proposal ID.
209	        if (proposalId == 0) {
210	            revert ZeroProposalIdError();
211	        }
212	        Storage storage stor = _getStorage();
213	        {
214	            // Must be the current InProgress proposal.
215	            uint256 currentInProgressProposalId = stor.currentInProgressProposalId;
216	            if (currentInProgressProposalId != proposalId) {
217	                revert ProposalNotInProgressError(proposalId);
218	            }
219	        }
220	        // Clear the current InProgress proposal ID and next progress data.
221	        stor.currentInProgressProposalId = 0;
222	        stor.nextProgressDataHash = 0;
223	    }
224	
...
318	    function _executeUpgradeProposalsImplementation(bytes memory proposalData) private {
319	        (address expectedImpl, bytes memory initData) = abi.decode(proposalData, (address, bytes));
320	        // Always upgrade to latest implementation stored in `_GLOBALS`.
321	        IProposalExecutionEngine newImpl = IProposalExecutionEngine(
322	            _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)
323	        );
324	        if (expectedImpl != address(newImpl)) {
325	            revert UnexpectedProposalEngineImplementationError(
326	                newImpl,
327	                IProposalExecutionEngine(expectedImpl)
328	            );
329	        }
330	        _initProposalImpl(newImpl, initData);
331	        emit ProposalEngineImplementationUpgraded(address(implementation), expectedImpl);
332	    }
333	
```
[123..138](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L123-L138)
[207..224](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L207-L224)
[318..333](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L318-L333)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
43	    function _initProposalImpl(IProposalExecutionEngine impl, bytes memory initData) internal {
44	        SharedProposalStorage storage stor = _getSharedProposalStorage();
45	        IProposalExecutionEngine oldImpl = stor.engineImpl;
46	        stor.engineImpl = impl;
47	        (bool s, bytes memory r) = address(impl).delegatecall(
48	            abi.encodeCall(IProposalExecutionEngine.initialize, (address(oldImpl), initData))
49	        );
50	        if (!s) {
51	            r.rawRevert();
52	        }
53	    }
```
[43..53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L43-L53)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
28	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
29	        uint8 v;
30	        bytes32 r;
31	        bytes32 s;
32	        assembly {
33	            // First word of signature after size contains r
34	            r := mload(add(signature, 0x20))
35	            s := mload(add(signature, 0x40))
36	            // v is one byte which starts after s. type is uint8 so extra data will be ignored
37	            v := mload(add(signature, 0x41))
38	        }
39	
40	        bytes memory message;
41	        assembly {
42	            // Raw message data begins after v. Overwriting part of s and v with size of `message`
43	            message := add(signature, 0x41)
44	            mstore(message, sub(mload(signature), 0x41))
45	        }
46	
47	        // Recreate the message pre-hash from the raw data
48	        bytes memory encodedPacket = abi.encodePacked(
49	            "\x19Ethereum Signed Message:\n",
50	            Strings.toString(message.length),
51	            message
52	        );
53	        if (keccak256(encodedPacket) != hash) {
54	            revert MessageHashMismatch();
55	        }
56	
57	        Party party = Party(payable(msg.sender));
58	        address signer = ecrecover(hash, v, r, s);
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
60	            10000;
61	
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
63	            // Must own a party card or be delegatated voting power
64	            revert NotMemberOfParty();
65	        }
66	
67	        uint96 totalVotingPower = party.getGovernanceValues().totalVotingPower;
68	        uint96 thresholdBps = signingThersholdBps[party];
69	
70	        // Either threshold is 0 or signer votes above threshold
71	        if (
72	            thresholdBps == 0 ||
73	            (signerVotingPowerBps > totalVotingPower &&
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
75	        ) {
76	            return IERC1271.isValidSignature.selector;
77	        }
78	
79	        revert InsufficientVotingPower();
80	    }
```
[28..80](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L28-L80)


</details>

-------
### [G-10] Optimize Gas by Using Only Named Returns
<a name="G-10"></a>
[To the top](#TOP)

The Solidity compiler can generate more efficient bytecode when using named returns.
It's recommended to replace anonymous returns with named returns for potential gas savings.

Example:
```solidity
/// 985 gas cost
function add(uint256 x, uint256 y) public pure returns (uint256) {
  return x + y;
}
/// 941 gas cost
function addNamed(uint256 x, uint256 y) public pure returns (uint256 res) {
  res = x + y;
}
```

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 21 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
372	    function _createParty(
373	        ETHPartyOptions memory opts,
374	        MetadataProvider customMetadataProvider,
375	        bytes memory customMetadata
376	    ) private returns (Party) {
377	        uint256 authoritiesLength = opts.authorities.length + 1;
378	        address[] memory authorities = new address[](authoritiesLength);
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
382	        authorities[authoritiesLength - 1] = address(this);
383	
384	        if (address(customMetadataProvider) == address(0)) {
385	            return
386	                opts.governanceOpts.partyFactory.createParty(
387	                    opts.governanceOpts.partyImpl,
388	                    authorities,
389	                    Party.PartyOptions({
390	                        name: opts.name,
391	                        symbol: opts.symbol,
392	                        customizationPresetId: opts.customizationPresetId,
393	                        governance: PartyGovernance.GovernanceOpts({
394	                            hosts: opts.governanceOpts.hosts,
395	                            voteDuration: opts.governanceOpts.voteDuration,
396	                            executionDelay: opts.governanceOpts.executionDelay,
397	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
398	                            totalVotingPower: 0,
399	                            feeBps: opts.governanceOpts.feeBps,
400	                            feeRecipient: opts.governanceOpts.feeRecipient
401	                        }),
402	                        proposalEngine: opts.proposalEngineOpts
403	                    }),
404	                    opts.preciousTokens,
405	                    opts.preciousTokenIds,
406	                    opts.rageQuitTimestamp
407	                );
408	        } else {
409	            return
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
411	                    opts.governanceOpts.partyImpl,
412	                    authorities,
413	                    Party.PartyOptions({
414	                        name: opts.name,
415	                        symbol: opts.symbol,
416	                        customizationPresetId: opts.customizationPresetId,
417	                        governance: PartyGovernance.GovernanceOpts({
418	                            hosts: opts.governanceOpts.hosts,
419	                            voteDuration: opts.governanceOpts.voteDuration,
420	                            executionDelay: opts.governanceOpts.executionDelay,
421	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
422	                            totalVotingPower: 0,
423	                            feeBps: opts.governanceOpts.feeBps,
424	                            feeRecipient: opts.governanceOpts.feeRecipient
425	                        }),
426	                        proposalEngine: opts.proposalEngineOpts
427	                    }),
428	                    opts.preciousTokens,
429	                    opts.preciousTokenIds,
430	                    opts.rageQuitTimestamp,
431	                    customMetadataProvider,
432	                    customMetadata
433	                );
434	        }
435	    }
```
[372..435](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L372-L435)

---

	 - contracts/party/PartyGovernance.sol

```solidity
333	    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {
334	        return
335	            interfaceId == type(IERC721Receiver).interfaceId ||
336	            interfaceId == type(ERC1155TokenReceiverBase).interfaceId ||
337	            // ERC4906 interface ID
338	            interfaceId == 0x49064906;
339	    }
340	
...
342	    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {
343	        return _getSharedProposalStorage().engineImpl;
344	    }
345	
...
347	    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {
348	        return _getSharedProposalStorage().opts;
349	    }
350	
...
390	    function getGovernanceValues() external view returns (GovernanceValues memory) {
391	        return _getSharedProposalStorage().governanceValues;
392	    }
393	
...
1053	    function _getProposalFlags(ProposalStateValues memory pv) private pure returns (uint256) {
1054	        uint256 flags = 0;
1055	        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1056	            flags = flags | LibProposal.PROPOSAL_FLAG_UNANIMOUS;
1057	        }
1058	        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1059	            flags = flags | LibProposal.PROPOSAL_FLAG_HOSTS_ACCEPT;
1060	        }
1061	        return flags;
1062	    }
1063	
...
1111	    function _isUnanimousVotes(
1112	        uint96 totalVotes,
1113	        uint96 totalVotingPower
1114	    ) private pure returns (bool) {
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
1116	        // If >= 99.99% acceptance, consider it unanimous.
1117	        // The minting formula for voting power is a bit lossy, so we check
1118	        // for slightly less than 100%.
1119	        return acceptanceRatio >= 0.9999e4;
1120	    }
1121	
...
1122	    function _hostsAccepted(
1123	        uint8 snapshotNumHosts,
1124	        uint8 numHostsAccepted
1125	    ) private pure returns (bool) {
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
1127	    }
1128	
...
1129	    function _areVotesPassing(
1130	        uint96 voteCount,
1131	        uint96 totalVotingPower,
1132	        uint16 passThresholdBps
1133	    ) private pure returns (bool) {
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
1135	    }
1136	
...
1147	    function _isPreciousListCorrect(
1148	        IERC721[] memory preciousTokens,
1149	        uint256[] memory preciousTokenIds
1150	    ) private view returns (bool) {
1151	        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);
1152	    }
1153	
```
[333..340](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L333-L340)
[342..345](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L342-L345)
[347..350](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L347-L350)
[390..393](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L390-L393)
[1053..1063](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1053-L1063)
[1111..1121](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1111-L1121)
[1122..1128](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1122-L1128)
[1129..1136](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1129-L1136)
[1147..1153](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1147-L1153)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
113	    function supportsInterface(
114	        bytes4 interfaceId
115	    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {
116	        return
117	            PartyGovernance.supportsInterface(interfaceId) ||
118	            ERC721.supportsInterface(interfaceId) ||
119	            interfaceId == type(IERC2981).interfaceId;
120	    }
...
123	    function tokenURI(uint256) public view override returns (string memory) {
124	        _delegateToRenderer();
125	        return ""; // Just to make the compiler happy.
126	    }
...
129	    function contractURI() external view returns (string memory) {
130	        _delegateToRenderer();
131	        return ""; // Just to make the compiler happy.
132	    }
...
136	    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {
137	        _delegateToRenderer();
138	        return (address(0), 0); // Just to make the compiler happy.
139	    }
...
146	    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {
147	        return votingPowerByTokenId[tokenId];
148	    }
...
154	    function getVotingPowerShareOf(uint256 tokenId) public view returns (uint256) {
155	        uint256 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
156	        return
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
158	    }
```
[113..120](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L113-L120)
[123..126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L123-L126)
[129..132](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L129-L132)
[136..139](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L136-L139)
[146..148](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L146-L148)
[154..158](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L154-L158)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
225	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
226	        IERC1271 validator = getSignatureValidatorForHash(hash);
227	        if (address(validator) == address(1)) {
228	            // Signature set by party to be always valid
229	            return IERC1271.isValidSignature.selector;
230	        }
231	        if (address(validator) != address(0)) {
232	            return validator.isValidSignature(hash, signature);
233	        }
234	        if (tx.origin == address(0)) {
235	            validator = getSignatureValidatorForHash(0);
236	            if (address(validator) == address(0)) {
237	                // Use global off-chain signature validator
238	                validator = IERC1271(
239	                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)
240	                );
241	            }
242	            return validator.isValidSignature(hash, signature);
243	        }
244	        return 0;
245	    }
246	
```
[225..246](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L225-L246)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
25	    function _executeSetGovernanceParameter(
26	        IProposalExecutionEngine.ExecuteProposalParams memory params
27	    ) internal returns (bytes memory) {
28	        SetGovernanceParameterProposalData memory proposalData = abi.decode(
29	            params.proposalData,
30	            (SetGovernanceParameterProposalData)
31	        );
32	        if (proposalData.voteDuration != 0) {
33	            if (proposalData.voteDuration < 1 hours) {
34	                revert InvalidGovernanceParameter(proposalData.voteDuration);
35	            }
36	            emit VoteDurationSet(
37	                _getSharedProposalStorage().governanceValues.voteDuration,
38	                proposalData.voteDuration
39	            );
40	            _getSharedProposalStorage().governanceValues.voteDuration = proposalData.voteDuration;
41	        }
42	        if (proposalData.executionDelay != 0) {
43	            if (proposalData.executionDelay > 30 days) {
44	                revert InvalidGovernanceParameter(proposalData.executionDelay);
45	            }
46	            emit ExecutionDelaySet(
47	                _getSharedProposalStorage().governanceValues.executionDelay,
48	                proposalData.executionDelay
49	            );
50	            _getSharedProposalStorage().governanceValues.executionDelay = proposalData
51	                .executionDelay;
52	        }
53	        if (proposalData.passThresholdBps != 0) {
54	            if (proposalData.passThresholdBps > 10000) {
55	                revert InvalidGovernanceParameter(proposalData.passThresholdBps);
56	            }
57	            emit PassThresholdBpsSet(
58	                _getSharedProposalStorage().governanceValues.passThresholdBps,
59	                proposalData.passThresholdBps
60	            );
61	            _getSharedProposalStorage().governanceValues.passThresholdBps = proposalData
62	                .passThresholdBps;
63	        }
64	
65	        return "";
66	    }
```
[25..66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L25-L66)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
42	    function getSignatureValidatorForHash(bytes32 hash) public view returns (IERC1271) {
43	        return _getSetSignatureValidatorProposalStorage().signatureValidators[hash];
44	    }
```
[42..44](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L42-L44)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
28	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
29	        uint8 v;
30	        bytes32 r;
31	        bytes32 s;
32	        assembly {
33	            // First word of signature after size contains r
34	            r := mload(add(signature, 0x20))
35	            s := mload(add(signature, 0x40))
36	            // v is one byte which starts after s. type is uint8 so extra data will be ignored
37	            v := mload(add(signature, 0x41))
38	        }
39	
40	        bytes memory message;
41	        assembly {
42	            // Raw message data begins after v. Overwriting part of s and v with size of `message`
43	            message := add(signature, 0x41)
44	            mstore(message, sub(mload(signature), 0x41))
45	        }
46	
47	        // Recreate the message pre-hash from the raw data
48	        bytes memory encodedPacket = abi.encodePacked(
49	            "\x19Ethereum Signed Message:\n",
50	            Strings.toString(message.length),
51	            message
52	        );
53	        if (keccak256(encodedPacket) != hash) {
54	            revert MessageHashMismatch();
55	        }
56	
57	        Party party = Party(payable(msg.sender));
58	        address signer = ecrecover(hash, v, r, s);
59	        uint96 signerVotingPowerBps = party.getVotingPowerAt(signer, uint40(block.timestamp)) *
60	            10000;
61	
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
63	            // Must own a party card or be delegatated voting power
64	            revert NotMemberOfParty();
65	        }
66	
67	        uint96 totalVotingPower = party.getGovernanceValues().totalVotingPower;
68	        uint96 thresholdBps = signingThersholdBps[party];
69	
70	        // Either threshold is 0 or signer votes above threshold
71	        if (
72	            thresholdBps == 0 ||
73	            (signerVotingPowerBps > totalVotingPower &&
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
75	        ) {
76	            return IERC1271.isValidSignature.selector;
77	        }
78	
79	        revert InsufficientVotingPower();
80	    }
```
[28..80](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L28-L80)

---

	 - contracts/utils/Implementation.sol

```solidity
40	    function IMPL() external view returns (address) {
41	        return implementation;
42	    }
```
[40..42](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L40-L42)


</details>

-------
### [G-11] Trade-offs Between Modifiers and Internal Functions
<a name="G-11"></a>
[To the top](#TOP)

In Solidity, both internal functions and modifiers are used to refactor and manage code, but they come with their own trade-offs, especially in terms of gas cost and flexibility.

#### Modifiers:
- Less runtime gas cost (saves around 24 gas per function call).
- Increases deployment gas cost due to repetitive code.
- Can only be executed at the start or end of a function.

#### Internal Functions:
- Lower deployment cost.
- Can be executed at any point in a function.
- Slightly higher runtime gas cost (24 gas) due to the need to jump to the function's location in bytecode.

#### Recommendations:
- Use modifiers for high-frequency functions where runtime gas cost matters the most.
- Use internal functions where the priority is reducing deployment gas cost or when you need more flexibility in the function's logic.

Example analysis shows that using modifiers can increase deployment costs by over 35k gas but save 24 gas per function call during runtime. Choose wisely based on your specific use case.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 20 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
113	    ) external payable onlyInitialize {
...
167	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
...
189	    ) public payable onlyDelegateCall returns (uint96 votingPower) {
...
206	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
...
240	    ) external payable onlyDelegateCall returns (uint96 votingPower) {
...
257	    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {
```
[113](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L113)
[167](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L167)
[189](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L189)
[206](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L206)
[240](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L240)
[257](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L257)

---

	 - contracts/party/PartyGovernance.sol

```solidity
231	    modifier onlyPartyDao() {
232	        {
233	            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
234	            if (msg.sender != partyDao) {
235	                revert NotAuthorized();
236	            }
237	        }
238	        _;
239	    }
240	
...
242	    modifier onlyPartyDaoOrHost() {
243	        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
244	        if (msg.sender != partyDao && !isHost[msg.sender]) {
245	            revert NotAuthorized();
246	        }
247	        _;
248	    }
249	
...
251	    modifier onlyWhenEmergencyExecuteAllowed() {
252	        if (emergencyExecuteDisabled) {
253	            revert OnlyWhenEmergencyActionsAllowedError();
254	        }
255	        _;
256	    }
257	
...
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
...
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
...
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
...
855	    function disableEmergencyExecute() external onlyPartyDaoOrHost {
```
[231..240](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L231-L240)
[242..249](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L242-L249)
[251..257](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L251-L257)
[845](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L845)
[845](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L845)
[845](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L845)
[855](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L855)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
67	    modifier onlySelf() {
68	        if (msg.sender != address(this)) {
69	            revert NotAuthorized();
70	        }
71	        _;
72	    }
...
479	    function addAuthority(address authority) external onlySelf {
```
[67..72](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L67-L72)
[479](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L479)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
126	    ) external override onlyDelegateCall {
...
148	    ) external onlyDelegateCall returns (bytes memory nextProgressData) {
...
207	    function cancelProposal(uint256 proposalId) external onlyDelegateCall {
```
[126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L126)
[148](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L148)
[207](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L207)

---

	 - contracts/utils/Implementation.sol

```solidity
22	    modifier onlyDelegateCall() virtual {
23	        if (address(this) == implementation) {
24	            revert OnlyDelegateCallError();
25	        }
26	        _;
27	    }
...
29	    modifier onlyInitialize() {
30	        if (initialized) revert AlreadyInitialized();
31	
32	        initialized = true;
33	        emit Initialized();
34	
35	        _;
36	    }
```
[22..27](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L22-L27)
[29..36](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L29-L36)


</details>

-------
### [G-12] Use assembly to check for `address(0)`
<a name="G-12"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 18 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
283	        if (delegate == address(0)) {
...
289	        if (_gateKeeper != IGateKeeper(address(0))) {
...
384	        if (address(customMetadataProvider) == address(0)) {
```
[283](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L283)
[289](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L289)
[384](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L384)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
...
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
```
[202](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L202)
[263](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263)
[286](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286)
[324](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324)
[348](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L348)

---

	 - contracts/party/PartyGovernance.sol

```solidity
460	        if (newPartyHost != address(0)) {
...
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
...
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
...
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
...
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
```
[460](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L460)
[949](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L949)
[951](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L951)
[979](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L979)
[979](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L979)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
196	        if (delegate_ != address(0)) {
```
[196](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L196)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
128	        if (oldImpl != address(0)) return;
...
231	        if (address(validator) != address(0)) {
...
234	        if (tx.origin == address(0)) {
...
236	            if (address(validator) == address(0)) {
```
[128](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L128)
[231](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L231)
[234](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L234)
[236](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L236)


</details>

-------
### [G-13] Consider Packing Small `uint` When it's Possible
<a name="G-13"></a>
[To the top](#TOP)

Packing `uint` variables into the same storage slot can help in reducing gas costs.
This is particularly useful when storing or reading multiple smaller uints (e.g., uint80) in a single transaction.
Consider using bit manipulation to pack these variables.

If you pack two `uint` variables into a single `uint` storage slot, you'd perform only one SLOAD operation (800 gas) instead of two (1,600 gas) when you read them.
This saves 800 gas for each read operation involving the two variables.

Similarly, when you need to update both variables, a single SSTORE operation would cost you 20,000 gas instead of 40,000 gas, saving you another 20,000 gas. 

Example:
```Solidity
uint160 packedVariables;

function packVariables(uint80 x, uint80 y) external {
  packedVariables = uint160(x) << 80 | uint160(y);
}
```

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 18 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
95	    uint96 public minContribution;
...
98	    uint96 public maxContribution;
...
109	    uint96 public minTotalContributions;
...
112	    uint96 public maxTotalContributions;
...
114	    uint96 public totalContributions;
...
117	    uint40 public expiry;
...
120	    uint16 public exchangeRateBps;
...
123	    uint16 public fundingSplitBps;
```
[95](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L95)
[98](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L98)
[109](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L109)
[112](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L112)
[114](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L114)
[117](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L117)
[120](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L120)
[123](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L123)

---

	 - contracts/party/PartyGovernance.sol

```solidity
187	    uint96 private constant VETO_VALUE = type(uint96).max;
...
196	    uint16 public feeBps;
...
200	    uint40 public lastRageQuitTimestamp;
...
210	    uint8 public numHosts;
```
[187](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L187)
[196](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L196)
[200](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L200)
[210](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L210)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
34	    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256("ENABLE_RAGEQUIT_PERMANENTLY")))
...
35	    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256("DISABLE_RAGEQUIT_PERMANENTLY")))
...
45	    uint96 public tokenCount;
...
49	    uint96 public mintedVotingPower;
...
55	    uint40 public rageQuitTimestamp;
```
[34](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L34)
[35](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L35)
[45](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L45)
[49](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L49)
[55](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L55)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
22	    mapping(Party party => uint96 thresholdBps) public signingThersholdBps;
```
[22](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L22)


</details>

-------
### [G-14] `>=` costs less gas than `>`
<a name="G-14"></a>
[To the top](#TOP)

The compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires LT for `>=`, which saves 3 gas. Similarly for `<=`.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 16 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
141	        if (initialContribution > 0) {
...
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
...
331	        if (amount > 0) {
```
[141](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L141)
[224](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L224)
[331](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L331)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
239	            if (refundAmount > 0) {
...
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
```
[239](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L239)
[263](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263)
[286](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286)
[324](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324)

---

	 - contracts/party/PartyGovernance.sol

```solidity
277	        if (govOpts.feeBps > 1e4) {
...
280	        if (govOpts.passThresholdBps > 1e4) {
...
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
```
[277](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L277)
[280](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L280)
[1126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1126)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
415	                if (fee > 0) {
...
426	                if (amount > 0) {
```
[415](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L415)
[426](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L426)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
303	        if (proposalData.length < 4) {
```
[303](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L303)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
33	            if (proposalData.voteDuration < 1 hours) {
...
43	            if (proposalData.executionDelay > 30 days) {
...
54	            if (proposalData.passThresholdBps > 10000) {
```
[33](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L33)
[43](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L43)
[54](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L54)


</details>

-------
### [G-15] Consider Caching Multiple Accesses to Mappings/Arrays
<a name="G-15"></a>
[To the top](#TOP)

Leveraging a local variable to cache these values when accessed more than once can yield a gas saving of approximately 42 units per access. This reduction is attributed to eliminating the need for recalculating the key's keccak256 hash (which costs Gkeccak256 - 30 gas) and the associated stack operations. For arrays, this also prevents the overhead of re-computing offsets in memory or calldata.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 15 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
372	    function _createParty(
373	        ETHPartyOptions memory opts,
374	        MetadataProvider customMetadataProvider,
375	        bytes memory customMetadata
376	    ) private returns (Party) {
377	        uint256 authoritiesLength = opts.authorities.length + 1;
378	        address[] memory authorities = new address[](authoritiesLength);
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
382	        authorities[authoritiesLength - 1] = address(this);
383	
384	        if (address(customMetadataProvider) == address(0)) {
385	            return
386	                opts.governanceOpts.partyFactory.createParty(
387	                    opts.governanceOpts.partyImpl,
388	                    authorities,
389	                    Party.PartyOptions({
390	                        name: opts.name,
391	                        symbol: opts.symbol,
392	                        customizationPresetId: opts.customizationPresetId,
393	                        governance: PartyGovernance.GovernanceOpts({
394	                            hosts: opts.governanceOpts.hosts,
395	                            voteDuration: opts.governanceOpts.voteDuration,
396	                            executionDelay: opts.governanceOpts.executionDelay,
397	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
398	                            totalVotingPower: 0,
399	                            feeBps: opts.governanceOpts.feeBps,
400	                            feeRecipient: opts.governanceOpts.feeRecipient
401	                        }),
402	                        proposalEngine: opts.proposalEngineOpts
403	                    }),
404	                    opts.preciousTokens,
405	                    opts.preciousTokenIds,
406	                    opts.rageQuitTimestamp
407	                );
408	        } else {
409	            return
410	                opts.governanceOpts.partyFactory.createPartyWithMetadata(
411	                    opts.governanceOpts.partyImpl,
412	                    authorities,
413	                    Party.PartyOptions({
414	                        name: opts.name,
415	                        symbol: opts.symbol,
416	                        customizationPresetId: opts.customizationPresetId,
417	                        governance: PartyGovernance.GovernanceOpts({
418	                            hosts: opts.governanceOpts.hosts,
419	                            voteDuration: opts.governanceOpts.voteDuration,
420	                            executionDelay: opts.governanceOpts.executionDelay,
421	                            passThresholdBps: opts.governanceOpts.passThresholdBps,
422	                            totalVotingPower: 0,
423	                            feeBps: opts.governanceOpts.feeBps,
424	                            feeRecipient: opts.governanceOpts.feeRecipient
425	                        }),
426	                        proposalEngine: opts.proposalEngineOpts
427	                    }),
428	                    opts.preciousTokens,
429	                    opts.preciousTokenIds,
430	                    opts.rageQuitTimestamp,
431	                    customMetadataProvider,
432	                    customMetadata
433	                );
434	        }
435	    }
```
[372..435](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L372-L435)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
```
[196..274](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L196-L274)

---

	 - contracts/party/PartyGovernance.sol

```solidity
423	    function findVotingPowerSnapshotIndex(
424	        address voter,
425	        uint40 timestamp
426	    ) public view returns (uint256 index) {
427	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
428	
429	        // Derived from Open Zeppelin binary search
430	        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39
431	        uint256 high = snaps.length;
432	        uint256 low = 0;
433	        while (low < high) {
434	            uint256 mid = (low + high) / 2;
435	            if (snaps[mid].timestamp > timestamp) {
436	                // Entry is too recent.
437	                high = mid;
438	            } else {
439	                // Entry is older. This is our best guess for now.
440	                low = mid + 1;
441	            }
442	        }
443	
444	        // Return `type(uint256).max` if no valid voting snapshots found.
445	        return high == 0 ? type(uint256).max : high - 1;
446	    }
447	
...
457	    function abdicateHost(address newPartyHost) external {
458	        _assertHost();
459	        // 0 is a special case burn address.
460	        if (newPartyHost != address(0)) {
461	            // Cannot transfer host status to an existing host.
462	            if (isHost[newPartyHost]) {
463	                revert InvalidNewHostError();
464	            }
465	            isHost[newPartyHost] = true;
466	        } else {
467	            // Burned the host status
468	            --numHosts;
469	        }
470	        isHost[msg.sender] = false;
471	        emit HostStatusTransferred(msg.sender, newPartyHost);
472	    }
473	
...
553	    function propose(
554	        Proposal memory proposal,
555	        uint256 latestSnapIndex
556	    ) external returns (uint256 proposalId) {
557	        _assertActiveMember();
558	        proposalId = ++lastProposalId;
559	        // Store the time the proposal was created and the proposal hash.
560	        (
561	            _proposalStateByProposalId[proposalId].values,
562	            _proposalStateByProposalId[proposalId].hash
563	        ) = (
564	            ProposalStateValues({
565	                proposedTime: uint40(block.timestamp),
566	                passedTime: 0,
567	                executedTime: 0,
568	                completedTime: 0,
569	                votes: 0,
570	                totalVotingPower: _getSharedProposalStorage().governanceValues.totalVotingPower,
571	                numHosts: numHosts,
572	                numHostsAccepted: 0
573	            }),
574	            getProposalHash(proposal)
575	        );
576	        emit Proposed(proposalId, msg.sender, proposal);
577	        accept(proposalId, latestSnapIndex);
578	
579	        // Notify third-party platforms that the governance NFT metadata has
580	        // updated for all tokens.
581	        emit BatchMetadataUpdate(0, type(uint256).max);
582	    }
583	
...
595	    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {
596	        // Get the information about the proposal.
597	        ProposalState storage info = _proposalStateByProposalId[proposalId];
598	        ProposalStateValues memory values = info.values;
599	
600	        // Can only vote in certain proposal statuses.
601	        {
602	            ProposalStatus status = _getProposalStatus(values);
603	            // Allow voting even if the proposal is passed/ready so it can
604	            // potentially reach 100% consensus, which unlocks special
605	            // behaviors for certain proposal types.
606	            if (
607	                status != ProposalStatus.Voting &&
608	                status != ProposalStatus.Passed &&
609	                status != ProposalStatus.Ready
610	            ) {
611	                revert BadProposalStatusError(status);
612	            }
613	        }
614	
615	        // Prevent voting in the same block as the last rage quit timestamp.
616	        // This is to prevent an exploit where a member can rage quit to reduce
617	        // the total voting power of the party, then propose and vote in the
618	        // same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.
619	        // This would allow them to use the voting power snapshot just before
620	        // their card was burned to vote, potentially passing a proposal that
621	        // would have otherwise not passed.
622	        if (lastRageQuitTimestamp == block.timestamp) {
623	            revert CannotRageQuitAndAcceptError();
624	        }
625	
626	        // Cannot vote twice.
627	        if (info.hasVoted[msg.sender]) {
628	            revert AlreadyVotedError(msg.sender);
629	        }
630	        // Mark the caller as having voted.
631	        info.hasVoted[msg.sender] = true;
632	
633	        // Increase the total votes that have been cast on this proposal.
634	        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);
635	        values.votes += votingPower;
636	        if (isHost[msg.sender]) {
637	            ++values.numHostsAccepted;
638	        }
639	        info.values = values;
640	        emit ProposalAccepted(proposalId, msg.sender, votingPower);
641	
642	        // Update the proposal status if it has reached the pass threshold.
643	        if (
644	            values.passedTime == 0 &&
645	            _areVotesPassing(
646	                values.votes,
647	                values.totalVotingPower,
648	                _getSharedProposalStorage().governanceValues.passThresholdBps
649	            )
650	        ) {
651	            info.values.passedTime = uint40(block.timestamp);
652	            emit ProposalPassed(proposalId);
653	            // Notify third-party platforms that the governance NFT metadata has
654	            // updated for all tokens.
655	            emit BatchMetadataUpdate(0, type(uint256).max);
656	        }
657	        return values.votes;
658	    }
659	
...
904	    function _getVotingPowerSnapshotAt(
905	        address voter,
906	        uint40 timestamp,
907	        uint256 hintIndex
908	    ) internal view returns (VotingPowerSnapshot memory snap) {
909	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
910	        uint256 snapsLength = snaps.length;
911	        if (snapsLength != 0) {
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
923	            // Hint was wrong, fallback to binary search to find snapshot.
924	            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);
925	            // Check that snapshot was found.
926	            if (hintIndex != type(uint256).max) {
927	                return snaps[hintIndex];
928	            }
929	        }
930	
931	        // No snapshot found.
932	        return snap;
933	    }
934	
...
944	    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {
945	        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);
946	        address oldDelegate = delegationsByVoter[voter];
947	        // If `oldDelegate` is zero and `voter` never delegated, then have
948	        // `voter` delegate to themself.
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
950	        // If the new `delegate` is zero, use the current (old) delegate.
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
952	
953	        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({
954	            timestamp: uint40(block.timestamp),
955	            delegatedVotingPower: oldSnap.delegatedVotingPower,
956	            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +
957	                votingPower).safeCastInt192ToUint96(),
958	            isDelegated: delegate != voter
959	        });
960	        _insertVotingPowerSnapshot(voter, newSnap);
961	        delegationsByVoter[voter] = delegate;
962	
963	        // This event is emitted even if the delegate did not change.
964	        emit PartyDelegateUpdated(voter, delegate);
965	
966	        // Handle rebalancing delegates.
967	        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);
968	    }
969	
...
1021	    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap) private {
1022	        emit PartyVotingSnapshotCreated(
1023	            voter,
1024	            snap.timestamp,
1025	            snap.delegatedVotingPower,
1026	            snap.intrinsicVotingPower,
1027	            snap.isDelegated
1028	        );
1029	
1030	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1031	        uint256 n = voterSnaps.length;
1032	        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.
1033	        if (n != 0) {
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
1035	            if (lastSnap.timestamp == snap.timestamp) {
1036	                voterSnaps[n - 1] = snap;
1037	                return;
1038	            }
1039	        }
1040	        voterSnaps.push(snap);
1041	    }
1042	
...
1043	    function _getLastVotingPowerSnapshotForVoter(
1044	        address voter
1045	    ) private view returns (VotingPowerSnapshot memory snap) {
1046	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1047	        uint256 n = voterSnaps.length;
1048	        if (n != 0) {
1049	            snap = voterSnaps[n - 1];
1050	        }
1051	    }
1052	
```
[423..447](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L423-L447)
[457..473](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L457-L473)
[553..583](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L553-L583)
[595..659](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L595-L659)
[904..934](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L904-L934)
[944..969](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L944-L969)
[1021..1042](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1021-L1042)
[1043..1052](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1043-L1052)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
208	    function increaseVotingPower(uint256 tokenId, uint96 votingPower) external {
209	        _assertAuthority();
210	        uint96 mintedVotingPower_ = mintedVotingPower;
211	        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;
212	
213	        // Cap voting power to remaining unminted voting power supply. Allow
214	        // minting past total voting power if minting party cards for initial
215	        // crowdfund when there is no total voting power.
216	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {
217	            unchecked {
218	                votingPower = totalVotingPower - mintedVotingPower_;
219	            }
220	        }
221	
222	        // Update state.
223	        mintedVotingPower += votingPower;
224	        uint256 newIntrinsicVotingPower = votingPowerByTokenId[tokenId] + votingPower;
225	        votingPowerByTokenId[tokenId] = newIntrinsicVotingPower;
226	
227	        emit PartyCardIntrinsicVotingPowerSet(tokenId, newIntrinsicVotingPower);
228	
229	        _adjustVotingPower(ownerOf(tokenId), votingPower.safeCastUint96ToInt192(), address(0));
230	    }
...
268	    function _burnAndUpdateVotingPower(
269	        uint256[] memory tokenIds,
270	        bool checkIfAuthorizedToBurn
271	    ) private returns (uint96 totalVotingPowerBurned) {
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
302	
303	        // Update minted voting power.
304	        mintedVotingPower -= totalVotingPowerBurned;
305	    }
...
310	    function burn(uint256 tokenId) external {
311	        uint256[] memory tokenIds = new uint256[](1);
312	        tokenIds[0] = tokenId;
313	        burn(tokenIds);
314	    }
...
344	    function rageQuit(
345	        uint256[] calldata tokenIds,
346	        IERC20[] calldata withdrawTokens,
347	        uint256[] calldata minWithdrawAmounts,
348	        address receiver
349	    ) external {
350	        if (tokenIds.length == 0) revert NothingToBurnError();
351	
352	        // Check if called by an authority.
353	        bool isAuthority_ = isAuthority[msg.sender];
354	
355	        // Check if ragequit is allowed.
356	        uint40 currentRageQuitTimestamp = rageQuitTimestamp;
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
367	
368	        // Used as a reentrancy guard. Will be updated back after ragequit.
369	        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;
370	
371	        // Update last rage quit timestamp.
372	        lastRageQuitTimestamp = uint40(block.timestamp);
373	
374	        // Sum up total amount of each token to withdraw.
375	        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);
376	        {
377	            IERC20 prevToken;
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
396	        }
397	        {
398	            // Burn caller's party cards. This will revert if caller is not the
399	            // the owner or approved for any of the card they are attempting to
400	            // burn, not an authority, or if there are duplicate token IDs.
401	            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);
402	
403	            // Update total voting power of party.
404	            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;
405	        }
406	        {
407	            uint16 feeBps_ = feeBps;
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
442	        }
443	
444	        // Update ragequit timestamp back to before.
445	        rageQuitTimestamp = currentRageQuitTimestamp;
446	
447	        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);
448	    }
```
[208..230](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L208-L230)
[268..305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L268-L305)
[310..314](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L310-L314)
[344..448](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L344-L448)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
84	    function setSigningThresholdBps(uint96 thresholdBps) external {
85	        Party party = Party(payable(msg.sender));
86	        emit SigningThresholdBpsSet(party, signingThersholdBps[party], thresholdBps);
87	        signingThersholdBps[party] = thresholdBps;
88	    }
```
[84..88](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L84-L88)


</details>

-------
### [G-16] Add `unchecked` blocks for divisions where the operands cannot overflow
<a name="G-16"></a>
[To the top](#TOP)

`uint` divisions can't overflow, while `int` divisions can overflow only in [one specific case](https://docs.soliditylang.org/en/latest/types.html#division).

Consider adding an `unchecked` block to have some [gas savings](https://gist.github.com/DadeKuma/3bc597338ae774b8b3bd43280d55271f).

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 14 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
...
270	        votingPower = (amount * exchangeRateBps) / 1e4;
...
281	        amount = (votingPower * 1e4) / exchangeRateBps;
...
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
...
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
...
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
...
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
```
[266](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L266)
[270](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L270)
[281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L281)
[287](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L287)
[325](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L325)
[329](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L329)
[355](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L355)

---

	 - contracts/party/PartyGovernance.sol

```solidity
434	            uint256 mid = (low + high) / 2;
...
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
...
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
```
[434](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L434)
[1115](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1115)
[1134](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1134)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
157	            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;
...
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
...
413	                uint256 fee = (amount * feeBps_) / 1e4;
```
[157](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L157)
[393](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L393)
[413](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L413)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
```
[74](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L74)


</details>

-------
### [G-17] Optimize Gas by Using Do-While Loops
<a name="G-17"></a>
[To the top](#TOP)

Using `do-while` loops instead of `for` loops can be more gas-efficient. 
Even if you add an `if` condition to account for the case where the loop doesn't execute at all, a `do-while` loop can still be cheaper in terms of gas.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 11 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
211	        for (uint256 i; i < numContributions; ++i) {
212	            ethAvailable -= args.values[i];
213	
214	            votingPowers[i] = _contribute(
215	                payable(msg.sender),
216	                args.delegate,
217	                args.values[i],
218	                args.tokenIds[i],
219	                args.gateDatas[i]
220	            );
221	        }
...
260	        for (uint256 i; i < args.recipients.length; ++i) {
261	            votingPowers[i] = _contribute(
262	                args.recipients[i],
263	                args.initialDelegates[i],
264	                args.values[i],
265	                args.tokenIds[i],
266	                args.gateDatas[i]
267	            );
268	            valuesSum += args.values[i];
269	        }
...
357	        for (uint256 i; i < numRefunds; ++i) {
358	            (bool s, bytes memory r) = address(this).call(
359	                abi.encodeCall(this.refund, (tokenIds[i]))
360	            );
361	
362	            if (!s) {
363	                if (revertOnFailure) {
364	                    r.rawRevert();
365	                }
366	            } else {
367	                amounts[i] = abi.decode(r, (uint96));
368	            }
369	        }
...
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
```
[211..221](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L211-L221)
[260..269](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L260-L269)
[357..369](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L357-L369)
[379..381](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L379-L381)

---

	 - contracts/party/PartyGovernance.sol

```solidity
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
...
433	        while (low < high) {
434	            uint256 mid = (low + high) / 2;
435	            if (snaps[mid].timestamp > timestamp) {
436	                // Entry is too recent.
437	                high = mid;
438	            } else {
439	                // Entry is older. This is our best guess for now.
440	                low = mid + 1;
441	            }
442	        }
443	
```
[305..308](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L305-L308)
[433..443](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L433-L443)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
...
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
...
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
...
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
...
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
```
[102..104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L102-L104)
[272..301](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L272-L301)
[378..395](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L378-L395)
[391..394](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L391-L394)
[408..441](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L408-L441)


</details>

-------
### [G-18] `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops
<a name="G-18"></a>
[To the top](#TOP)

The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 10 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
211	        for (uint256 i; i < numContributions; ++i) {
212	            ethAvailable -= args.values[i];
213	
214	            votingPowers[i] = _contribute(
215	                payable(msg.sender),
216	                args.delegate,
217	                args.values[i],
218	                args.tokenIds[i],
219	                args.gateDatas[i]
220	            );
221	        }
...
260	        for (uint256 i; i < args.recipients.length; ++i) {
261	            votingPowers[i] = _contribute(
262	                args.recipients[i],
263	                args.initialDelegates[i],
264	                args.values[i],
265	                args.tokenIds[i],
266	                args.gateDatas[i]
267	            );
268	            valuesSum += args.values[i];
269	        }
...
357	        for (uint256 i; i < numRefunds; ++i) {
358	            (bool s, bytes memory r) = address(this).call(
359	                abi.encodeCall(this.refund, (tokenIds[i]))
360	            );
361	
362	            if (!s) {
363	                if (revertOnFailure) {
364	                    r.rawRevert();
365	                }
366	            } else {
367	                amounts[i] = abi.decode(r, (uint96));
368	            }
369	        }
...
379	        for (uint i = 0; i < authoritiesLength - 1; ++i) {
380	            authorities[i] = opts.authorities[i];
381	        }
```
[211..221](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L211-L221)
[260..269](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L260-L269)
[357..369](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L357-L369)
[379..381](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L379-L381)

---

	 - contracts/party/PartyGovernance.sol

```solidity
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
```
[305..308](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L305-L308)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
...
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
...
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
...
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
...
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
```
[102..104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L102-L104)
[272..301](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L272-L301)
[378..395](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L378-L395)
[391..394](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L391-L394)
[408..441](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L408-L441)


</details>

-------
### [G-19] Use at least Solidity version `0.8.19` to gain some gas boost
<a name="G-19"></a>
[To the top](#TOP)

Upgrade to at least solidity version 0.8.19 to get additional gas savings. Check the [documentation](https://blog.soliditylang.org/2263/26/22/solidity-0.8.19-release-announcement/) for reference.

Some additional details:
> In earlier releases and in the default legacy code generation, when an internal library function or a free function accessed via a module was called only during contract creation, e.g. only in the constructor, a copy of the function still also occurred in the contract’s runtime bytecode.
>
>So a function pointer in creation code also refers to the offset of the function in runtime code, which requires the function to actually be present in runtime code.
>
>For direct calls to internal contract functions the full encoding of the function expression is bypassed by the compiler. However, this bypassing did not happen for internal library functions and for free functions called via modules, causing the undesirable behaviour that is now fixed in this release.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 10 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L2)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L2)

---

	 - contracts/party/PartyGovernance.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L2)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L2)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L2)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L2)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L2)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L2)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L2)

---

	 - contracts/utils/Implementation.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L2)


</details>

-------
### [G-20] Optimize Unsigned Integer Comparison With Zero
<a name="G-20"></a>
[To the top](#TOP)

For unsigned integers, checking whether the integer is not equal to zero (`!= 0`) is less gas-intensive than checking whether it is greater than zero (`> 0`). 

This is because the Ethereum Virtual Machine (EVM) can perform a simple bitwise operation to check if any bit is set (which directly translates to `!= 0`), while checking for `> 0` requires additional logic.

As such, when dealing with unsigned integers in Solidity, it is recommended to use the `!= 0` comparison for gas optimization.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 10 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
141	        if (initialContribution > 0) {
...
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
...
331	        if (amount > 0) {
```
[141](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L141)
[224](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L224)
[331](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L331)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
239	            if (refundAmount > 0) {
...
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
```
[239](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L239)
[263](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263)
[286](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286)
[324](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324)

---

	 - contracts/party/PartyGovernance.sol

```solidity
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
```
[1126](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1126)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
415	                if (fee > 0) {
...
426	                if (amount > 0) {
```
[415](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L415)
[426](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L426)


</details>

-------
### [G-21] `<array>.length` Should Not Be Looked Up In Every Loop Of A For-loop
<a name="G-21"></a>
[To the top](#TOP)

The overheads outlined below are PER LOOP, excluding the first loop

storage arrays incur a Gwarmaccess (100 gas)
memory arrays use MLOAD (3 gas)
calldata arrays use CALLDATALOAD (3 gas)

Caching the length changes each of these to a DUP<N> (3 gas), and gets rid of the extra DUP<N> needed to store the stack offset

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 7 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
260	        for (uint256 i; i < args.recipients.length; ++i) {
```
[260](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L260)

---

	 - contracts/party/PartyGovernance.sol

```solidity
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
```
[305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L305)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
102	            for (uint256 i; i < authorities.length; ++i) {
...
272	        for (uint256 i; i < tokenIds.length; ++i) {
...
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
...
391	                for (uint256 j; j < tokenIds.length; ++j) {
...
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
```
[102](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L102)
[272](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L272)
[378](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L378)
[391](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L391)
[408](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L408)


</details>

-------
### [G-22] Using `bool` for storage incurs overhead
<a name="G-22"></a>
[To the top](#TOP)

Use `uint256(1)` and `uint256(2)` for `true`/`false` to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from `false` to `true`, after having been `true` in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27).

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 7 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
101	    bool public disableContributingForExistingCard;
...
104	    bool public fundingSplitPaid;
...
106	    bool public emergencyExecuteDisabled;
```
[101](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L101)
[104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L104)
[106](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L106)

---

	 - contracts/party/PartyGovernance.sol

```solidity
194	    bool public emergencyExecuteDisabled;
...
206	    mapping(address => bool) public isHost;
```
[194](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L194)
[206](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L206)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
59	    mapping(address => bool) public isAuthority;
```
[59](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L59)

---

	 - contracts/utils/Implementation.sol

```solidity
15	    bool public initialized;
```
[15](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L15)


</details>

-------
### [G-23] Optimize Boolean States with `uint256(1/2)`
<a name="G-23"></a>
[To the top](#TOP)

Boolean variables in Solidity are more expensive than `uint256` or any type that takes up a full word, due to additional gas costs associated with write operations.
When using boolean variables, each write operation emits an extra SLOAD to read the slot's contents, replace the bits taken up by the boolean, and then write back.
This process cannot be disabled and leads to extra gas consumption.

By using `uint256(1)` and `uint256(2)` for representing true and false states, you can avoid a `Gwarmaccess` (100 gas) cost and also avoid a `Gsset` (20000 gas) cost when changing from `false` to `true`, after having been `true` in the past.
This approach helps in optimizing gas usage, making your contract more cost-effective.

[Usage in OpenZeppelin ReentrancyGuard.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27)

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 7 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
101	    bool public disableContributingForExistingCard;
...
104	    bool public fundingSplitPaid;
...
106	    bool public emergencyExecuteDisabled;
```
[101](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L101)
[104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L104)
[106](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L106)

---

	 - contracts/party/PartyGovernance.sol

```solidity
194	    bool public emergencyExecuteDisabled;
...
206	    mapping(address => bool) public isHost;
```
[194](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L194)
[206](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L206)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
59	    mapping(address => bool) public isAuthority;
```
[59](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L59)

---

	 - contracts/utils/Implementation.sol

```solidity
15	    bool public initialized;
```
[15](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L15)


</details>

-------
### [G-24] `Internal` functions only called once can be inlined to save gas
<a name="G-24"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 6 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
140	    function _initialize(ETHCrowdfundOptions memory opts) internal {
141	        // Set the minimum and maximum contribution amounts.
142	        if (opts.minContribution > opts.maxContribution) {
143	            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);
144	        }
145	        minContribution = opts.minContribution;
146	        maxContribution = opts.maxContribution;
147	        // Set the min total contributions.
148	        if (opts.minTotalContributions > opts.maxTotalContributions) {
149	            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);
150	        }
151	        minTotalContributions = opts.minTotalContributions;
152	        // Set the max total contributions.
153	        if (opts.maxTotalContributions == 0) {
154	            // Prevent this because when `maxTotalContributions` is 0 the
155	            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has
156	            // never been initialized.
157	            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);
158	        }
159	        maxTotalContributions = opts.maxTotalContributions;
160	        // Set the party crowdfund is for.
161	        party = opts.party;
162	        // Set the crowdfund start and end timestamps.
163	        expiry = uint40(block.timestamp + opts.duration);
164	        // Set the exchange rate.
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
166	        exchangeRateBps = opts.exchangeRateBps;
167	        // Set the funding split and its recipient.
168	        fundingSplitBps = opts.fundingSplitBps;
169	        fundingSplitRecipient = opts.fundingSplitRecipient;
170	        // Set whether to disable contributing for existing card.
171	        disableContributingForExistingCard = opts.disableContributingForExistingCard;
172	    }
173	
```
[140..173](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L140-L173)

---

	 - contracts/party/PartyGovernance.sol

```solidity
270	    function _initialize(
271	        GovernanceOpts memory govOpts,
272	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
273	        IERC721[] memory preciousTokens,
274	        uint256[] memory preciousTokenIds
275	    ) internal virtual {
276	        // Check BPS are valid.
277	        if (govOpts.feeBps > 1e4) {
278	            revert InvalidBpsError(govOpts.feeBps);
279	        }
280	        if (govOpts.passThresholdBps > 1e4) {
281	            revert InvalidBpsError(govOpts.passThresholdBps);
282	        }
283	        // Initialize the proposal execution engine.
284	        _initProposalImpl(
285	            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),
286	            abi.encode(proposalEngineOpts)
287	        );
288	        // Set the governance parameters.
289	        _getSharedProposalStorage().governanceValues = GovernanceValues({
290	            voteDuration: govOpts.voteDuration,
291	            executionDelay: govOpts.executionDelay,
292	            passThresholdBps: govOpts.passThresholdBps,
293	            totalVotingPower: govOpts.totalVotingPower
294	        });
295	        numHosts = uint8(govOpts.hosts.length);
296	        // Set fees.
297	        feeBps = govOpts.feeBps;
298	        feeRecipient = govOpts.feeRecipient;
299	        // Set the precious list.
300	        _setPreciousList(preciousTokens, preciousTokenIds);
301	        // Set the party hosts.
302	        if (govOpts.hosts.length > type(uint8).max) {
303	            revert TooManyHosts();
304	        }
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
309	
```
[270..309](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L270-L309)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
81	    function _initialize(
82	        string memory name_,
83	        string memory symbol_,
84	        uint256 customizationPresetId,
85	        PartyGovernance.GovernanceOpts memory governanceOpts,
86	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
87	        IERC721[] memory preciousTokens,
88	        uint256[] memory preciousTokenIds,
89	        address[] memory authorities,
90	        uint40 rageQuitTimestamp_
91	    ) internal {
92	        PartyGovernance._initialize(
93	            governanceOpts,
94	            proposalEngineOpts,
95	            preciousTokens,
96	            preciousTokenIds
97	        );
98	        name = name_;
99	        symbol = symbol_;
100	        rageQuitTimestamp = rageQuitTimestamp_;
101	        unchecked {
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
105	        }
106	        if (customizationPresetId != 0) {
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
109	        }
110	    }
```
[81..110](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L81-L110)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
248	    function _execute(
249	        ProposalType pt,
250	        ExecuteProposalParams memory params
251	    ) internal virtual returns (bytes memory nextProgressData) {
252	        if (pt == ProposalType.ListOnOpensea) {
253	            nextProgressData = _executeListOnOpensea(params);
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
293	
```
[248..293](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L248-L293)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
25	    function _executeSetGovernanceParameter(
26	        IProposalExecutionEngine.ExecuteProposalParams memory params
27	    ) internal returns (bytes memory) {
28	        SetGovernanceParameterProposalData memory proposalData = abi.decode(
29	            params.proposalData,
30	            (SetGovernanceParameterProposalData)
31	        );
32	        if (proposalData.voteDuration != 0) {
33	            if (proposalData.voteDuration < 1 hours) {
34	                revert InvalidGovernanceParameter(proposalData.voteDuration);
35	            }
36	            emit VoteDurationSet(
37	                _getSharedProposalStorage().governanceValues.voteDuration,
38	                proposalData.voteDuration
39	            );
40	            _getSharedProposalStorage().governanceValues.voteDuration = proposalData.voteDuration;
41	        }
42	        if (proposalData.executionDelay != 0) {
43	            if (proposalData.executionDelay > 30 days) {
44	                revert InvalidGovernanceParameter(proposalData.executionDelay);
45	            }
46	            emit ExecutionDelaySet(
47	                _getSharedProposalStorage().governanceValues.executionDelay,
48	                proposalData.executionDelay
49	            );
50	            _getSharedProposalStorage().governanceValues.executionDelay = proposalData
51	                .executionDelay;
52	        }
53	        if (proposalData.passThresholdBps != 0) {
54	            if (proposalData.passThresholdBps > 10000) {
55	                revert InvalidGovernanceParameter(proposalData.passThresholdBps);
56	            }
57	            emit PassThresholdBpsSet(
58	                _getSharedProposalStorage().governanceValues.passThresholdBps,
59	                proposalData.passThresholdBps
60	            );
61	            _getSharedProposalStorage().governanceValues.passThresholdBps = proposalData
62	                .passThresholdBps;
63	        }
64	
65	        return "";
66	    }
```
[25..66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L25-L66)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
28	    function _executeSetSignatureValidator(
29	        IProposalExecutionEngine.ExecuteProposalParams memory params
30	    ) internal returns (bytes memory nextProgressData) {
31	        SetSignatureValidatorProposalData memory data = abi.decode(
32	            params.proposalData,
33	            (SetSignatureValidatorProposalData)
34	        );
35	        _getSetSignatureValidatorProposalStorage().signatureValidators[data.signatureHash] = data
36	            .signatureValidator;
37	        nextProgressData = "";
38	
39	        emit SignatureValidatorSet(data.signatureHash, data.signatureValidator);
40	    }
```
[28..40](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L28-L40)


</details>

-------
### [G-25] Using `storage` instead of `memory` for structs/arrays saves gas
<a name="G-25"></a>
[To the top](#TOP)

When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 6 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
598	        ProposalStateValues memory values = info.values;
...
669	        ProposalStateValues memory values = info.values;
...
720	        ProposalStateValues memory values = proposalState.values;
...
777	        ProposalStateValues memory values = proposalState.values;
...
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
...
1087	        GovernanceValues memory gv = _getSharedProposalStorage().governanceValues;
```
[598](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L598)
[669](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L669)
[720](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L720)
[777](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L777)
[1034](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1034)
[1087](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1087)


</details>

-------
### [G-26] Consider using `bytes32` rather than a `string`
<a name="G-26"></a>
[To the top](#TOP)

Using the `bytes` types for fixed-length strings is more efficient than having the EVM have to incur the overhead of string processing. Consider whether the value _needs_ to be a `string`. A good reason to keep it as a `string` would be if the variable is defined in an interface that this project does not own.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 6 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
44	        string name;
...
46	        string symbol;
```
[44](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L44)
[46](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L46)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
82	        string memory name_,
...
83	        string memory symbol_,
...
123	    function tokenURI(uint256) public view override returns (string memory) {
...
129	    function contractURI() external view returns (string memory) {
```
[82](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L82)
[83](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L83)
[123](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L123)
[129](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L129)


</details>

-------
### [G-27] Setting the `constructor` to `payable`
<a name="G-27"></a>
[To the top](#TOP)

Saves ~13 gas per instance

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 5 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
99	    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}
```
[99](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L99)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
134	    constructor(IGlobals globals) {
```
[134](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L134)

---

	 - contracts/party/PartyGovernance.sol

```solidity
265	    constructor(IGlobals globals) {
```
[265](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L265)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
107	    constructor(
108	        IGlobals globals,
109	        IReserveAuctionCoreEth zora,
110	        IFractionalV1VaultFactory fractionalVaultFactory
111	    )
112	        ListOnOpenseaAdvancedProposal(globals)
113	        ListOnZoraProposal(globals, zora)
114	        FractionalizeProposal(fractionalVaultFactory)
115	        ArbitraryCallsProposal(zora)
116	    {
```
[107..116](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L107-L116)

---

	 - contracts/utils/Implementation.sol

```solidity
17	    constructor() {
```
[17](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L17)


</details>

-------
### [G-28] State variables access within a loop
<a name="G-28"></a>
[To the top](#TOP)

State variable reads and writes are more expensive than local variable reads and writes. Therefore, it is recommended to replace state variable reads and writes within loops with a local variable. Gas savings should be multiplied by the average loop length.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 5 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
```
[305..308](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L305-L308)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
102	            for (uint256 i; i < authorities.length; ++i) {
103	                isAuthority[authorities[i]] = true;
104	            }
...
272	        for (uint256 i; i < tokenIds.length; ++i) {
273	            uint256 tokenId = tokenIds[i];
274	            address owner = ownerOf(tokenId);
275	
276	            // Check if caller is authorized to burn the token.
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
286	
287	            // Must be retrieved before updating voting power for token to be burned.
288	            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();
289	
290	            totalVotingPowerBurned += votingPower;
291	
292	            // Update voting power for token to be burned.
293	            delete votingPowerByTokenId[tokenId];
294	            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);
295	            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));
296	
297	            // Burn token.
298	            _burn(tokenId);
299	
300	            emit Burn(msg.sender, tokenId, votingPower);
301	        }
...
378	            for (uint256 i; i < withdrawTokens.length; ++i) {
379	                // Check if order of tokens to transfer is valid.
380	                // Prevent null and duplicate transfers.
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
382	
383	                prevToken = withdrawTokens[i];
384	
385	                // Check token's balance.
386	                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS
387	                    ? address(this).balance
388	                    : withdrawTokens[i].balanceOf(address(this));
389	
390	                // Add fair share of tokens from the party to total.
391	                for (uint256 j; j < tokenIds.length; ++j) {
392	                    // Must be retrieved before burning the token.
393	                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;
394	                }
395	            }
...
408	            for (uint256 i; i < withdrawTokens.length; ++i) {
409	                IERC20 token = withdrawTokens[i];
410	                uint256 amount = withdrawAmounts[i];
411	
412	                // Take fee from amount.
413	                uint256 fee = (amount * feeBps_) / 1e4;
414	
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
425	
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
441	            }
```
[102..104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L102-L104)
[272..301](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L272-L301)
[378..395](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L378-L395)
[408..441](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L408-L441)


</details>

-------
### [G-29] Use Assembly for Hash Calculations
<a name="G-29"></a>
[To the top](#TOP)

In certain cases, using inline assembly to calculate hashes can lead to significant gas savings. Solidity's built-in keccak256 function is convenient but costs more gas than the equivalent assembly code. However, it's important to note that using assembly should be done with care as it's less readable and could increase the risk of introducing errors.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 5 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
406	        bytes32 dataHash = keccak256(proposal.proposalData);
```
[406](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L406)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
177	                bytes32 progressDataHash = keccak256(params.progressData);
...
171	                        keccak256(params.progressData),
...
202	            stor.nextProgressDataHash = keccak256(nextProgressData);
```
[177](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L177)
[171](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L171)
[202](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L202)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
53	        if (keccak256(encodedPacket) != hash) {
```
[53](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L53)


</details>

-------
### [G-30] Function calls should be cached instead of re-calling the function
<a name="G-30"></a>
[To the top](#TOP)

Consider caching the result instead of re-calling the function when possible. Note: this also includes casts, which cost between 42-46 gas, depending on the type.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 4 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
487	    function distribute(
488	        uint256 amount,
489	        ITokenDistributor.TokenType tokenType,
490	        address token,
491	        uint256 tokenId
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
493	        _assertNotGloballyDisabled();
494	        // Ignore if the party is calling functions on itself, like with
495	        // `FractionalizeProposal` and `DistributionProposal`.
496	        if (msg.sender != address(this)) {
497	            // Must not require a vote to create a distribution, otherwise
498	            // distributions can only be created through a distribution
499	            // proposal.
500	            if (_getSharedProposalStorage().opts.distributionsRequireVote) {
501	                revert DistributionsRequireVoteError();
502	            }
503	            // Must be an active member.
504	            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
509	        // Prevent creating a distribution if the party has not started.
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
511	            revert PartyNotStartedError();
512	        }
513	        // Get the address of the token distributor.
514	        ITokenDistributor distributor = ITokenDistributor(
515	            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)
516	        );
517	        emit DistributionCreated(tokenType, token, tokenId);
518	        // Notify third-party platforms that the governance NFT metadata has
519	        // updated for all tokens.
520	        emit BatchMetadataUpdate(0, type(uint256).max);
521	        // Create a native token distribution.
522	        address payable feeRecipient_ = feeRecipient;
523	        uint16 feeBps_ = feeBps;
524	        if (tokenType == ITokenDistributor.TokenType.Native) {
525	            return
526	                distributor.createNativeDistribution{ value: amount }(
527	                    Party(payable(address(this))),
528	                    feeRecipient_,
529	                    feeBps_
530	                );
531	        }
532	        // Otherwise must be an ERC20 token distribution.
533	        assert(tokenType == ITokenDistributor.TokenType.Erc20);
534	        IERC20(token).compatTransfer(address(distributor), amount);
535	        return
536	            distributor.createErc20Distribution(
537	                IERC20(token),
538	                Party(payable(address(this))),
539	                feeRecipient_,
540	                feeBps_
541	            );
542	    }
543	
```
[487..543](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L487-L543)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
225	    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {
226	        IERC1271 validator = getSignatureValidatorForHash(hash);
227	        if (address(validator) == address(1)) {
228	            // Signature set by party to be always valid
229	            return IERC1271.isValidSignature.selector;
230	        }
231	        if (address(validator) != address(0)) {
232	            return validator.isValidSignature(hash, signature);
233	        }
234	        if (tx.origin == address(0)) {
235	            validator = getSignatureValidatorForHash(0);
236	            if (address(validator) == address(0)) {
237	                // Use global off-chain signature validator
238	                validator = IERC1271(
239	                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)
240	                );
241	            }
242	            return validator.isValidSignature(hash, signature);
243	        }
244	        return 0;
245	    }
246	
...
248	    function _execute(
249	        ProposalType pt,
250	        ExecuteProposalParams memory params
251	    ) internal virtual returns (bytes memory nextProgressData) {
252	        if (pt == ProposalType.ListOnOpensea) {
253	            nextProgressData = _executeListOnOpensea(params);
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
293	
```
[225..246](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L225-L246)
[248..293](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L248-L293)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
25	    function _executeSetGovernanceParameter(
26	        IProposalExecutionEngine.ExecuteProposalParams memory params
27	    ) internal returns (bytes memory) {
28	        SetGovernanceParameterProposalData memory proposalData = abi.decode(
29	            params.proposalData,
30	            (SetGovernanceParameterProposalData)
31	        );
32	        if (proposalData.voteDuration != 0) {
33	            if (proposalData.voteDuration < 1 hours) {
34	                revert InvalidGovernanceParameter(proposalData.voteDuration);
35	            }
36	            emit VoteDurationSet(
37	                _getSharedProposalStorage().governanceValues.voteDuration,
38	                proposalData.voteDuration
39	            );
40	            _getSharedProposalStorage().governanceValues.voteDuration = proposalData.voteDuration;
41	        }
42	        if (proposalData.executionDelay != 0) {
43	            if (proposalData.executionDelay > 30 days) {
44	                revert InvalidGovernanceParameter(proposalData.executionDelay);
45	            }
46	            emit ExecutionDelaySet(
47	                _getSharedProposalStorage().governanceValues.executionDelay,
48	                proposalData.executionDelay
49	            );
50	            _getSharedProposalStorage().governanceValues.executionDelay = proposalData
51	                .executionDelay;
52	        }
53	        if (proposalData.passThresholdBps != 0) {
54	            if (proposalData.passThresholdBps > 10000) {
55	                revert InvalidGovernanceParameter(proposalData.passThresholdBps);
56	            }
57	            emit PassThresholdBpsSet(
58	                _getSharedProposalStorage().governanceValues.passThresholdBps,
59	                proposalData.passThresholdBps
60	            );
61	            _getSharedProposalStorage().governanceValues.passThresholdBps = proposalData
62	                .passThresholdBps;
63	        }
64	
65	        return "";
66	    }
```
[25..66](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L25-L66)


</details>

-------
### [G-31] Multiple mappings can be replaced with a single struct mapping
<a name="G-31"></a>
[To the top](#TOP)

Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 3 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
206	    mapping(address => bool) public isHost;
...
208	    mapping(address => address) public delegationsByVoter;
...
214	    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;
```
[206](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L206)
[208](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L208)
[214](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L214)


</details>

-------
### [G-32] Optimize by Using Assembly for Low-Level Calls' Return Data
<a name="G-32"></a>
[To the top](#TOP)

Even second return value from a low-level call is not assigned, it is still copied to memory, leading to additional gas costs.
By employing assembly, you can bypass this memory copying, achieving a 159 gas saving.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 3 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
358	            (bool s, bytes memory r) = address(this).call(
```
[358](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L358)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
```
[379](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L379)

---

	 - contracts/party/PartyGovernance.sol

```solidity
846	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
```
[846](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L846)


</details>

-------
### [G-33] Use Custom Errors
<a name="G-33"></a>
[To the top](#TOP)

[Source](https://blog.soliditylang.org/2061/04/21/custom-errors/)
Instead of using error strings, to reduce deployment and runtime cost, you should use Custom Errors. This would save both deployment and runtime cost.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
313	        require(proposalType != ProposalType.Invalid);
...
314	        require(uint8(proposalType) <= uint8(type(ProposalType).max));
```
[313](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L313)
[314](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L314)


</details>

-------
### [G-34] State Variables can be packed into fewer storage slots
<a name="G-34"></a>
[To the top](#TOP)

Each slot saved can avoid an extra Gsset (21000 gas). Subsequent reads as well as writes have smaller gas savings

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 2 instances</summary>


---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
9	contract ETHCrowdfundBase is Implementation {
10	    using LibRawResult for bytes;
11	    using LibSafeCast for uint256;
12	    using LibAddress for address payable;
13	
14	    enum CrowdfundLifecycle {
15	        // In practice, this state is never used. If the crowdfund is ever in
16	        // this stage, something is wrong (e.g. crowdfund was never initialized).
17	        Invalid,
18	        // Ready to accept contributions to reach contribution targets
19	        // until a deadline or the minimum contribution target is reached and
20	        // host finalizes.
21	        Active,
22	        // Expired and the minimum contribution target was not reached.
23	        Lost,
24	        // The crowdfund has expired and reached the minimum contribution
25	        // target. It is now ready to finalize.
26	        Won,
27	        // A won crowdfund has been finalized, with funds transferred to the
28	        // party and voting power successfully updated.
29	        Finalized
30	    }
31	
32	    // Options to be passed into `initialize()` when the crowdfund is created.
33	    struct ETHCrowdfundOptions {
34	        Party party;
35	        address payable initialContributor;
36	        address initialDelegate;
37	        uint96 minContribution;
38	        uint96 maxContribution;
39	        bool disableContributingForExistingCard;
40	        uint96 minTotalContributions;
41	        uint96 maxTotalContributions;
42	        uint16 exchangeRateBps;
43	        uint16 fundingSplitBps;
44	        address payable fundingSplitRecipient;
45	        uint40 duration;
46	        IGateKeeper gateKeeper;
47	        bytes12 gateKeeperId;
48	    }
49	
50	    error WrongLifecycleError(CrowdfundLifecycle lc);
51	    error NotAllowedByGateKeeperError(
52	        address contributor,
53	        IGateKeeper gateKeeper,
54	        bytes12 gateKeeperId,
55	        bytes gateData
56	    );
57	    error OnlyPartyHostError();
58	    error OnlyPartyDaoError(address notDao);
59	    error OnlyPartyDaoOrHostError(address notDao);
60	    error NotOwnerError(uint256 tokenId);
61	    error OnlyWhenEmergencyActionsAllowedError();
62	    error InvalidDelegateError();
63	    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);
64	    error MinGreaterThanMaxError(uint96 min, uint96 max);
65	    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);
66	    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);
67	    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);
68	    error InvalidExchangeRateError(uint16 exchangeRateBps);
69	    error ContributingForExistingCardDisabledError();
70	    error ZeroVotingPowerError();
71	    error FundingSplitAlreadyPaidError();
72	    error FundingSplitNotConfiguredError();
73	    error InvalidMessageValue();
74	
75	    event Contributed(
76	        address indexed sender,
77	        address indexed contributor,
78	        uint256 amount,
79	        address delegate
80	    );
81	    event Finalized();
82	    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);
83	    event EmergencyExecuteDisabled();
84	    event EmergencyExecute(address target, bytes data, uint256 amountEth);
85	
86	    // The `Globals` contract storing global configuration values. This contract
87	    // is immutable and it’s address will never change.
88	    IGlobals private immutable _GLOBALS;
89	
90	    /// @notice The address of the `Party` contract instance associated
91	    ///         with the crowdfund.
92	    Party public party;
93	    /// @notice The minimum amount of ETH that a contributor can send to
94	    ///         participate in the crowdfund.
95	    uint96 public minContribution;
96	    /// @notice The maximum amount of ETH that a contributor can send to
97	    ///         participate in the crowdfund per address.
98	    uint96 public maxContribution;
99	    /// @notice A boolean flag that determines whether contributors are allowed
100	    ///         to increase the voting power of their existing party cards.
101	    bool public disableContributingForExistingCard;
102	    /// @notice Whether the funding split has been claimed by the funding split
103	    ///         recipient.
104	    bool public fundingSplitPaid;
105	    /// @notice Whether the DAO has emergency powers for this crowdfund.
106	    bool public emergencyExecuteDisabled;
107	    /// @notice The minimum amount of total ETH contributions required for the
108	    ///         crowdfund to be considered successful.
109	    uint96 public minTotalContributions;
110	    /// @notice The maximum amount of total ETH contributions allowed for the
111	    ///         crowdfund.
112	    uint96 public maxTotalContributions;
113	    /// @notice The total amount of ETH contributed to the crowdfund so far.
114	    uint96 public totalContributions;
115	    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the
116	    ///         crowdfund has finalized.
117	    uint40 public expiry;
118	    /// @notice The exchange rate to use for converting ETH contributions to
119	    ///         voting power in basis points (e.g. 10000 = 1:1).
120	    uint16 public exchangeRateBps;
121	    /// @notice The portion of contributions to send to the funding recipient in
122	    ///         basis points (e.g. 100 = 1%).
123	    uint16 public fundingSplitBps;
124	    /// @notice The address to which a portion of the contributions is sent to.
125	    address payable public fundingSplitRecipient;
126	    /// @notice The gatekeeper contract used to restrict who can contribute to the party.
127	    IGateKeeper public gateKeeper;
128	    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.
129	    bytes12 public gateKeeperId;
130	    /// @notice The address a contributor is delegating their voting power to.
131	    mapping(address => address) public delegationsByContributor;
132	
133	    // Set the `Globals` contract.
134	    constructor(IGlobals globals) {
135	        _GLOBALS = globals;
136	    }
137	
138	    // Initialize storage for proxy contracts, credit initial contribution (if
139	    // any), and setup gatekeeper.
140	    function _initialize(ETHCrowdfundOptions memory opts) internal {
141	        // Set the minimum and maximum contribution amounts.
142	        if (opts.minContribution > opts.maxContribution) {
143	            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);
144	        }
145	        minContribution = opts.minContribution;
146	        maxContribution = opts.maxContribution;
147	        // Set the min total contributions.
148	        if (opts.minTotalContributions > opts.maxTotalContributions) {
149	            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);
150	        }
151	        minTotalContributions = opts.minTotalContributions;
152	        // Set the max total contributions.
153	        if (opts.maxTotalContributions == 0) {
154	            // Prevent this because when `maxTotalContributions` is 0 the
155	            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has
156	            // never been initialized.
157	            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);
158	        }
159	        maxTotalContributions = opts.maxTotalContributions;
160	        // Set the party crowdfund is for.
161	        party = opts.party;
162	        // Set the crowdfund start and end timestamps.
163	        expiry = uint40(block.timestamp + opts.duration);
164	        // Set the exchange rate.
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
166	        exchangeRateBps = opts.exchangeRateBps;
167	        // Set the funding split and its recipient.
168	        fundingSplitBps = opts.fundingSplitBps;
169	        fundingSplitRecipient = opts.fundingSplitRecipient;
170	        // Set whether to disable contributing for existing card.
171	        disableContributingForExistingCard = opts.disableContributingForExistingCard;
172	    }
173	
174	    /// @notice Get the current lifecycle of the crowdfund.
175	    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {
176	        if (maxTotalContributions == 0) {
177	            return CrowdfundLifecycle.Invalid;
178	        }
179	
180	        uint256 expiry_ = expiry;
181	        if (expiry_ == 0) {
182	            return CrowdfundLifecycle.Finalized;
183	        }
184	
185	        if (block.timestamp >= expiry_) {
186	            if (totalContributions >= minTotalContributions) {
187	                return CrowdfundLifecycle.Won;
188	            } else {
189	                return CrowdfundLifecycle.Lost;
190	            }
191	        }
192	
193	        return CrowdfundLifecycle.Active;
194	    }
195	
196	    function _processContribution(
197	        address payable contributor,
198	        address delegate,
199	        uint96 amount
200	    ) internal returns (uint96 votingPower) {
201	        address oldDelegate = delegationsByContributor[contributor];
202	        if (msg.sender == contributor || oldDelegate == address(0)) {
203	            // Update delegate.
204	            delegationsByContributor[contributor] = delegate;
205	        } else {
206	            // Prevent changing another's delegate if already delegated.
207	            delegate = oldDelegate;
208	        }
209	
210	        emit Contributed(msg.sender, contributor, amount, delegate);
211	
212	        // OK to contribute with zero just to update delegate.
213	        if (amount == 0) return 0;
214	
215	        // Only allow contributions while the crowdfund is active.
216	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
221	        // Check that the contribution amount is at or below the maximum.
222	        uint96 maxContribution_ = maxContribution;
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
227	        uint96 newTotalContributions = totalContributions + amount;
228	        uint96 maxTotalContributions_ = maxTotalContributions;
229	        if (newTotalContributions >= maxTotalContributions_) {
230	            totalContributions = maxTotalContributions_;
231	
232	            // Finalize the crowdfund.
233	            // This occurs before refunding excess contribution to act as a
234	            // reentrancy guard.
235	            _finalize(maxTotalContributions_);
236	
237	            // Refund excess contribution.
238	            uint96 refundAmount = newTotalContributions - maxTotalContributions;
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
244	            totalContributions = newTotalContributions;
245	        }
246	
247	        // Check that the contribution amount is at or above the minimum. This
248	        // is done after `amount` is potentially reduced if refunding excess
249	        // contribution. There is a case where this prevents a crowdfunds from
250	        // reaching `maxTotalContributions` if the `minContribution` is greater
251	        // than the difference between `maxTotalContributions` and the current
252	        // `totalContributions`. In this scenario users will have to wait until
253	        // the crowdfund expires or a host finalizes after
254	        // `minTotalContribution` has been reached by calling `finalize()`.
255	        uint96 minContribution_ = minContribution;
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
260	        // Subtract fee from contribution amount if applicable.
261	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
262	        uint16 fundingSplitBps_ = fundingSplitBps;
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
269	        // Calculate voting power.
270	        votingPower = (amount * exchangeRateBps) / 1e4;
271	
272	        if (votingPower == 0) revert ZeroVotingPowerError();
273	    }
274	
275	    /// @notice Calculate the contribution amount from the given voting power.
276	    /// @param votingPower The voting power to convert to a contribution amount.
277	    /// @return amount The contribution amount.
278	    function convertVotingPowerToContribution(
279	        uint96 votingPower
280	    ) public view returns (uint96 amount) {
281	        amount = (votingPower * 1e4) / exchangeRateBps;
282	
283	        // Add back funding split to contribution amount if applicable.
284	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
285	        uint16 fundingSplitBps_ = fundingSplitBps;
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
288	        }
289	    }
290	
291	    function finalize() external {
292	        uint96 totalContributions_ = totalContributions;
293	
294	        // Check that the crowdfund is not already finalized.
295	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
296	        if (lc == CrowdfundLifecycle.Active) {
297	            // Allow host to finalize crowdfund early if it has reached its minimum goal.
298	            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();
299	
300	            // Check that the crowdfund has reached its minimum goal.
301	            uint96 minTotalContributions_ = minTotalContributions;
302	            if (totalContributions_ < minTotalContributions_) {
303	                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);
304	            }
305	        } else {
306	            // Otherwise only allow finalization if the crowdfund has expired
307	            // and been won. Can be finalized by anyone.
308	            if (lc != CrowdfundLifecycle.Won) {
309	                revert WrongLifecycleError(lc);
310	            }
311	        }
312	
313	        // Finalize the crowdfund.
314	        _finalize(totalContributions_);
315	    }
316	
317	    function _finalize(uint96 totalContributions_) internal {
318	        // Finalize the crowdfund.
319	        delete expiry;
320	
321	        // Transfer funding split to recipient if applicable.
322	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
323	        uint16 fundingSplitBps_ = fundingSplitBps;
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
326	        }
327	
328	        // Update the party's total voting power.
329	        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;
330	        party.increaseTotalVotingPower(newVotingPower);
331	
332	        // Transfer ETH to the party.
333	        payable(address(party)).transferEth(totalContributions_);
334	
335	        emit Finalized();
336	    }
337	
338	    /// @notice Send the funding split to the recipient if applicable.
339	    function sendFundingSplit() external returns (uint96 splitAmount) {
340	        // Check that the crowdfund is finalized.
341	        CrowdfundLifecycle lc = getCrowdfundLifecycle();
342	        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);
343	
344	        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();
345	
346	        address payable fundingSplitRecipient_ = fundingSplitRecipient;
347	        uint16 fundingSplitBps_ = fundingSplitBps;
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
349	            revert FundingSplitNotConfiguredError();
350	        }
351	
352	        fundingSplitPaid = true;
353	
354	        // Transfer funding split to recipient.
355	        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;
356	        payable(fundingSplitRecipient_).transferEth(splitAmount);
357	
358	        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);
359	    }
360	
361	    /// @notice As the DAO, execute an arbitrary function call from this contract.
362	    /// @dev Emergency actions must not be revoked for this to work.
363	    /// @param targetAddress The contract to call.
364	    /// @param targetCallData The data to pass to the contract.
365	    /// @param amountEth The amount of ETH to send to the contract.
366	    function emergencyExecute(
367	        address targetAddress,
368	        bytes calldata targetCallData,
369	        uint256 amountEth
370	    ) external payable {
371	        // Must be called by the DAO.
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
384	    }
385	
386	    /// @notice Revoke the DAO's ability to call emergencyExecute().
387	    /// @dev Either the DAO or the party host can call this.
388	    function disableEmergencyExecute() external {
389	        // Only the DAO or a host can call this.
390	        if (
391	            !party.isHost(msg.sender) &&
392	            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender
393	        ) {
394	            revert OnlyPartyDaoOrHostError(msg.sender);
395	        }
396	        emergencyExecuteDisabled = true;
397	        emit EmergencyExecuteDisabled();
398	    }
399	}
```
[9..400](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L9-L400)

---

	 - contracts/party/PartyGovernance.sol

```solidity
23	abstract contract PartyGovernance is
24	    ProposalStorage,
25	    Implementation,
26	    IERC4906,
27	    ReadOnlyDelegateCall
28	{
29	    using LibERC20Compat for IERC20;
30	    using LibRawResult for bytes;
31	    using LibSafeCast for uint256;
32	    using LibSafeCast for int192;
33	    using LibSafeCast for uint96;
34	
35	    // States a proposal can be in.
36	    enum ProposalStatus {
37	        // The proposal does not exist.
38	        Invalid,
39	        // The proposal has been proposed (via `propose()`), has not been vetoed
40	        // by a party host, and is within the voting window. Members can vote on
41	        // the proposal and party hosts can veto the proposal.
42	        Voting,
43	        // The proposal has either exceeded its voting window without reaching
44	        // `passThresholdBps` of votes or was vetoed by a party host.
45	        Defeated,
46	        // The proposal reached at least `passThresholdBps` of votes but is still
47	        // waiting for `executionDelay` to pass before it can be executed. Members
48	        // can continue to vote on the proposal and party hosts can veto at this time.
49	        Passed,
50	        // Same as `Passed` but now `executionDelay` has been satisfied. Any member
51	        // may execute the proposal via `execute()`, unless `maxExecutableTime`
52	        // has arrived.
53	        Ready,
54	        // The proposal has been executed at least once but has further steps to
55	        // complete so it needs to be executed again. No other proposals may be
56	        // executed while a proposal is in the `InProgress` state. No voting or
57	        // vetoing of the proposal is allowed, however it may be forcibly cancelled
58	        // via `cancel()` if the `cancelDelay` has passed since being first executed.
59	        InProgress,
60	        // The proposal was executed and completed all its steps. No voting or
61	        // vetoing can occur and it cannot be cancelled nor executed again.
62	        Complete,
63	        // The proposal was executed at least once but did not complete before
64	        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.
65	        Cancelled
66	    }
67	
68	    struct GovernanceOpts {
69	        // Address of initial party hosts.
70	        address[] hosts;
71	        // How long people can vote on a proposal.
72	        uint40 voteDuration;
73	        // How long to wait after a proposal passes before it can be
74	        // executed.
75	        uint40 executionDelay;
76	        // Minimum ratio of accept votes to consider a proposal passed,
77	        // in bps, where 10,000 == 100%.
78	        uint16 passThresholdBps;
79	        // Total voting power of governance NFTs.
80	        uint96 totalVotingPower;
81	        // Fee bps for distributions.
82	        uint16 feeBps;
83	        // Fee recipeint for distributions.
84	        address payable feeRecipient;
85	    }
86	
87	    // A snapshot of voting power for a member.
88	    struct VotingPowerSnapshot {
89	        // The timestamp when the snapshot was taken.
90	        uint40 timestamp;
91	        // Voting power that was delegated to this user by others.
92	        uint96 delegatedVotingPower;
93	        // The intrinsic (not delegated from someone else) voting power of this user.
94	        uint96 intrinsicVotingPower;
95	        // Whether the user was delegated to another at this snapshot.
96	        bool isDelegated;
97	    }
98	
99	    // Proposal details chosen by proposer.
100	    struct Proposal {
101	        // Time beyond which the proposal can no longer be executed.
102	        // If the proposal has already been executed, and is still InProgress,
103	        // this value is ignored.
104	        uint40 maxExecutableTime;
105	        // The minimum seconds this proposal can remain in the InProgress status
106	        // before it can be cancelled.
107	        uint40 cancelDelay;
108	        // Encoded proposal data. The first 4 bytes are the proposal type, followed
109	        // by encoded proposal args specific to the proposal type. See
110	        // ProposalExecutionEngine for details.
111	        bytes proposalData;
112	    }
113	
114	    // Accounting and state tracking values for a proposal.
115	    struct ProposalStateValues {
116	        // When the proposal was proposed.
117	        uint40 proposedTime;
118	        // When the proposal passed the vote.
119	        uint40 passedTime;
120	        // When the proposal was first executed.
121	        uint40 executedTime;
122	        // When the proposal completed.
123	        uint40 completedTime;
124	        // Number of accept votes.
125	        uint96 votes; // -1 == vetoed
126	        // Number of total voting power at time proposal created.
127	        uint96 totalVotingPower;
128	        /// @notice Number of hosts at time proposal created
129	        uint8 numHosts;
130	        /// @notice Number of hosts that accepted proposal
131	        uint8 numHostsAccepted;
132	    }
133	
134	    // Storage states for a proposal.
135	    struct ProposalState {
136	        // Accounting and state tracking values.
137	        ProposalStateValues values;
138	        // Hash of the proposal.
139	        bytes32 hash;
140	        // Whether a member has voted for (accepted) this proposal already.
141	        mapping(address => bool) hasVoted;
142	    }
143	
144	    event Proposed(uint256 proposalId, address proposer, Proposal proposal);
145	    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);
146	    event EmergencyExecute(address target, bytes data, uint256 amountEth);
147	
148	    event ProposalPassed(uint256 indexed proposalId);
149	    event ProposalVetoed(uint256 indexed proposalId, address host);
150	    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);
151	    event ProposalCancelled(uint256 indexed proposalId);
152	    event DistributionCreated(
153	        ITokenDistributor.TokenType tokenType,
154	        address token,
155	        uint256 tokenId
156	    );
157	    event PartyDelegateUpdated(address indexed owner, address indexed delegate);
158	    event HostStatusTransferred(address oldHost, address newHost);
159	    event EmergencyExecuteDisabled();
160	    event PartyVotingSnapshotCreated(
161	        address indexed voter,
162	        uint40 timestamp,
163	        uint96 delegatedVotingPower,
164	        uint96 intrinsicVotingPower,
165	        bool isDelegated
166	    );
167	
168	    error MismatchedPreciousListLengths();
169	    error BadProposalStatusError(ProposalStatus status);
170	    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);
171	    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);
172	    error NotAuthorized();
173	    error InvalidDelegateError();
174	    error BadPreciousListError();
175	    error OnlyWhenEmergencyActionsAllowedError();
176	    error OnlyWhenEnabledError();
177	    error AlreadyVotedError(address voter);
178	    error InvalidNewHostError();
179	    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);
180	    error InvalidBpsError(uint16 bps);
181	    error DistributionsRequireVoteError();
182	    error PartyNotStartedError();
183	    error CannotRageQuitAndAcceptError();
184	    error TooManyHosts();
185	
186	    uint256 private constant UINT40_HIGH_BIT = 1 << 39;
187	    uint96 private constant VETO_VALUE = type(uint96).max;
188	
189	    // The `Globals` contract storing global configuration values. This contract
190	    // is immutable and it’s address will never change.
191	    IGlobals private immutable _GLOBALS;
192	
193	    /// @notice Whether the DAO has emergency powers for this party.
194	    bool public emergencyExecuteDisabled;
195	    /// @notice Distribution fee bps.
196	    uint16 public feeBps;
197	    /// @notice Distribution fee recipient.
198	    address payable public feeRecipient;
199	    /// @notice The timestamp of the last time `rageQuit()` was called.
200	    uint40 public lastRageQuitTimestamp;
201	    /// @notice The hash of the list of precious NFTs guarded by the party.
202	    bytes32 public preciousListHash;
203	    /// @notice The last proposal ID that was used. 0 means no proposals have been made.
204	    uint256 public lastProposalId;
205	    /// @notice Whether an address is a party host.
206	    mapping(address => bool) public isHost;
207	    /// @notice The last person a voter delegated its voting power to.
208	    mapping(address => address) public delegationsByVoter;
209	    /// @notice Number of hosts for this party
210	    uint8 public numHosts;
211	    /// @notice ProposalState by proposal ID.
212	    mapping(uint256 => ProposalState) private _proposalStateByProposalId;
213	    /// @notice Snapshots of voting power per user, each sorted by increasing time.
214	    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;
215	
216	    function _assertHost() internal view {
217	        if (!isHost[msg.sender]) {
218	            revert NotAuthorized();
219	        }
220	    }
221	
222	    function _assertActiveMember() internal view {
223	        VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
224	        // Must have either delegated voting power or intrinsic voting power.
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
226	            revert NotAuthorized();
227	        }
228	    }
229	
230	    // Only the party DAO multisig can call.
231	    modifier onlyPartyDao() {
232	        {
233	            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
234	            if (msg.sender != partyDao) {
235	                revert NotAuthorized();
236	            }
237	        }
238	        _;
239	    }
240	
241	    // Only the party DAO multisig or a party host can call.
242	    modifier onlyPartyDaoOrHost() {
243	        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);
244	        if (msg.sender != partyDao && !isHost[msg.sender]) {
245	            revert NotAuthorized();
246	        }
247	        _;
248	    }
249	
250	    // Only if `emergencyExecuteDisabled` is not true.
251	    modifier onlyWhenEmergencyExecuteAllowed() {
252	        if (emergencyExecuteDisabled) {
253	            revert OnlyWhenEmergencyActionsAllowedError();
254	        }
255	        _;
256	    }
257	
258	    function _assertNotGloballyDisabled() internal view {
259	        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {
260	            revert OnlyWhenEnabledError();
261	        }
262	    }
263	
264	    // Set the `Globals` contract.
265	    constructor(IGlobals globals) {
266	        _GLOBALS = globals;
267	    }
268	
269	    // Initialize storage for proxy contracts and initialize the proposal execution engine.
270	    function _initialize(
271	        GovernanceOpts memory govOpts,
272	        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,
273	        IERC721[] memory preciousTokens,
274	        uint256[] memory preciousTokenIds
275	    ) internal virtual {
276	        // Check BPS are valid.
277	        if (govOpts.feeBps > 1e4) {
278	            revert InvalidBpsError(govOpts.feeBps);
279	        }
280	        if (govOpts.passThresholdBps > 1e4) {
281	            revert InvalidBpsError(govOpts.passThresholdBps);
282	        }
283	        // Initialize the proposal execution engine.
284	        _initProposalImpl(
285	            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),
286	            abi.encode(proposalEngineOpts)
287	        );
288	        // Set the governance parameters.
289	        _getSharedProposalStorage().governanceValues = GovernanceValues({
290	            voteDuration: govOpts.voteDuration,
291	            executionDelay: govOpts.executionDelay,
292	            passThresholdBps: govOpts.passThresholdBps,
293	            totalVotingPower: govOpts.totalVotingPower
294	        });
295	        numHosts = uint8(govOpts.hosts.length);
296	        // Set fees.
297	        feeBps = govOpts.feeBps;
298	        feeRecipient = govOpts.feeRecipient;
299	        // Set the precious list.
300	        _setPreciousList(preciousTokens, preciousTokenIds);
301	        // Set the party hosts.
302	        if (govOpts.hosts.length > type(uint8).max) {
303	            revert TooManyHosts();
304	        }
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
306	            isHost[govOpts.hosts[i]] = true;
307	        }
308	    }
309	
310	    /// @dev Forward all unknown read-only calls to the proposal execution engine.
311	    ///      Initial use case is to facilitate eip-1271 signatures.
312	    fallback() external {
313	        bytes4 functionSelector = bytes4(msg.data[0:4]);
314	        if (
315	            functionSelector == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector ||
316	            functionSelector == ERC1155TokenReceiverBase.onERC1155Received.selector ||
317	            functionSelector == IERC721Receiver.onERC721Received.selector
318	        ) {
319	            assembly {
320	                let freeMem := mload(0x40)
321	                mstore(freeMem, functionSelector)
322	                mstore(0x40, add(freeMem, 0x20))
323	                return(freeMem, 0x20)
324	            }
325	        }
326	        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);
327	    }
328	
329	    /// @notice Query if a contract implements an interface.
330	    /// @param interfaceId The interface identifier, as specified in ERC-165
331	    /// @return `true` if the contract implements `interfaceId` and
332	    ///         `interfaceId` is not 0xffffffff, `false` otherwise
333	    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {
334	        return
335	            interfaceId == type(IERC721Receiver).interfaceId ||
336	            interfaceId == type(ERC1155TokenReceiverBase).interfaceId ||
337	            // ERC4906 interface ID
338	            interfaceId == 0x49064906;
339	    }
340	
341	    /// @notice Get the current `ProposalExecutionEngine` instance.
342	    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {
343	        return _getSharedProposalStorage().engineImpl;
344	    }
345	
346	    /// @notice Get the current `ProposalEngineOpts` options.
347	    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {
348	        return _getSharedProposalStorage().opts;
349	    }
350	
351	    /// @notice Get the total voting power of `voter` at a `timestamp`.
352	    /// @param voter The address of the voter.
353	    /// @param timestamp The timestamp to get the voting power at.
354	    /// @return votingPower The total voting power of `voter` at `timestamp`.
355	    function getVotingPowerAt(
356	        address voter,
357	        uint40 timestamp
358	    ) external view returns (uint96 votingPower) {
359	        return getVotingPowerAt(voter, timestamp, type(uint256).max);
360	    }
361	
362	    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to
363	    ///         make sure it is the latest voting snapshot =< `timestamp`.
364	    /// @param voter The address of the voter.
365	    /// @param timestamp The timestamp to get the voting power at.
366	    /// @param snapIndex The index of the snapshot to get the voting power at.
367	    /// @return votingPower The total voting power of `voter` at `timestamp`.
368	    function getVotingPowerAt(
369	        address voter,
370	        uint40 timestamp,
371	        uint256 snapIndex
372	    ) public view returns (uint96 votingPower) {
373	        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);
374	        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;
375	    }
376	
377	    /// @notice Get the state of a proposal.
378	    /// @param proposalId The ID of the proposal.
379	    /// @return status The status of the proposal.
380	    /// @return values The state of the proposal.
381	    function getProposalStateInfo(
382	        uint256 proposalId
383	    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {
384	        values = _proposalStateByProposalId[proposalId].values;
385	        status = _getProposalStatus(values);
386	    }
387	
388	    /// @notice Retrieve fixed governance parameters.
389	    /// @return gv The governance parameters of this party.
390	    function getGovernanceValues() external view returns (GovernanceValues memory) {
391	        return _getSharedProposalStorage().governanceValues;
392	    }
393	
394	    /// @notice Get the hash of a proposal.
395	    /// @dev Proposal details are not stored on-chain so the hash is used to enforce
396	    ///      consistency between calls.
397	    /// @param proposal The proposal to hash.
398	    /// @return proposalHash The hash of the proposal.
399	    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {
400	        // Hash the proposal in-place. Equivalent to:
401	        // keccak256(abi.encode(
402	        //   proposal.maxExecutableTime,
403	        //   proposal.cancelDelay,
404	        //   keccak256(proposal.proposalData)
405	        // ))
406	        bytes32 dataHash = keccak256(proposal.proposalData);
407	        assembly {
408	            // Overwrite the data field with the hash of its contents and then
409	            // hash the struct.
410	            let dataPos := add(proposal, 0x40)
411	            let t := mload(dataPos)
412	            mstore(dataPos, dataHash)
413	            proposalHash := keccak256(proposal, 0x60)
414	            // Restore the data field.
415	            mstore(dataPos, t)
416	        }
417	    }
418	
419	    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.
420	    /// @param voter The address of the voter.
421	    /// @param timestamp The timestamp to get the snapshot index at.
422	    /// @return index The index of the snapshot.
423	    function findVotingPowerSnapshotIndex(
424	        address voter,
425	        uint40 timestamp
426	    ) public view returns (uint256 index) {
427	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
428	
429	        // Derived from Open Zeppelin binary search
430	        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39
431	        uint256 high = snaps.length;
432	        uint256 low = 0;
433	        while (low < high) {
434	            uint256 mid = (low + high) / 2;
435	            if (snaps[mid].timestamp > timestamp) {
436	                // Entry is too recent.
437	                high = mid;
438	            } else {
439	                // Entry is older. This is our best guess for now.
440	                low = mid + 1;
441	            }
442	        }
443	
444	        // Return `type(uint256).max` if no valid voting snapshots found.
445	        return high == 0 ? type(uint256).max : high - 1;
446	    }
447	
448	    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from
449	    ///         the old one (if any).
450	    /// @param delegate The address to delegating voting power to.
451	    function delegateVotingPower(address delegate) external {
452	        _adjustVotingPower(msg.sender, 0, delegate);
453	    }
454	
455	    /// @notice Transfer party host status to another.
456	    /// @param newPartyHost The address of the new host.
457	    function abdicateHost(address newPartyHost) external {
458	        _assertHost();
459	        // 0 is a special case burn address.
460	        if (newPartyHost != address(0)) {
461	            // Cannot transfer host status to an existing host.
462	            if (isHost[newPartyHost]) {
463	                revert InvalidNewHostError();
464	            }
465	            isHost[newPartyHost] = true;
466	        } else {
467	            // Burned the host status
468	            --numHosts;
469	        }
470	        isHost[msg.sender] = false;
471	        emit HostStatusTransferred(msg.sender, newPartyHost);
472	    }
473	
474	    /// @notice Create a token distribution by moving the party's entire balance
475	    ///         to the `TokenDistributor` contract and immediately creating a
476	    ///         distribution governed by this party.
477	    /// @dev The `feeBps` and `feeRecipient` this party was created with will be
478	    ///      propagated to the distribution. Party members are entitled to a
479	    ///      share of the distribution's tokens proportionate to their relative
480	    ///      voting power in this party (less the fee).
481	    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.
482	    /// @param tokenType The type of token to distribute.
483	    /// @param token The address of the token to distribute.
484	    /// @param tokenId The ID of the token to distribute. Currently unused but
485	    ///                may be used in the future to support other distribution types.
486	    /// @return distInfo The information about the created distribution.
487	    function distribute(
488	        uint256 amount,
489	        ITokenDistributor.TokenType tokenType,
490	        address token,
491	        uint256 tokenId
492	    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {
493	        _assertNotGloballyDisabled();
494	        // Ignore if the party is calling functions on itself, like with
495	        // `FractionalizeProposal` and `DistributionProposal`.
496	        if (msg.sender != address(this)) {
497	            // Must not require a vote to create a distribution, otherwise
498	            // distributions can only be created through a distribution
499	            // proposal.
500	            if (_getSharedProposalStorage().opts.distributionsRequireVote) {
501	                revert DistributionsRequireVoteError();
502	            }
503	            // Must be an active member.
504	            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
509	        // Prevent creating a distribution if the party has not started.
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
511	            revert PartyNotStartedError();
512	        }
513	        // Get the address of the token distributor.
514	        ITokenDistributor distributor = ITokenDistributor(
515	            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)
516	        );
517	        emit DistributionCreated(tokenType, token, tokenId);
518	        // Notify third-party platforms that the governance NFT metadata has
519	        // updated for all tokens.
520	        emit BatchMetadataUpdate(0, type(uint256).max);
521	        // Create a native token distribution.
522	        address payable feeRecipient_ = feeRecipient;
523	        uint16 feeBps_ = feeBps;
524	        if (tokenType == ITokenDistributor.TokenType.Native) {
525	            return
526	                distributor.createNativeDistribution{ value: amount }(
527	                    Party(payable(address(this))),
528	                    feeRecipient_,
529	                    feeBps_
530	                );
531	        }
532	        // Otherwise must be an ERC20 token distribution.
533	        assert(tokenType == ITokenDistributor.TokenType.Erc20);
534	        IERC20(token).compatTransfer(address(distributor), amount);
535	        return
536	            distributor.createErc20Distribution(
537	                IERC20(token),
538	                Party(payable(address(this))),
539	                feeRecipient_,
540	                feeBps_
541	            );
542	    }
543	
544	    /// @notice Make a proposal for members to vote on and cast a vote to accept it
545	    ///         as well.
546	    /// @dev Only an active member (has voting power) can call this.
547	    ///      Afterwards, members can vote to support it with `accept()` or a party
548	    ///      host can unilaterally reject the proposal with `veto()`.
549	    /// @param proposal The details of the proposal.
550	    /// @param latestSnapIndex The index of the caller's most recent voting power
551	    ///                        snapshot before the proposal was created. Should
552	    ///                        be retrieved off-chain and passed in.
553	    function propose(
554	        Proposal memory proposal,
555	        uint256 latestSnapIndex
556	    ) external returns (uint256 proposalId) {
557	        _assertActiveMember();
558	        proposalId = ++lastProposalId;
559	        // Store the time the proposal was created and the proposal hash.
560	        (
561	            _proposalStateByProposalId[proposalId].values,
562	            _proposalStateByProposalId[proposalId].hash
563	        ) = (
564	            ProposalStateValues({
565	                proposedTime: uint40(block.timestamp),
566	                passedTime: 0,
567	                executedTime: 0,
568	                completedTime: 0,
569	                votes: 0,
570	                totalVotingPower: _getSharedProposalStorage().governanceValues.totalVotingPower,
571	                numHosts: numHosts,
572	                numHostsAccepted: 0
573	            }),
574	            getProposalHash(proposal)
575	        );
576	        emit Proposed(proposalId, msg.sender, proposal);
577	        accept(proposalId, latestSnapIndex);
578	
579	        // Notify third-party platforms that the governance NFT metadata has
580	        // updated for all tokens.
581	        emit BatchMetadataUpdate(0, type(uint256).max);
582	    }
583	
584	    /// @notice Vote to support a proposed proposal.
585	    /// @dev The voting power cast will be the effective voting power of the caller
586	    ///      just before `propose()` was called (see `getVotingPowerAt()`).
587	    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the
588	    ///      proposal will be in the `Passed` state and will be executable after
589	    ///      the `executionDelay` has passed, putting it in the `Ready` state.
590	    /// @param proposalId The ID of the proposal to accept.
591	    /// @param snapIndex The index of the caller's last voting power snapshot
592	    ///                  before the proposal was created. Should be retrieved
593	    ///                  off-chain and passed in.
594	    /// @return totalVotes The total votes cast on the proposal.
595	    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {
596	        // Get the information about the proposal.
597	        ProposalState storage info = _proposalStateByProposalId[proposalId];
598	        ProposalStateValues memory values = info.values;
599	
600	        // Can only vote in certain proposal statuses.
601	        {
602	            ProposalStatus status = _getProposalStatus(values);
603	            // Allow voting even if the proposal is passed/ready so it can
604	            // potentially reach 100% consensus, which unlocks special
605	            // behaviors for certain proposal types.
606	            if (
607	                status != ProposalStatus.Voting &&
608	                status != ProposalStatus.Passed &&
609	                status != ProposalStatus.Ready
610	            ) {
611	                revert BadProposalStatusError(status);
612	            }
613	        }
614	
615	        // Prevent voting in the same block as the last rage quit timestamp.
616	        // This is to prevent an exploit where a member can rage quit to reduce
617	        // the total voting power of the party, then propose and vote in the
618	        // same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.
619	        // This would allow them to use the voting power snapshot just before
620	        // their card was burned to vote, potentially passing a proposal that
621	        // would have otherwise not passed.
622	        if (lastRageQuitTimestamp == block.timestamp) {
623	            revert CannotRageQuitAndAcceptError();
624	        }
625	
626	        // Cannot vote twice.
627	        if (info.hasVoted[msg.sender]) {
628	            revert AlreadyVotedError(msg.sender);
629	        }
630	        // Mark the caller as having voted.
631	        info.hasVoted[msg.sender] = true;
632	
633	        // Increase the total votes that have been cast on this proposal.
634	        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);
635	        values.votes += votingPower;
636	        if (isHost[msg.sender]) {
637	            ++values.numHostsAccepted;
638	        }
639	        info.values = values;
640	        emit ProposalAccepted(proposalId, msg.sender, votingPower);
641	
642	        // Update the proposal status if it has reached the pass threshold.
643	        if (
644	            values.passedTime == 0 &&
645	            _areVotesPassing(
646	                values.votes,
647	                values.totalVotingPower,
648	                _getSharedProposalStorage().governanceValues.passThresholdBps
649	            )
650	        ) {
651	            info.values.passedTime = uint40(block.timestamp);
652	            emit ProposalPassed(proposalId);
653	            // Notify third-party platforms that the governance NFT metadata has
654	            // updated for all tokens.
655	            emit BatchMetadataUpdate(0, type(uint256).max);
656	        }
657	        return values.votes;
658	    }
659	
660	    /// @notice As a party host, veto a proposal, unilaterally rejecting it.
661	    /// @dev The proposal will never be executable and cannot be voted on anymore.
662	    ///      A proposal that has been already executed at least once (in the `InProgress` status)
663	    ///      cannot be vetoed.
664	    /// @param proposalId The ID of the proposal to veto.
665	    function veto(uint256 proposalId) external {
666	        _assertHost();
667	        // Setting `votes` to -1 indicates a veto.
668	        ProposalState storage info = _proposalStateByProposalId[proposalId];
669	        ProposalStateValues memory values = info.values;
670	
671	        {
672	            ProposalStatus status = _getProposalStatus(values);
673	            // Proposal must be in one of the following states.
674	            if (
675	                status != ProposalStatus.Voting &&
676	                status != ProposalStatus.Passed &&
677	                status != ProposalStatus.Ready
678	            ) {
679	                revert BadProposalStatusError(status);
680	            }
681	        }
682	
683	        // -1 indicates veto.
684	        info.values.votes = VETO_VALUE;
685	        emit ProposalVetoed(proposalId, msg.sender);
686	        // Notify third-party platforms that the governance NFT metadata has
687	        // updated for all tokens.
688	        emit BatchMetadataUpdate(0, type(uint256).max);
689	    }
690	
691	    /// @notice Executes a proposal that has passed governance.
692	    /// @dev The proposal must be in the `Ready` or `InProgress` status.
693	    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`
694	    ///      if the proposal has extra steps (must be executed again) to carry out,
695	    ///      in which case `nextProgressData` should be passed into the next `execute()` call.
696	    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal
697	    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`
698	    ///      in order to execute a different proposal.
699	    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.
700	    /// @param proposalId The ID of the proposal to execute.
701	    /// @param proposal The details of the proposal.
702	    /// @param preciousTokens The tokens that the party considers precious.
703	    /// @param preciousTokenIds The token IDs associated with each precious token.
704	    /// @param progressData The data returned from the last `execute()` call, if any.
705	    /// @param extraData Off-chain data a proposal might need to execute a step.
706	    function execute(
707	        uint256 proposalId,
708	        Proposal memory proposal,
709	        IERC721[] memory preciousTokens,
710	        uint256[] memory preciousTokenIds,
711	        bytes calldata progressData,
712	        bytes calldata extraData
713	    ) external payable {
714	        _assertNotGloballyDisabled();
715	        _assertActiveMember();
716	        // Get information about the proposal.
717	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
718	        // Proposal details must remain the same from `propose()`.
719	        _validateProposalHash(proposal, proposalState.hash);
720	        ProposalStateValues memory values = proposalState.values;
721	        ProposalStatus status = _getProposalStatus(values);
722	        // The proposal must be executable or have already been executed but still
723	        // has more steps to go.
724	        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {
725	            revert BadProposalStatusError(status);
726	        }
727	        if (status == ProposalStatus.Ready) {
728	            // If the proposal has not been executed yet, make sure it hasn't
729	            // expired. Note that proposals that have been executed
730	            // (but still have more steps) ignore `maxExecutableTime`.
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
738	        }
739	        // Check that the precious list is valid.
740	        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {
741	            revert BadPreciousListError();
742	        }
743	        // Preemptively set the proposal to completed to avoid it being executed
744	        // again in a deeper call.
745	        proposalState.values.completedTime = uint40(block.timestamp);
746	        // Execute the proposal.
747	        bool completed = _executeProposal(
748	            proposalId,
749	            proposal,
750	            preciousTokens,
751	            preciousTokenIds,
752	            _getProposalFlags(values),
753	            progressData,
754	            extraData
755	        );
756	        if (!completed) {
757	            // Proposal did not complete.
758	            proposalState.values.completedTime = 0;
759	        }
760	    }
761	
762	    /// @notice Cancel a (probably stuck) InProgress proposal.
763	    /// @dev `proposal.cancelDelay` seconds must have passed since it was first
764	    ///      executed for this to be valid. The currently active proposal will
765	    ///      simply be yeeted out of existence so another proposal can execute.
766	    ///      This is intended to be a last resort and can leave the party in a
767	    ///      broken state. Whenever possible, active proposals should be
768	    ///      allowed to complete their lifecycle.
769	    /// @param proposalId The ID of the proposal to cancel.
770	    /// @param proposal The details of the proposal to cancel.
771	    function cancel(uint256 proposalId, Proposal calldata proposal) external {
772	        _assertActiveMember();
773	        // Get information about the proposal.
774	        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];
775	        // Proposal details must remain the same from `propose()`.
776	        _validateProposalHash(proposal, proposalState.hash);
777	        ProposalStateValues memory values = proposalState.values;
778	        {
779	            // Must be `InProgress`.
780	            ProposalStatus status = _getProposalStatus(values);
781	            if (status != ProposalStatus.InProgress) {
782	                revert BadProposalStatusError(status);
783	            }
784	        }
785	        {
786	            // Limit the `cancelDelay` to the global max and min cancel delay
787	            // to mitigate parties accidentally getting stuck forever by setting an
788	            // unrealistic `cancelDelay` or being reckless with too low a
789	            // cancel delay.
790	            uint256 cancelDelay = proposal.cancelDelay;
791	            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(
792	                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION
793	            );
794	            uint256 globalMinCancelDelay = _GLOBALS.getUint256(
795	                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION
796	            );
797	            if (globalMaxCancelDelay != 0) {
798	                // Only if we have one set.
799	                if (cancelDelay > globalMaxCancelDelay) {
800	                    cancelDelay = globalMaxCancelDelay;
801	                }
802	            }
803	            if (globalMinCancelDelay != 0) {
804	                // Only if we have one set.
805	                if (cancelDelay < globalMinCancelDelay) {
806	                    cancelDelay = globalMinCancelDelay;
807	                }
808	            }
809	            uint256 cancelTime = values.executedTime + cancelDelay;
810	            // Must not be too early.
811	            if (block.timestamp < cancelTime) {
812	                revert ProposalCannotBeCancelledYetError(
813	                    uint40(block.timestamp),
814	                    uint40(cancelTime)
815	                );
816	            }
817	        }
818	        // Mark the proposal as cancelled by setting the completed time to the current
819	        // time with the high bit set.
820	        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);
821	        {
822	            // Delegatecall into the proposal engine impl to perform the cancel.
823	            (bool success, bytes memory resultData) = (
824	                address(_getSharedProposalStorage().engineImpl)
825	            ).delegatecall(abi.encodeCall(IProposalExecutionEngine.cancelProposal, (proposalId)));
826	            if (!success) {
827	                resultData.rawRevert();
828	            }
829	        }
830	        emit ProposalCancelled(proposalId);
831	        // Notify third-party platforms that the governance NFT metadata has
832	        // updated for all tokens.
833	        emit BatchMetadataUpdate(0, type(uint256).max);
834	    }
835	
836	    /// @notice As the DAO, execute an arbitrary function call from this contract.
837	    /// @dev Emergency actions must not be revoked for this to work.
838	    /// @param targetAddress The contract to call.
839	    /// @param targetCallData The data to pass to the contract.
840	    /// @param amountEth The amount of ETH to send to the contract.
841	    function emergencyExecute(
842	        address targetAddress,
843	        bytes calldata targetCallData,
844	        uint256 amountEth
845	    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed onlyDelegateCall {
846	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
847	        if (!success) {
848	            res.rawRevert();
849	        }
850	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
851	    }
852	
853	    /// @notice Revoke the DAO's ability to call emergencyExecute().
854	    /// @dev Either the DAO or the party host can call this.
855	    function disableEmergencyExecute() external onlyPartyDaoOrHost {
856	        emergencyExecuteDisabled = true;
857	        emit EmergencyExecuteDisabled();
858	    }
859	
860	    function _executeProposal(
861	        uint256 proposalId,
862	        Proposal memory proposal,
863	        IERC721[] memory preciousTokens,
864	        uint256[] memory preciousTokenIds,
865	        uint256 flags,
866	        bytes memory progressData,
867	        bytes memory extraData
868	    ) private returns (bool completed) {
869	        // Setup the arguments for the proposal execution engine.
870	        IProposalExecutionEngine.ExecuteProposalParams
871	            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({
872	                proposalId: proposalId,
873	                proposalData: proposal.proposalData,
874	                progressData: progressData,
875	                extraData: extraData,
876	                preciousTokens: preciousTokens,
877	                preciousTokenIds: preciousTokenIds,
878	                flags: flags
879	            });
880	        // Get the progress data returned after the proposal is executed.
881	        bytes memory nextProgressData;
882	        {
883	            // Execute the proposal.
884	            (bool success, bytes memory resultData) = address(
885	                _getSharedProposalStorage().engineImpl
886	            ).delegatecall(
887	                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))
888	                );
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
893	        }
894	        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);
895	        // Notify third-party platforms that the governance NFT metadata has
896	        // updated for all tokens.
897	        emit BatchMetadataUpdate(0, type(uint256).max);
898	        // If the returned progress data is empty, then the proposal completed
899	        // and it should not be executed again.
900	        return nextProgressData.length == 0;
901	    }
902	
903	    // Get the most recent voting power snapshot <= timestamp using `hintindex` as a "hint".
904	    function _getVotingPowerSnapshotAt(
905	        address voter,
906	        uint40 timestamp,
907	        uint256 hintIndex
908	    ) internal view returns (VotingPowerSnapshot memory snap) {
909	        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];
910	        uint256 snapsLength = snaps.length;
911	        if (snapsLength != 0) {
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
923	            // Hint was wrong, fallback to binary search to find snapshot.
924	            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);
925	            // Check that snapshot was found.
926	            if (hintIndex != type(uint256).max) {
927	                return snaps[hintIndex];
928	            }
929	        }
930	
931	        // No snapshot found.
932	        return snap;
933	    }
934	
935	    // Transfers some voting power of `from` to `to`. The total voting power of
936	    // their respective delegates will be updated as well.
937	    function _transferVotingPower(address from, address to, uint256 power) internal {
938	        int192 powerI192 = power.safeCastUint256ToInt192();
939	        _adjustVotingPower(from, -powerI192, address(0));
940	        _adjustVotingPower(to, powerI192, address(0));
941	    }
942	
943	    // Increase `voter`'s intrinsic voting power and update their delegate if delegate is nonzero.
944	    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {
945	        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);
946	        address oldDelegate = delegationsByVoter[voter];
947	        // If `oldDelegate` is zero and `voter` never delegated, then have
948	        // `voter` delegate to themself.
949	        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;
950	        // If the new `delegate` is zero, use the current (old) delegate.
951	        delegate = delegate == address(0) ? oldDelegate : delegate;
952	
953	        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({
954	            timestamp: uint40(block.timestamp),
955	            delegatedVotingPower: oldSnap.delegatedVotingPower,
956	            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +
957	                votingPower).safeCastInt192ToUint96(),
958	            isDelegated: delegate != voter
959	        });
960	        _insertVotingPowerSnapshot(voter, newSnap);
961	        delegationsByVoter[voter] = delegate;
962	
963	        // This event is emitted even if the delegate did not change.
964	        emit PartyDelegateUpdated(voter, delegate);
965	
966	        // Handle rebalancing delegates.
967	        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);
968	    }
969	
970	    // Update the delegated voting power of the old and new delegates delegated to
971	    // by `voter` based on the snapshot change.
972	    function _rebalanceDelegates(
973	        address voter,
974	        address oldDelegate,
975	        address newDelegate,
976	        VotingPowerSnapshot memory oldSnap,
977	        VotingPowerSnapshot memory newSnap
978	    ) private {
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
980	            revert InvalidDelegateError();
981	        }
982	        if (oldDelegate != voter && oldDelegate != newDelegate) {
983	            // Remove past voting power from old delegate.
984	            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(
985	                oldDelegate
986	            );
987	            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({
988	                timestamp: uint40(block.timestamp),
989	                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -
990	                    oldSnap.intrinsicVotingPower,
991	                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,
992	                isDelegated: oldDelegateSnap.isDelegated
993	            });
994	            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);
995	        }
996	        if (newDelegate != voter) {
997	            // Not delegating to self.
998	            // Add new voting power to new delegate.
999	            VotingPowerSnapshot memory newDelegateSnap = _getLastVotingPowerSnapshotForVoter(
1000	                newDelegate
1001	            );
1002	            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +
1003	                newSnap.intrinsicVotingPower;
1004	            if (newDelegate == oldDelegate) {
1005	                // If the old and new delegate are the same, subtract the old
1006	                // intrinsic voting power of the voter, or else we will double
1007	                // count a portion of it.
1008	                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;
1009	            }
1010	            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({
1011	                timestamp: uint40(block.timestamp),
1012	                delegatedVotingPower: newDelegateDelegatedVotingPower,
1013	                intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,
1014	                isDelegated: newDelegateSnap.isDelegated
1015	            });
1016	            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);
1017	        }
1018	    }
1019	
1020	    // Append a new voting power snapshot, overwriting the last one if possible.
1021	    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap) private {
1022	        emit PartyVotingSnapshotCreated(
1023	            voter,
1024	            snap.timestamp,
1025	            snap.delegatedVotingPower,
1026	            snap.intrinsicVotingPower,
1027	            snap.isDelegated
1028	        );
1029	
1030	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1031	        uint256 n = voterSnaps.length;
1032	        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.
1033	        if (n != 0) {
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
1035	            if (lastSnap.timestamp == snap.timestamp) {
1036	                voterSnaps[n - 1] = snap;
1037	                return;
1038	            }
1039	        }
1040	        voterSnaps.push(snap);
1041	    }
1042	
1043	    function _getLastVotingPowerSnapshotForVoter(
1044	        address voter
1045	    ) private view returns (VotingPowerSnapshot memory snap) {
1046	        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];
1047	        uint256 n = voterSnaps.length;
1048	        if (n != 0) {
1049	            snap = voterSnaps[n - 1];
1050	        }
1051	    }
1052	
1053	    function _getProposalFlags(ProposalStateValues memory pv) private pure returns (uint256) {
1054	        uint256 flags = 0;
1055	        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1056	            flags = flags | LibProposal.PROPOSAL_FLAG_UNANIMOUS;
1057	        }
1058	        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1059	            flags = flags | LibProposal.PROPOSAL_FLAG_HOSTS_ACCEPT;
1060	        }
1061	        return flags;
1062	    }
1063	
1064	    function _getProposalStatus(
1065	        ProposalStateValues memory pv
1066	    ) private view returns (ProposalStatus status) {
1067	        // Never proposed.
1068	        if (pv.proposedTime == 0) {
1069	            return ProposalStatus.Invalid;
1070	        }
1071	        // Executed at least once.
1072	        if (pv.executedTime != 0) {
1073	            if (pv.completedTime == 0) {
1074	                return ProposalStatus.InProgress;
1075	            }
1076	            // completedTime high bit will be set if cancelled.
1077	            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {
1078	                return ProposalStatus.Cancelled;
1079	            }
1080	            return ProposalStatus.Complete;
1081	        }
1082	        // Vetoed.
1083	        if (pv.votes == type(uint96).max) {
1084	            return ProposalStatus.Defeated;
1085	        }
1086	        uint40 t = uint40(block.timestamp);
1087	        GovernanceValues memory gv = _getSharedProposalStorage().governanceValues;
1088	        if (pv.passedTime != 0) {
1089	            // Ready.
1090	            if (pv.passedTime + gv.executionDelay <= t) {
1091	                return ProposalStatus.Ready;
1092	            }
1093	            // If unanimous, we skip the execution delay.
1094	            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1095	                return ProposalStatus.Ready;
1096	            }
1097	            // If all hosts voted, skip execution delay
1098	            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1099	                return ProposalStatus.Ready;
1100	            }
1101	            // Passed.
1102	            return ProposalStatus.Passed;
1103	        }
1104	        // Voting window expired.
1105	        if (pv.proposedTime + gv.voteDuration <= t) {
1106	            return ProposalStatus.Defeated;
1107	        }
1108	        return ProposalStatus.Voting;
1109	    }
1110	
1111	    function _isUnanimousVotes(
1112	        uint96 totalVotes,
1113	        uint96 totalVotingPower
1114	    ) private pure returns (bool) {
1115	        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;
1116	        // If >= 99.99% acceptance, consider it unanimous.
1117	        // The minting formula for voting power is a bit lossy, so we check
1118	        // for slightly less than 100%.
1119	        return acceptanceRatio >= 0.9999e4;
1120	    }
1121	
1122	    function _hostsAccepted(
1123	        uint8 snapshotNumHosts,
1124	        uint8 numHostsAccepted
1125	    ) private pure returns (bool) {
1126	        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;
1127	    }
1128	
1129	    function _areVotesPassing(
1130	        uint96 voteCount,
1131	        uint96 totalVotingPower,
1132	        uint16 passThresholdBps
1133	    ) private pure returns (bool) {
1134	        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);
1135	    }
1136	
1137	    function _setPreciousList(
1138	        IERC721[] memory preciousTokens,
1139	        uint256[] memory preciousTokenIds
1140	    ) private {
1141	        if (preciousTokens.length != preciousTokenIds.length) {
1142	            revert MismatchedPreciousListLengths();
1143	        }
1144	        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);
1145	    }
1146	
1147	    function _isPreciousListCorrect(
1148	        IERC721[] memory preciousTokens,
1149	        uint256[] memory preciousTokenIds
1150	    ) private view returns (bool) {
1151	        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);
1152	    }
1153	
1154	    function _hashPreciousList(
1155	        IERC721[] memory preciousTokens,
1156	        uint256[] memory preciousTokenIds
1157	    ) internal pure returns (bytes32 h) {
1158	        assembly {
1159	            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))
1160	            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))
1161	            h := keccak256(0x00, 0x40)
1162	        }
1163	    }
1164	
1165	    // Assert that the hash of a proposal matches expectedHash.
1166	    function _validateProposalHash(Proposal memory proposal, bytes32 expectedHash) private pure {
1167	        bytes32 actualHash = getProposalHash(proposal);
1168	        if (expectedHash != actualHash) {
1169	            revert BadProposalHashError(actualHash, expectedHash);
1170	        }
1171	    }
1172	}
```
[23..1173](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L23-L1173)


</details>

-------
### [G-35] `selfbalance()` is cheaper than `address(this).balance`
<a name="G-35"></a>
[To the top](#TOP)



#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
387	                    ? address(this).balance
```
[387](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L387)


</details>

-------
### [G-36] Functions guaranteed to revert when called by normal users can be marked `payable`
<a name="G-36"></a>
[To the top](#TOP)

If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost


#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
479	    function addAuthority(address authority) external onlySelf {
480	        isAuthority[authority] = true;
481	
482	        emit AuthorityAdded(authority);
483	    }
```
[479..483](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L479-L483)


</details>

-------
### [G-37] Using `private` for constants saves gas
<a name="G-37"></a>
[To the top](#TOP)

Saves deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/proposals/ProposalStorage.sol

```solidity
39	    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;
```
[39](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L39)


</details>

-------
### [G-38] Consider activating `via-ir` for deploying
<a name="G-38"></a>
[To the top](#TOP)

The IR-based code generator was developed to make code generation more performant by enabling optimization passes that can be applied across functions.

It is possible to activate the IR-based code generator through the command line by using the flag `--via-ir` or by including the option `{"viaIR": true}`.

Keep in mind that compiling with this option may take longer. However, you can simply test it before deploying your code. If you find that it provides better performance, you can add the `--via-ir` flag to your deploy command.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>

Placeholder, for non-solidity issues.


[project\2023-10-party](https://github.com/code-423n4/2023-10-party/blob/main/)


</details>

-------
### [G-39] Multiplication/division by two should use bit shifting
<a name="G-39"></a>
[To the top](#TOP)

`X * 2` is equivalent to `X << 1` and `X / 2` is the same as `X >> 1`.

The `MUL` and `DIV` opcodes cost 5 gas, whereas `SHL` and `SHR` only cost 3 gas.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
434	            uint256 mid = (low + high) / 2;
```
[434](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L434)


</details>

-------
### [G-40] Using `private` for `constants` saves gas
<a name="G-40"></a>
[To the top](#TOP)

Saves deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/proposals/ProposalStorage.sol

```solidity
39	    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;
```
[39](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L39)


</details>


## Disputed Risk Issues

### [D-01] Control structures do not comply with best practices
<a name="D-01"></a>
[To the top](#TOP)

Usually, most instances are comply with best practices, it just report when true/false body is not block, but it is allowed by style guade when statement is one line.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 156 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
141	        if (initialContribution > 0) {
142	            // If this contract has ETH, either passed in during deployment or
143	            // pre-existing, credit it to the `initialContributor`.
144	            _contribute(
145	                crowdfundOpts.initialContributor,
146	                crowdfundOpts.initialDelegate,
147	                initialContribution,
148	                0,
149	                ""
150	            );
151	        }
...
224	        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);
...
270	        if (msg.value != valuesSum) {
271	            revert InvalidMessageValue();
272	        }
...
283	        if (delegate == address(0)) {
284	            revert InvalidDelegateError();
285	        }
...
289	        if (_gateKeeper != IGateKeeper(address(0))) {
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
291	                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);
292	            }
293	        }
...
290	            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {
291	                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);
292	            }
...
298	        if (amount == 0) return 0;
...
300	        if (tokenId == 0) {
301	            // Mint contributor a new party card.
302	            party.mint(contributor, votingPower, delegate);
303	        } else if (disableContributingForExistingCard) {
304	            revert ContributingForExistingCardDisabledError();
305	        } else if (party.ownerOf(tokenId) == contributor) {
306	            // Increase voting power of contributor's existing party card.
307	            party.increaseVotingPower(tokenId, votingPower);
308	        } else {
309	            revert NotOwnerError(tokenId);
310	        }
...
303	        } else if (disableContributingForExistingCard) {
304	            revert ContributingForExistingCardDisabledError();
305	        } else if (party.ownerOf(tokenId) == contributor) {
306	            // Increase voting power of contributor's existing party card.
307	            party.increaseVotingPower(tokenId, votingPower);
308	        } else {
309	            revert NotOwnerError(tokenId);
310	        }
...
322	            if (lc != CrowdfundLifecycle.Lost) {
323	                revert WrongLifecycleError(lc);
324	            }
...
331	        if (amount > 0) {
332	            // Get contributor to refund.
333	            address payable contributor = payable(party.ownerOf(tokenId));
334	
335	            // Burn contributor's party card.
336	            party.burn(tokenId);
337	
338	            // Refund contributor.
339	            contributor.transferEth(amount);
340	
341	            emit Refunded(contributor, tokenId, amount);
342	        }
...
363	                if (revertOnFailure) {
364	                    r.rawRevert();
365	                }
```
[141..151](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L141-L151)
[224](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L224)
[270..272](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L270-L272)
[283..285](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L283-L285)
[289..293](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L289-L293)
[290..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L290-L292)
[298](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L298)
[300..310](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L300-L310)
[303..310](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L303-L310)
[322..324](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L322-L324)
[331..342](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L331-L342)
[363..365](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L363-L365)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
142	        if (opts.minContribution > opts.maxContribution) {
143	            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);
144	        }
145	        minContribution = opts.minContribution;
...
148	        if (opts.minTotalContributions > opts.maxTotalContributions) {
149	            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);
150	        }
151	        minTotalContributions = opts.minTotalContributions;
...
153	        if (opts.maxTotalContributions == 0) {
154	            // Prevent this because when `maxTotalContributions` is 0 the
155	            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has
156	            // never been initialized.
157	            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);
158	        }
159	        maxTotalContributions = opts.maxTotalContributions;
...
165	        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);
...
176	        if (maxTotalContributions == 0) {
177	            return CrowdfundLifecycle.Invalid;
178	        }
179	
...
181	        if (expiry_ == 0) {
182	            return CrowdfundLifecycle.Finalized;
183	        }
184	
...
185	        if (block.timestamp >= expiry_) {
186	            if (totalContributions >= minTotalContributions) {
187	                return CrowdfundLifecycle.Won;
188	            } else {
189	                return CrowdfundLifecycle.Lost;
190	            }
191	        }
192	
...
213	        if (amount == 0) return 0;
...
217	        if (lc != CrowdfundLifecycle.Active) {
218	            revert WrongLifecycleError(lc);
219	        }
220	
...
223	        if (amount > maxContribution_) {
224	            revert AboveMaximumContributionsError(amount, maxContribution_);
225	        }
226	
...
239	            if (refundAmount > 0) {
240	                amount -= refundAmount;
241	                payable(msg.sender).transferEth(refundAmount);
242	            }
243	        } else {
...
256	        if (amount < minContribution_) {
257	            revert BelowMinimumContributionsError(amount, minContribution_);
258	        }
259	
...
263	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
264	            // Removes funding split from contribution amount in a way that
265	            // avoids rounding errors for very small contributions <1e4 wei.
266	            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;
267	        }
268	
...
272	        if (votingPower == 0) revert ZeroVotingPowerError();
...
286	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
287	            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);
288	        }
289	    }
...
308	            if (lc != CrowdfundLifecycle.Won) {
309	                revert WrongLifecycleError(lc);
310	            }
311	        }
...
298	            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();
...
302	            if (totalContributions_ < minTotalContributions_) {
303	                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);
304	            }
305	        } else {
...
324	        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {
325	            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;
326	        }
327	
...
342	        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);
...
344	        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();
...
348	        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {
349	            revert FundingSplitNotConfiguredError();
350	        }
351	
...
372	        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {
373	            revert OnlyPartyDaoError(msg.sender);
374	        }
375	        // Must not be disabled by DAO or host.
...
376	        if (emergencyExecuteDisabled) {
377	            revert OnlyWhenEmergencyActionsAllowedError();
378	        }
379	        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);
...
380	        if (!success) {
381	            res.rawRevert();
382	        }
383	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
...
390	        if (
391	            !party.isHost(msg.sender) &&
392	            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender
393	        ) {
394	            revert OnlyPartyDaoOrHostError(msg.sender);
395	        }
396	        emergencyExecuteDisabled = true;
```
[142..145](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L142-L145)
[148..151](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L148-L151)
[153..159](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L153-L159)
[165](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L165)
[176..179](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L176-L179)
[181..184](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L181-L184)
[185..192](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L185-L192)
[213](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L213)
[217..220](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L217-L220)
[223..226](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L223-L226)
[239..243](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L239-L243)
[256..259](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L256-L259)
[263..268](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L263-L268)
[272](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L272)
[286..289](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L286-L289)
[308..311](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L308-L311)
[298](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L298)
[302..305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L302-L305)
[324..327](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L324-L327)
[342](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L342)
[344](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L344)
[348..351](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L348-L351)
[372..375](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L372-L375)
[376..379](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L376-L379)
[380..383](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L380-L383)
[390..396](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L390-L396)

---

	 - contracts/party/PartyGovernance.sol

```solidity
217	        if (!isHost[msg.sender]) {
218	            revert NotAuthorized();
219	        }
220	    }
...
225	        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
226	            revert NotAuthorized();
227	        }
228	    }
...
234	            if (msg.sender != partyDao) {
235	                revert NotAuthorized();
236	            }
237	        }
...
244	        if (msg.sender != partyDao && !isHost[msg.sender]) {
245	            revert NotAuthorized();
246	        }
247	        _;
...
252	        if (emergencyExecuteDisabled) {
253	            revert OnlyWhenEmergencyActionsAllowedError();
254	        }
255	        _;
...
259	        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {
260	            revert OnlyWhenEnabledError();
261	        }
262	    }
...
277	        if (govOpts.feeBps > 1e4) {
278	            revert InvalidBpsError(govOpts.feeBps);
279	        }
280	        if (govOpts.passThresholdBps > 1e4) {
...
280	        if (govOpts.passThresholdBps > 1e4) {
281	            revert InvalidBpsError(govOpts.passThresholdBps);
282	        }
283	        // Initialize the proposal execution engine.
...
302	        if (govOpts.hosts.length > type(uint8).max) {
303	            revert TooManyHosts();
304	        }
305	        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {
...
314	        if (
315	            functionSelector == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector ||
316	            functionSelector == ERC1155TokenReceiverBase.onERC1155Received.selector ||
317	            functionSelector == IERC721Receiver.onERC721Received.selector
318	        ) {
319	            assembly {
320	                let freeMem := mload(0x40)
321	                mstore(freeMem, functionSelector)
322	                mstore(0x40, add(freeMem, 0x20))
323	                return(freeMem, 0x20)
324	            }
325	        }
326	        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);
...
462	            if (isHost[newPartyHost]) {
463	                revert InvalidNewHostError();
464	            }
465	            isHost[newPartyHost] = true;
...
496	        if (msg.sender != address(this)) {
497	            // Must not require a vote to create a distribution, otherwise
498	            // distributions can only be created through a distribution
499	            // proposal.
500	            if (_getSharedProposalStorage().opts.distributionsRequireVote) {
501	                revert DistributionsRequireVoteError();
502	            }
503	            // Must be an active member.
504	            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
509	        // Prevent creating a distribution if the party has not started.
...
500	            if (_getSharedProposalStorage().opts.distributionsRequireVote) {
501	                revert DistributionsRequireVoteError();
502	            }
503	            // Must be an active member.
...
505	            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {
506	                revert NotAuthorized();
507	            }
508	        }
...
510	        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {
511	            revert PartyNotStartedError();
512	        }
513	        // Get the address of the token distributor.
...
524	        if (tokenType == ITokenDistributor.TokenType.Native) {
525	            return
526	                distributor.createNativeDistribution{ value: amount }(
527	                    Party(payable(address(this))),
528	                    feeRecipient_,
529	                    feeBps_
530	                );
531	        }
532	        // Otherwise must be an ERC20 token distribution.
...
606	            if (
607	                status != ProposalStatus.Voting &&
608	                status != ProposalStatus.Passed &&
609	                status != ProposalStatus.Ready
610	            ) {
611	                revert BadProposalStatusError(status);
612	            }
613	        }
...
622	        if (lastRageQuitTimestamp == block.timestamp) {
623	            revert CannotRageQuitAndAcceptError();
624	        }
625	
...
627	        if (info.hasVoted[msg.sender]) {
628	            revert AlreadyVotedError(msg.sender);
629	        }
630	        // Mark the caller as having voted.
...
636	        if (isHost[msg.sender]) {
637	            ++values.numHostsAccepted;
638	        }
639	        info.values = values;
...
643	        if (
644	            values.passedTime == 0 &&
645	            _areVotesPassing(
646	                values.votes,
647	                values.totalVotingPower,
648	                _getSharedProposalStorage().governanceValues.passThresholdBps
649	            )
650	        ) {
651	            info.values.passedTime = uint40(block.timestamp);
652	            emit ProposalPassed(proposalId);
653	            // Notify third-party platforms that the governance NFT metadata has
654	            // updated for all tokens.
655	            emit BatchMetadataUpdate(0, type(uint256).max);
656	        }
657	        return values.votes;
...
674	            if (
675	                status != ProposalStatus.Voting &&
676	                status != ProposalStatus.Passed &&
677	                status != ProposalStatus.Ready
678	            ) {
679	                revert BadProposalStatusError(status);
680	            }
681	        }
...
724	        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {
725	            revert BadProposalStatusError(status);
726	        }
727	        if (status == ProposalStatus.Ready) {
...
727	        if (status == ProposalStatus.Ready) {
728	            // If the proposal has not been executed yet, make sure it hasn't
729	            // expired. Note that proposals that have been executed
730	            // (but still have more steps) ignore `maxExecutableTime`.
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
738	        }
739	        // Check that the precious list is valid.
...
731	            if (proposal.maxExecutableTime < block.timestamp) {
732	                revert ExecutionTimeExceededError(
733	                    proposal.maxExecutableTime,
734	                    uint40(block.timestamp)
735	                );
736	            }
737	            proposalState.values.executedTime = uint40(block.timestamp);
...
740	        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {
741	            revert BadPreciousListError();
742	        }
743	        // Preemptively set the proposal to completed to avoid it being executed
...
756	        if (!completed) {
757	            // Proposal did not complete.
758	            proposalState.values.completedTime = 0;
759	        }
760	    }
...
781	            if (status != ProposalStatus.InProgress) {
782	                revert BadProposalStatusError(status);
783	            }
784	        }
...
797	            if (globalMaxCancelDelay != 0) {
798	                // Only if we have one set.
799	                if (cancelDelay > globalMaxCancelDelay) {
800	                    cancelDelay = globalMaxCancelDelay;
801	                }
802	            }
803	            if (globalMinCancelDelay != 0) {
...
799	                if (cancelDelay > globalMaxCancelDelay) {
800	                    cancelDelay = globalMaxCancelDelay;
801	                }
802	            }
...
803	            if (globalMinCancelDelay != 0) {
804	                // Only if we have one set.
805	                if (cancelDelay < globalMinCancelDelay) {
806	                    cancelDelay = globalMinCancelDelay;
807	                }
808	            }
809	            uint256 cancelTime = values.executedTime + cancelDelay;
...
805	                if (cancelDelay < globalMinCancelDelay) {
806	                    cancelDelay = globalMinCancelDelay;
807	                }
808	            }
...
811	            if (block.timestamp < cancelTime) {
812	                revert ProposalCannotBeCancelledYetError(
813	                    uint40(block.timestamp),
814	                    uint40(cancelTime)
815	                );
816	            }
817	        }
...
826	            if (!success) {
827	                resultData.rawRevert();
828	            }
829	        }
...
847	        if (!success) {
848	            res.rawRevert();
849	        }
850	        emit EmergencyExecute(targetAddress, targetCallData, amountEth);
...
889	            if (!success) {
890	                resultData.rawRevert();
891	            }
892	            nextProgressData = abi.decode(resultData, (bytes));
...
911	        if (snapsLength != 0) {
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
923	            // Hint was wrong, fallback to binary search to find snapshot.
924	            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);
925	            // Check that snapshot was found.
926	            if (hintIndex != type(uint256).max) {
927	                return snaps[hintIndex];
928	            }
929	        }
930	
...
912	            if (
913	                // Hint is within bounds.
914	                hintIndex < snapsLength &&
915	                // Snapshot is not too recent.
916	                snaps[hintIndex].timestamp <= timestamp &&
917	                // Snapshot is not too old.
918	                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)
919	            ) {
920	                return snaps[hintIndex];
921	            }
922	
...
926	            if (hintIndex != type(uint256).max) {
927	                return snaps[hintIndex];
928	            }
929	        }
...
979	        if (newDelegate == address(0) || oldDelegate == address(0)) {
980	            revert InvalidDelegateError();
981	        }
982	        if (oldDelegate != voter && oldDelegate != newDelegate) {
...
982	        if (oldDelegate != voter && oldDelegate != newDelegate) {
983	            // Remove past voting power from old delegate.
984	            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(
985	                oldDelegate
986	            );
987	            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({
988	                timestamp: uint40(block.timestamp),
989	                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -
990	                    oldSnap.intrinsicVotingPower,
991	                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,
992	                isDelegated: oldDelegateSnap.isDelegated
993	            });
994	            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);
995	        }
996	        if (newDelegate != voter) {
...
996	        if (newDelegate != voter) {
997	            // Not delegating to self.
998	            // Add new voting power to new delegate.
999	            VotingPowerSnapshot memory newDelegateSnap = _getLastVotingPowerSnapshotForVoter(
1000	                newDelegate
1001	            );
1002	            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +
1003	                newSnap.intrinsicVotingPower;
1004	            if (newDelegate == oldDelegate) {
1005	                // If the old and new delegate are the same, subtract the old
1006	                // intrinsic voting power of the voter, or else we will double
1007	                // count a portion of it.
1008	                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;
1009	            }
1010	            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({
1011	                timestamp: uint40(block.timestamp),
1012	                delegatedVotingPower: newDelegateDelegatedVotingPower,
1013	                intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,
1014	                isDelegated: newDelegateSnap.isDelegated
1015	            });
1016	            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);
1017	        }
1018	    }
...
1004	            if (newDelegate == oldDelegate) {
1005	                // If the old and new delegate are the same, subtract the old
1006	                // intrinsic voting power of the voter, or else we will double
1007	                // count a portion of it.
1008	                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;
1009	            }
1010	            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({
...
1033	        if (n != 0) {
1034	            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];
1035	            if (lastSnap.timestamp == snap.timestamp) {
1036	                voterSnaps[n - 1] = snap;
1037	                return;
1038	            }
1039	        }
1040	        voterSnaps.push(snap);
...
1035	            if (lastSnap.timestamp == snap.timestamp) {
1036	                voterSnaps[n - 1] = snap;
1037	                return;
1038	            }
1039	        }
...
1048	        if (n != 0) {
1049	            snap = voterSnaps[n - 1];
1050	        }
1051	    }
...
1055	        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1056	            flags = flags | LibProposal.PROPOSAL_FLAG_UNANIMOUS;
1057	        }
1058	        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
...
1058	        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1059	            flags = flags | LibProposal.PROPOSAL_FLAG_HOSTS_ACCEPT;
1060	        }
1061	        return flags;
...
1068	        if (pv.proposedTime == 0) {
1069	            return ProposalStatus.Invalid;
1070	        }
1071	        // Executed at least once.
...
1072	        if (pv.executedTime != 0) {
1073	            if (pv.completedTime == 0) {
1074	                return ProposalStatus.InProgress;
1075	            }
1076	            // completedTime high bit will be set if cancelled.
1077	            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {
1078	                return ProposalStatus.Cancelled;
1079	            }
1080	            return ProposalStatus.Complete;
1081	        }
1082	        // Vetoed.
...
1073	            if (pv.completedTime == 0) {
1074	                return ProposalStatus.InProgress;
1075	            }
1076	            // completedTime high bit will be set if cancelled.
...
1077	            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {
1078	                return ProposalStatus.Cancelled;
1079	            }
1080	            return ProposalStatus.Complete;
...
1083	        if (pv.votes == type(uint96).max) {
1084	            return ProposalStatus.Defeated;
1085	        }
1086	        uint40 t = uint40(block.timestamp);
...
1088	        if (pv.passedTime != 0) {
1089	            // Ready.
1090	            if (pv.passedTime + gv.executionDelay <= t) {
1091	                return ProposalStatus.Ready;
1092	            }
1093	            // If unanimous, we skip the execution delay.
1094	            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1095	                return ProposalStatus.Ready;
1096	            }
1097	            // If all hosts voted, skip execution delay
1098	            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1099	                return ProposalStatus.Ready;
1100	            }
1101	            // Passed.
1102	            return ProposalStatus.Passed;
1103	        }
1104	        // Voting window expired.
...
1090	            if (pv.passedTime + gv.executionDelay <= t) {
1091	                return ProposalStatus.Ready;
1092	            }
1093	            // If unanimous, we skip the execution delay.
...
1094	            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {
1095	                return ProposalStatus.Ready;
1096	            }
1097	            // If all hosts voted, skip execution delay
...
1098	            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {
1099	                return ProposalStatus.Ready;
1100	            }
1101	            // Passed.
...
1105	        if (pv.proposedTime + gv.voteDuration <= t) {
1106	            return ProposalStatus.Defeated;
1107	        }
1108	        return ProposalStatus.Voting;
...
1141	        if (preciousTokens.length != preciousTokenIds.length) {
1142	            revert MismatchedPreciousListLengths();
1143	        }
1144	        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);
...
1168	        if (expectedHash != actualHash) {
1169	            revert BadProposalHashError(actualHash, expectedHash);
1170	        }
1171	    }
```
[217..220](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L217-L220)
[225..228](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L225-L228)
[234..237](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L234-L237)
[244..247](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L244-L247)
[252..255](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L252-L255)
[259..262](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L259-L262)
[277..280](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L277-L280)
[280..283](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L280-L283)
[302..305](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L302-L305)
[314..326](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L314-L326)
[462..465](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L462-L465)
[496..509](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L496-L509)
[500..503](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L500-L503)
[505..508](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L505-L508)
[510..513](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L510-L513)
[524..532](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L524-L532)
[606..613](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L606-L613)
[622..625](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L622-L625)
[627..630](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L627-L630)
[636..639](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L636-L639)
[643..657](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L643-L657)
[674..681](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L674-L681)
[724..727](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L724-L727)
[727..739](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L727-L739)
[731..737](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L731-L737)
[740..743](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L740-L743)
[756..760](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L756-L760)
[781..784](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L781-L784)
[797..803](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L797-L803)
[799..802](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L799-L802)
[803..809](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L803-L809)
[805..808](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L805-L808)
[811..817](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L811-L817)
[826..829](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L826-L829)
[847..850](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L847-L850)
[889..892](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L889-L892)
[911..930](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L911-L930)
[912..922](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L912-L922)
[926..929](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L926-L929)
[979..982](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L979-L982)
[982..996](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L982-L996)
[996..1018](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L996-L1018)
[1004..1010](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1004-L1010)
[1033..1040](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1033-L1040)
[1035..1039](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1035-L1039)
[1048..1051](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1048-L1051)
[1055..1058](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1055-L1058)
[1058..1061](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1058-L1061)
[1068..1071](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1068-L1071)
[1072..1082](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1072-L1082)
[1073..1076](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1073-L1076)
[1077..1080](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1077-L1080)
[1083..1086](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1083-L1086)
[1088..1104](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1088-L1104)
[1090..1093](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1090-L1093)
[1094..1097](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1094-L1097)
[1098..1101](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1098-L1101)
[1105..1108](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1105-L1108)
[1141..1144](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1141-L1144)
[1168..1171](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L1168-L1171)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
62	        if (!isAuthority[msg.sender]) {
63	            revert NotAuthorized();
64	        }
...
68	        if (msg.sender != address(this)) {
69	            revert NotAuthorized();
70	        }
...
106	        if (customizationPresetId != 0) {
107	            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))
108	                .useCustomizationPreset(customizationPresetId);
109	        }
...
179	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {
180	            unchecked {
181	                votingPower_ = totalVotingPower - mintedVotingPower_;
182	            }
183	        }
...
196	        if (delegate_ != address(0)) {
197	            delegate = delegate_;
198	        }
...
216	        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {
217	            unchecked {
218	                votingPower = totalVotingPower - mintedVotingPower_;
219	            }
220	        }
...
277	            if (checkIfAuthorizedToBurn) {
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
285	            }
...
278	                if (
279	                    msg.sender != owner &&
280	                    getApproved[tokenId] != msg.sender &&
281	                    !isApprovedForAll[owner][msg.sender]
282	                ) {
283	                    revert NotAuthorized();
284	                }
...
321	        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {
322	            revert CannotDisableRageQuitAfterInitializationError();
323	        }
...
328	        if (
329	            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||
330	            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY
331	        ) {
332	            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);
333	        }
...
350	        if (tokenIds.length == 0) revert NothingToBurnError();
...
357	        if (!isAuthority_) {
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
366	        }
...
358	            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
365	            }
...
359	                if (
360	                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||
361	                    currentRageQuitTimestamp < block.timestamp
362	                ) {
363	                    revert CannotRageQuitError(currentRageQuitTimestamp);
364	                }
...
381	                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();
...
415	                if (fee > 0) {
416	                    amount -= fee;
417	
418	                    // Transfer fee to fee recipient.
419	                    if (address(token) == ETH_ADDRESS) {
420	                        payable(feeRecipient).transferEth(fee);
421	                    } else {
422	                        token.compatTransfer(feeRecipient, fee);
423	                    }
424	                }
...
426	                if (amount > 0) {
427	                    uint256 minAmount = minWithdrawAmounts[i];
428	
429	                    // Check amount is at least minimum.
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
433	
434	                    // Transfer token from party to recipient.
435	                    if (address(token) == ETH_ADDRESS) {
436	                        payable(receiver).transferEth(amount);
437	                    } else {
438	                        token.compatTransfer(receiver, amount);
439	                    }
440	                }
...
430	                    if (amount < minAmount) {
431	                        revert BelowMinWithdrawAmountError(amount, minAmount);
432	                    }
```
[62..64](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L62-L64)
[68..70](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L68-L70)
[106..109](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L106-L109)
[179..183](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L179-L183)
[196..198](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L196-L198)
[216..220](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L216-L220)
[277..285](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L277-L285)
[278..284](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L278-L284)
[321..323](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L321-L323)
[328..333](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L328-L333)
[350](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L350)
[357..366](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L357-L366)
[358..365](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L358-L365)
[359..364](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L359-L364)
[381](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L381)
[415..424](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L415-L424)
[426..440](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L426-L440)
[430..432](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L430-L432)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
128	        if (oldImpl != address(0)) return;
129	
...
131	        if (initializeData.length == 0) return;
132	
...
150	        if (params.proposalId == 0) {
151	            revert ZeroProposalIdError();
152	        }
153	        Storage storage stor = _getStorage();
...
155	        if (currentInProgressProposalId == 0) {
156	            // No proposal is currently in progress.
157	            // Mark this proposal as the one in progress.
158	            stor.currentInProgressProposalId = params.proposalId;
159	        } else if (currentInProgressProposalId != params.proposalId) {
160	            // Only one proposal can be in progress at a time.
161	            revert ProposalExecutionBlockedError(params.proposalId, currentInProgressProposalId);
162	        }
163	        {
...
159	        } else if (currentInProgressProposalId != params.proposalId) {
160	            // Only one proposal can be in progress at a time.
161	            revert ProposalExecutionBlockedError(params.proposalId, currentInProgressProposalId);
162	        }
163	        {
...
179	                if (nextProgressDataHash != progressDataHash) {
180	                    revert ProposalProgressDataInvalidError(progressDataHash, nextProgressDataHash);
181	                }
182	            }
...
169	                if (params.progressData.length != 0) {
170	                    revert ProposalProgressDataInvalidError(
171	                        keccak256(params.progressData),
172	                        nextProgressDataHash
173	                    );
174	                }
175	            } else {
...
209	        if (proposalId == 0) {
210	            revert ZeroProposalIdError();
211	        }
212	        Storage storage stor = _getStorage();
...
216	            if (currentInProgressProposalId != proposalId) {
217	                revert ProposalNotInProgressError(proposalId);
218	            }
219	        }
...
227	        if (address(validator) == address(1)) {
228	            // Signature set by party to be always valid
229	            return IERC1271.isValidSignature.selector;
230	        }
231	        if (address(validator) != address(0)) {
...
231	        if (address(validator) != address(0)) {
232	            return validator.isValidSignature(hash, signature);
233	        }
234	        if (tx.origin == address(0)) {
...
234	        if (tx.origin == address(0)) {
235	            validator = getSignatureValidatorForHash(0);
236	            if (address(validator) == address(0)) {
237	                // Use global off-chain signature validator
238	                validator = IERC1271(
239	                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)
240	                );
241	            }
242	            return validator.isValidSignature(hash, signature);
243	        }
244	        return 0;
...
236	            if (address(validator) == address(0)) {
237	                // Use global off-chain signature validator
238	                validator = IERC1271(
239	                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)
240	                );
241	            }
242	            return validator.isValidSignature(hash, signature);
...
252	        if (pt == ProposalType.ListOnOpensea) {
253	            nextProgressData = _executeListOnOpensea(params);
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
254	        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {
255	            nextProgressData = _executeListOnOpenseaAdvanced(params);
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
256	        } else if (pt == ProposalType.ListOnZora) {
257	            nextProgressData = _executeListOnZora(params);
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
258	        } else if (pt == ProposalType.Fractionalize) {
259	            nextProgressData = _executeFractionalize(params);
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
260	        } else if (pt == ProposalType.ArbitraryCalls) {
261	            nextProgressData = _executeArbitraryCalls(
262	                params,
263	                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth
264	            );
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
265	        } else if (pt == ProposalType.Distribute) {
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
270	            nextProgressData = _executeDistribute(params);
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
271	        } else if (pt == ProposalType.AddAuthority) {
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
276	            nextProgressData = _executeAddAuthority(params);
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
277	        } else if (pt == ProposalType.Operator) {
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
282	            nextProgressData = _executeOperation(params);
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
283	        } else if (pt == ProposalType.SetSignatureValidatorProposal) {
284	            nextProgressData = _executeSetSignatureValidator(params);
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
285	        } else if (pt == ProposalType.SetGovernanceParameterProposal) {
286	            nextProgressData = _executeSetGovernanceParameter(params);
287	        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {
288	            _executeUpgradeProposalsImplementation(params.proposalData);
289	        } else {
290	            revert UnsupportedProposalTypeError(uint32(pt));
291	        }
292	    }
...
278	            if (!_getSharedProposalStorage().opts.allowOperators) {
279	                revert ProposalDisabled(pt);
280	            }
281	
...
272	            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {
273	                revert ProposalDisabled(pt);
274	            }
275	
...
266	            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {
267	                revert ProposalDisabled(pt);
268	            }
269	
...
303	        if (proposalData.length < 4) {
304	            revert MalformedProposalDataError();
305	        }
306	        assembly {
...
324	        if (expectedImpl != address(newImpl)) {
325	            revert UnexpectedProposalEngineImplementationError(
326	                newImpl,
327	                IProposalExecutionEngine(expectedImpl)
328	            );
329	        }
330	        _initProposalImpl(newImpl, initData);
```
[128..129](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L128-L129)
[131..132](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L131-L132)
[150..153](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L150-L153)
[155..163](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L155-L163)
[159..163](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L159-L163)
[179..182](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L179-L182)
[169..175](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L169-L175)
[209..212](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L209-L212)
[216..219](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L216-L219)
[227..231](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L227-L231)
[231..234](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L231-L234)
[234..244](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L234-L244)
[236..242](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L236-L242)
[252..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L252-L292)
[254..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L254-L292)
[256..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L256-L292)
[258..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L258-L292)
[260..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L260-L292)
[265..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L265-L292)
[271..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L271-L292)
[277..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L277-L292)
[283..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L283-L292)
[285..292](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L285-L292)
[278..281](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L278-L281)
[272..275](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L272-L275)
[266..269](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L266-L269)
[303..306](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L303-L306)
[324..330](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L324-L330)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
50	        if (!s) {
51	            r.rawRevert();
52	        }
```
[50..52](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L50-L52)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
32	        if (proposalData.voteDuration != 0) {
33	            if (proposalData.voteDuration < 1 hours) {
34	                revert InvalidGovernanceParameter(proposalData.voteDuration);
35	            }
36	            emit VoteDurationSet(
37	                _getSharedProposalStorage().governanceValues.voteDuration,
38	                proposalData.voteDuration
39	            );
40	            _getSharedProposalStorage().governanceValues.voteDuration = proposalData.voteDuration;
41	        }
...
33	            if (proposalData.voteDuration < 1 hours) {
34	                revert InvalidGovernanceParameter(proposalData.voteDuration);
35	            }
...
42	        if (proposalData.executionDelay != 0) {
43	            if (proposalData.executionDelay > 30 days) {
44	                revert InvalidGovernanceParameter(proposalData.executionDelay);
45	            }
46	            emit ExecutionDelaySet(
47	                _getSharedProposalStorage().governanceValues.executionDelay,
48	                proposalData.executionDelay
49	            );
50	            _getSharedProposalStorage().governanceValues.executionDelay = proposalData
51	                .executionDelay;
52	        }
...
43	            if (proposalData.executionDelay > 30 days) {
44	                revert InvalidGovernanceParameter(proposalData.executionDelay);
45	            }
...
53	        if (proposalData.passThresholdBps != 0) {
54	            if (proposalData.passThresholdBps > 10000) {
55	                revert InvalidGovernanceParameter(proposalData.passThresholdBps);
56	            }
57	            emit PassThresholdBpsSet(
58	                _getSharedProposalStorage().governanceValues.passThresholdBps,
59	                proposalData.passThresholdBps
60	            );
61	            _getSharedProposalStorage().governanceValues.passThresholdBps = proposalData
62	                .passThresholdBps;
63	        }
...
54	            if (proposalData.passThresholdBps > 10000) {
55	                revert InvalidGovernanceParameter(proposalData.passThresholdBps);
56	            }
```
[32..41](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L32-L41)
[33..35](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L33-L35)
[42..52](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L42-L52)
[43..45](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L43-L45)
[53..63](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L53-L63)
[54..56](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L54-L56)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
53	        if (keccak256(encodedPacket) != hash) {
54	            revert MessageHashMismatch();
55	        }
...
62	        if (signerVotingPowerBps == 0 && party.balanceOf(signer) == 0) {
63	            // Must own a party card or be delegatated voting power
64	            revert NotMemberOfParty();
65	        }
...
71	        if (
72	            thresholdBps == 0 ||
73	            (signerVotingPowerBps > totalVotingPower &&
74	                signerVotingPowerBps / totalVotingPower >= thresholdBps)
75	        ) {
76	            return IERC1271.isValidSignature.selector;
77	        }
```
[53..55](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L53-L55)
[62..65](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L62-L65)
[71..77](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L71-L77)

---

	 - contracts/utils/Implementation.sol

```solidity
23	        if (address(this) == implementation) {
24	            revert OnlyDelegateCallError();
25	        }
...
30	        if (initialized) revert AlreadyInitialized();
```
[23..25](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L23-L25)
[30](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L30)


</details>

-------
### [D-02] Optimize Gas Spend Using `0.8.20` and Optimizer Features
<a name="D-02"></a>
[To the top](#TOP)

The rule itself is correct. But here are the cases in which SemVer allows you to use version up to `0.8.20`

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 10 instances</summary>


---

	 - contracts/crowdfund/InitialETHCrowdfund.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol#L2)

---

	 - contracts/crowdfund/ETHCrowdfundBase.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol#L2)

---

	 - contracts/party/PartyGovernance.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L2)

---

	 - contracts/party/PartyGovernanceNFT.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L2)

---

	 - contracts/proposals/ProposalExecutionEngine.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalExecutionEngine.sol#L2)

---

	 - contracts/proposals/ProposalStorage.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ProposalStorage.sol#L2)

---

	 - contracts/proposals/SetGovernanceParameterProposal.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetGovernanceParameterProposal.sol#L2)

---

	 - contracts/proposals/SetSignatureValidatorProposal.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/SetSignatureValidatorProposal.sol#L2)

---

	 - contracts/signature-validators/OffChainSignatureValidator.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/signature-validators/OffChainSignatureValidator.sol#L2)

---

	 - contracts/utils/Implementation.sol

```solidity
2	pragma solidity 0.8.20;
```
[2](https://github.com/code-423n4/2023-10-party/blob/main/contracts/utils/Implementation.sol#L2)


</details>

-------
### [D-03] `abi.encode()` is less efficient than `abi.encodepacked()`
<a name="D-03"></a>
[To the top](#TOP)

`abi.encodePacked()` does not always save gas over `abi.encode()` and in fact often costs [more](https://gist.github.com/IllIllI000/2ee970e4f05af4d2a3d89a56b5cc93a5) gas. The [comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison) sometimes linked to itself even shows that when addresses are involved, the packed flavor costs more gas.

#### <ins>Proof Of Concept</ins>

<details>

<summary>see 1 instances</summary>


---

	 - contracts/party/PartyGovernance.sol

```solidity
286	            abi.encode(proposalEngineOpts)
```
[286](https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L286)


</details>
